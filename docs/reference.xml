<?xml version="1.0" encoding="utf-8"?>
<!--
  To turn this XML document into a "docs.cfg" that can be read by the AssaultCube engine, simply
  uncomment the below xml-stylesheet. Then comment the xml-stylesheet below that one. Save your changes.
  Then refresh this XML document in your web browser and copy/paste the output into ./config/docs.cfg
  If you are using Firefox and you encounter any CORS-related errors try this configuration change -> https://stackoverflow.com/a/18495435
  
  Security concerns have made accessing XSLT locally illegal, even w/ "allow-file-access-from-files" (for Google-Chrome). 
  If you have python3 use https://stackoverflow.com/a/33814529/3022387 solution:
     Go to this docs directory and call: python3 -m http.server
     Then browse to http://localhost:8000/reference.xml
  <?xml-stylesheet type="text/xsl" href="xml/cuberef2cubescript.xslt"?>
-->


<!--
  You may be able to redistribute this content under specific conditions.
  Please read the licensing information, available @ https://assault.cubers.net/docs/license.html for the
  conditions that would apply to what you may be redistributing.

-->
<?xml-stylesheet type="text/xsl" href="xml/cuberef2xhtml.xslt"?>
<!-- Please ensure the following when writing content for this reference.xml:
  General
    * Do NOT use any XML editor that breaks the formatting!!!
       * This is a big file, please ensure it remains readable and use correct indentations.
       * Please see how the markup is currently written and write your new markup accordingly!
    * Do NOT write tutorial-like content, this is a reference.
       * Focus on the technical description of identifiers as a single unit.
       * Some examples may be okay.
    * See the XML schema (./xml/cuberef.xsd) for details on the elements.
    * Use a CDATA section for content that requires special characters.

  Sections
    * A section represents a group of identifiers.
    * Choose sections based on the usage areas of identifiers.

  Identifiers
    * An identifier represents a command, variable or an alias that is available through CubeScript.
    * Identifiers must be unique across sections (i.e. don't double-up!)
    * Avoid documenting CubeScript in ./config/*  (such as those in defaults.cfg) that aren't important.

  Description
    * Provide a short and concise description of what the identifier does or represents, omit details.

  Arguments
    * Use a single character token if possible.
    * Keep the argument description simple, write a remark for details.
    * Write restricted integer values in the way of 0..3 (0 to 3) and 1..* (1 to 'infinite').
    * If no restrictions apply to values, specify the pseudo data type.
    * If the meaning of the arguments depends on other arguments, create multiple identifiers
      with the name containing the depending argument. Example: 'newent type v1 v2 v3 v4' depends
      on the type, therefore it's split to 'newent light', 'newent ammo', etc.

  Remarks
    * Describe details and special behavior.
    * Give _short_ examples if needed.

  References
    * Refer to other identifiers that are _directly_ related.
    * Refer to _official_ online sources, like the wiki.
    * Name other (offline) sources without URI or identifier.
-->


<cuberef xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="https://assault.cubers.net/docs/xml"
name="AssaultCube Documentation" version="Current" xsi:schemaLocation="xml/cuberef.xsd">
  <sections sort="true">
  <!--
    Sections available: Cubescript, General, Gameplay, Game modes, Keyboard and mouse, Visuals, Heads-Up Display, Sound,
                        Serverbrowser, Server commands, Authentication, Editing, Editing configs, Menus, Ingame reference,
                        Bot mode, Optional, TODO
  -->
    <!-- CubeScript language Section Starts -->
    <section name="CubeScript" sortindex="00">
      <description>This section describes identifiers that are closely related to the CubeScript language.</description>
      <identifiers sort="true">

        <command name="&lt;f">
          <description>Compares if a particular floating-point value is smaller than another floating-point value.</description>
          <return token="F" description="(true)1||0(false)"/>
          <arguments>
            <argument token="A" description="The first value."/>
            <argument token="B" description="The second value."/>
          </arguments>
        </command>

        <command name="&lt;=f">
          <description>Compares if a particular floating-point value is less than or equal to another floating-point value.</description>
          <return token="F" description="(true)1||0(false)"/>
          <arguments>
            <argument token="A" description="The first value."/>
            <argument token="B" description="The second value."/>
          </arguments>
        </command>

        <command name="=f">
          <description>Compares if a particular floating-point value is equal to another floating-point value.</description>
          <return token="F" description="(true)1||0(false)"/>
          <arguments>
            <argument token="A" description="The first value."/>
            <argument token="B" description="The second value."/>
          </arguments>
        </command>

        <command name="&gt;f">
          <description>Determines if the first floating-point value is greater than the second floating-point value.</description>
          <return token="F" description="(true)1||0(false)"/>
          <arguments>
            <argument token="A" description="the first value"/>
            <argument token="B" description="the second value"/>
          </arguments>
        </command>

        <command name="&gt;=f">
          <description>Determines if the first floating-point value is greater than or equal to the second floating-point value.</description>
          <return token="F" description="(true)1||0(false)"/>
          <arguments>
            <argument token="A" description="the first value"/>
            <argument token="B" description="the second value"/>
          </arguments>
        </command>

        <command name="!=f">
          <description>Determines if the first floating-point value is not equal to the second floating-point value.</description>
          <return token="F" description="(true)1||0(false)"/>
          <arguments>
            <argument token="A" description="the first value"/>
            <argument token="B" description="the second value"/>
          </arguments>
        </command>

        <command name="result">
          <description>Sets the result value of a cubescript block.</description>
          <arguments>
            <argument token="R" description="the result"/>
          </arguments>
          <references>
            <identifierReference identifier="execute"/>
          </references>
        </command>

        <command name="execute">
          <description>Executes the specified string as cubescript.</description>
          <arguments>
            <argument token="S" description="the string to execute"/>
          </arguments>
          <examples>
            <example>
              <code><![CDATA[execute (concat echo (addpunct fov 3))]]></code>
              <explanation>Example output: 90.0</explanation>
            </example>
          </examples>
        </command>

        <command name="push">
          <description>Temporarily redefines the value of an alias.</description>
          <arguments>
            <argument token="N" description="alias name"/>
            <argument token="A" description="action"/>
          </arguments>
          <examples>
            <example>
              <code><![CDATA[p = 1; push p 2; echo $p]]></code>
              <explanation>Output: 2</explanation>
            </example>
          </examples>
          <references>
            <identifierReference identifier="pop"/>
          </references>
        </command>

        <command name="getalias">
          <description>Returns the value of the alias.</description>
          <arguments>
            <argument token="N" description="alias name"/>
          </arguments>
          <references>
            <identifierReference identifier="storesets"/>
            <identifierReference identifier="getvarrange"/>
          </references>
        </command>

        <command name="getvarrange">
          <description>Gets range attribute for builtin variable.</description>
          <arguments>
            <argument token="W" description="what" valueNotes="min, max, default"/>
            <argument token="N" description="the name of any builtin variable (integer or float)"/>
          </arguments>
          <references>
            <identifierReference identifier="getalias"/>
          </references>
        </command>

        <command name="isIdent">
          <description>Returns whether or not there is an identifier by that name.</description>
          <arguments>
            <argument token="N" description="identifier name"/>
          </arguments>
        </command>

        <command name="modf">
          <description>Performs a floating-point modulo operation.</description>
          <arguments>
            <argument token="A" description="the dividend"/>
            <argument token="B" description="the divisor"/>
          </arguments>
          <return token="F" description="the modulo value"/>
          <examples>
            <example>
              <code><![CDATA[echo (modf 7.5 12.5)]]></code>
              <explanation>Output: 7.5</explanation>
            </example>
            <example>
              <code><![CDATA[echo (modf 17.5 12.5)]]></code>
              <explanation>Output: 5.0</explanation>
            </example>
          </examples>
        </command>

        <command name="powf">
          <description>Returns A raised to the power of B (floating-point).</description>
          <arguments>
            <argument token="A" description="the mantissa"/>
            <argument token="B" description="the exponent"/>
          </arguments>
          <return token="F" description="A raised to the power of B"/>
        </command>

        <command name="pop">
          <description>Resets a previously pushed alias to it's original value.</description>
          <remarks>
            <remark>
              It is allowed to use multiple arguments for "pop".
              So instead of "pop var_a ; pop var_b" you can write "pop var_a var_b".
              Also, "pop" will now give back the removed value of the first alias from the argument list.
              This allows using the pop'd value one last time.
            </remark>
          </remarks>
          <arguments>
            <argument token="A" description="alias"/>
          </arguments>
          <examples>
            <example>
              <code><![CDATA[p = 1; push p 2; pop p; echo $p]]></code>
              <explanation>Output: 1</explanation>
            </example>
          </examples>
          <references>
            <identifierReference identifier="push"/>
          </references>
        </command>

        <command name="+">
          <description>Performs an addition 2 or more numbers.</description>
          <remarks>
            <remark>
              Example: echo the sum of x and y is (+ $x $y)
            </remark>
          </remarks>
          <arguments>
            <argument token="A" description="the first summand"/>
            <argument token="B" description="the summand(s)"/>
          </arguments>
          <return token="N" description="the sum"/>
        </command>

        <command name="-">
          <description>Performs a subtraction.</description>
          <arguments>
            <argument token="A" description="the minuend"/>
            <argument token="B" description="the subtrahend"/>
          </arguments>
          <return token="N" description="the difference"/>
        </command>

        <command name="*">
          <description>Performs a multiplication 2 or more numbers.</description>
          <arguments>
            <argument token="A" description="the multiplicand"/>
            <argument token="B" description="the multiplier(s)"/>
          </arguments>
          <return token="N" description="the product"/>
        </command>

        <command name="div">
          <description>Performs an integer division.</description>
          <arguments>
            <argument token="A" description="the dividend"/>
            <argument token="B" description="the divisor"/>
          </arguments>
          <return token="N" description="the quotient (integer)"/>
        </command>

        <command name="-f">
          <description>Subtracts two floating-point numbers.</description>
          <arguments>
            <argument token="A" description="the minuend" valueNotes="float"/>
            <argument token="B" description="the subtrahend" valueNotes="float"/>
          </arguments>
          <return token="F" description="the difference"/>
        </command>

        <command name="+f">
          <description>Adds up two or more floating-point numbers.</description>
          <arguments>
            <argument token="A" description="the first summand" valueNotes="float"/>
            <argument token="B" description="the summand(s)" valueNotes="float"/>
          </arguments>
          <return token="F" description="the sum"/>
        </command>

        <command name="*f">
          <description>Performs a floating point multiplication 2 or more numbers.</description>
          <arguments>
            <argument token="A" description="the multiplicand"/>
            <argument token="B" description="the multiplier(s)"/>
          </arguments>
          <return token="N" description="the product"/>
        </command>

        <command name="divf">
          <description>Performs a division with floating-point precision.</description>
          <arguments>
            <argument token="A" description="" valueNotes="the dividend"/>
            <argument token="B" description="" valueNotes="the divisor"/>
          </arguments>
          <return token="F" description="the quotient (floating-point)"/>
        </command>

        <command name="+=">
          <description>Adds a value to an alias.</description>
          <remarks>
            <remark>
              Example: += foo 1337
            </remark>
          </remarks>
          <arguments>
            <argument token="A" description="the alias to add to"/>
            <argument token="B" description="value to be added"/>
          </arguments>
        </command>

        <command name="-=">
          <description>Subtracts a value from an alias.</description>
          <remarks>
            <remark>
              Example: -= foo 1337
            </remark>
          </remarks>
          <arguments>
            <argument token="A" description="the alias to subtract from"/>
            <argument token="B" description="value to be subtracted"/>
          </arguments>
        </command>

        <command name="*=">
          <description>Multiplies an alias by a value.</description>
          <remarks>
            <remark>
              Example: *= foo 1337
            </remark>
          </remarks>
          <arguments>
            <argument token="A" description="the alias to be multiplied"/>
            <argument token="B" description="the multiplier"/>
          </arguments>
        </command>

        <command name="div=">
          <description>Divides an alias by a value.</description>
          <remarks>
            <remark>
              Example: div= foo 1337
            </remark>
          </remarks>
          <arguments>
            <argument token="A" description="the alias to be divided"/>
            <argument token="B" description="the divisor"/>
          </arguments>
        </command>

        <command name="+=f">
          <description>Adds a floating-point value to an alias.</description>
          <remarks>
            <remark>
              Example: +=f foo 13.37
            </remark>
          </remarks>
          <arguments>
            <argument token="A" description="the alias to add to"/>
            <argument token="B" description="value to be added"/>
          </arguments>
        </command>

        <command name="-=f">
          <description>Subtracts a floating-point value from an alias.</description>
          <remarks>
            <remark>
              Example: -=f foo 13.37
            </remark>
          </remarks>
          <arguments>
            <argument token="A" description="the alias to subtract from"/>
            <argument token="B" description="value to be subtracted"/>
          </arguments>
        </command>

        <command name="*=f">
          <description>Multiplies an alias by a floating-point value.</description>
          <remarks>
            <remark>
              Example: *=f foo 13.37
            </remark>
          </remarks>
          <arguments>
            <argument token="A" description="the alias to be multiplied"/>
            <argument token="B" description="the multiplier"/>
          </arguments>
        </command>

        <command name="div=f">
          <description>Divides an alias by a floating-point value.</description>
          <remarks>
            <remark>
              Example: div=f foo 13.37
            </remark>
          </remarks>
          <arguments>
            <argument token="A" description="the alias to be divided"/>
            <argument token="B" description="the divisor"/>
          </arguments>
        </command>

        <command name="mod">
          <description>Performs a modulo operation.</description>
          <arguments>
            <argument token="A" description="the dividend"/>
            <argument token="B" description="the divisor"/>
          </arguments>
          <return token="N" description="the modulo value"/>
        </command>

        <command name="=">
          <description>Determines if two values are equal.</description>
          <arguments>
            <argument token="A" description="first value"/>
            <argument token="B" description="second value"/>
          </arguments>
          <return token="N" description="the equality" valueNotes="1 (equal) or 0 (not equal)"/>
          <examples>
            <example>
              <code><![CDATA[echo there are only (concatword (= 1 1) (= 1 0)) types of people in the world]]></code>
              <explanation>Output: there are only 10 types of people in the world</explanation>
            </example>
          </examples>
        </command>

        <command name="!=">
          <description>Determines if two values are not equal.</description>
          <arguments>
            <argument token="A" description="first value"/>
            <argument token="B" description="second value"/>
          </arguments>
          <return token="N" description="the inequality" valueNotes="1 (not equal) or 0 (equal)"/>
        </command>

        <command name="&lt;">
          <description>Determines if a value is smaller than a second value.</description>
          <arguments>
            <argument token="A" description="the first value"/>
            <argument token="B" description="the second value"/>
          </arguments>
          <return token="N" description="the comparison" valueNotes="1 (smaller) or 0 (not smaller)"/>
        </command>

        <command name="&gt;">
          <description>Determines if a value is bigger than a second value.</description>
          <arguments>
            <argument token="A" description="the first value"/>
            <argument token="B" description="the second value"/>
          </arguments>
          <return token="N" description="the comparison" valueNotes="1 (bigger) or 0 (not bigger)"/>
        </command>

        <command name="&lt;=">
          <description>Determines if a values is less than or equal to a second value.</description>
          <arguments>
            <argument token="A" description="the first value"/>
            <argument token="B" description="the second value"/>
          </arguments>
        </command>

        <command name="&gt;=">
          <description>Determines if a values is greater than or equal to a second value.</description>
          <arguments>
            <argument token="A" description="the first value"/>
            <argument token="B" description="the second value"/>
          </arguments>
        </command>

        <command name="&amp;&amp;">
          <description>Logical AND.</description>
          <examples>
            <example>
              <code><![CDATA[echo (&& 1 1)]]></code>
              <explanation>Output: 1</explanation>
            </example>
            <example>
              <code><![CDATA[echo (&& 1 0)]]></code>
              <explanation>Output: 0</explanation>
            </example>
          </examples>
          <arguments>
            <argument token="A" description="first value"/>
            <argument token="B" description="second value"/>
          </arguments>
          <return token="N" description="A AND B"/>
        </command>

        <command name="||">
          <description>Logical OR.</description>
          <examples>
            <example>
              <code><![CDATA[echo (|| 1 0)]]></code>
              <explanation>output: 1</explanation>
            </example>
            <example>
              <code><![CDATA[echo (|| 0 0)]]></code>
              <explanation>output: 0</explanation>
            </example>
          </examples>
          <arguments>
            <argument token="A" description="first value"/>
            <argument token="B" description="second value"/>
          </arguments>
          <return token="N" description="A OR B"/>
        </command>

        <command name="!">
          <description>Performs a negation.</description>
          <arguments>
            <argument token="A" description="argument"/>
          </arguments>
        </command>

        <command name="&amp;b">
          <description>Performs the operation AND using binary arithmetic on integer values (32-bit signed).</description>
          <arguments>
            <argument token="A" description="the first argument"/>
            <argument token="B" description="the second argument"/>
          </arguments>
          <references>
            <identifierReference identifier="|b"/>
            <identifierReference identifier="^b"/>
            <identifierReference identifier="!b"/>
          </references>
        </command>

        <command name="|b">
          <description>Performs the operation OR using binary arithmetic on integer values (32-bit signed).</description>
          <arguments>
            <argument token="A" description="the first argument"/>
            <argument token="B" description="the second argument"/>
          </arguments>
          <references>
            <identifierReference identifier="&amp;b"/>
            <identifierReference identifier="^b"/>
            <identifierReference identifier="!b"/>
          </references>
        </command>

        <command name="^b">
          <description>Performs the operation XOR using binary arithmetic on integer values (32-bit signed).</description>
          <arguments>
            <argument token="A" description="the first argument"/>
            <argument token="B" description="the second argument"/>
          </arguments>
          <references>
            <identifierReference identifier="&amp;b"/>
            <identifierReference identifier="|b"/>
            <identifierReference identifier="!b"/>
          </references>
        </command>

        <command name="!b">
          <description>Performs the operation NOT using binary arithmetic on integer values (32-bit signed).</description>
          <remarks>
            <remark>Integer values are 32-bit signed values, so for example "echo (!b 1)" returns "-2".</remark>
          </remarks>
          <arguments>
            <argument token="A" description="argument"/>
          </arguments>
          <references>
            <identifierReference identifier="&amp;b"/>
            <identifierReference identifier="|b"/>
            <identifierReference identifier="^b"/>
          </references>
        </command>

        <command name="h0">
          <description>Returns value as string of hexadecimal digits, padded with leading zeros to a given minimum length (precision).</description>
          <examples>
            <example>
              <code><![CDATA[echo (h0 2 1024)]]></code>
              <explanation>Output: 400</explanation>
            </example>
            <example>
              <code><![CDATA[echo (h0 4 1024)]]></code>
              <explanation>Output: 0400</explanation>
            </example>
            <example>
              <code><![CDATA[echo (h0 6 1024)]]></code>
              <explanation>Output: 000400</explanation>
            </example>
            <example>
              <code><![CDATA[echo (h0 0 (&b 0xe 0x3))]]></code>
              <explanation>Output: 2</explanation>
            </example>
            <example>
              <code><![CDATA[echo (h0 0 (|b 0xe 0x3))]]></code>
              <explanation>Output: f</explanation>
            </example>
            <example>
              <code><![CDATA[echo (h0 0 (^b 0xe 0x3))]]></code>
              <explanation>Output: d</explanation>
            </example>
            <example>
              <code><![CDATA[echo (h0 0 (!b 0xe))]]></code>
              <explanation>Output: fffffff1</explanation>
            </example>
            <example>
              <code><![CDATA[echo (h0 0 (* -1 0xe))]]></code>
              <explanation>Output: fffffff2</explanation>
            </example>
          </examples>
          <arguments>
            <argument token="P" description="precision"/>
            <argument token="V" description="value"/>
          </arguments>
          <references>
            <identifierReference identifier="l0"/>
          </references>
        </command>

        <command name="rnd">
          <description>Random value.</description>
          <arguments>
            <argument token="A" description="the upper limit of the random value" valueNotes=""/>
          </arguments>
          <return token="R" description="the random value" valueNotes="larger or equal 0 and smaller than A"/>
        </command>

        <command name="round">
          <description>Rounds the given float.</description>
          <arguments>
            <argument token="F" description="the float number to round" valueNotes=""/>
          </arguments>
          <return token="I" description="the rounded integer" valueNotes="the precision is 1 unit"/>
        </command>

        <command name="ceil">
          <description>Upper value of a float number.</description>
          <arguments>
            <argument token="F" description="the float number to get the ceil from" valueNotes=""/>
          </arguments>
          <return token="I" description="the ceil value (integer)"/>
        </command>

        <command name="floor">
          <description>Floor value of a float number.</description>
          <arguments>
            <argument token="F" description="the float number to get the floor from" valueNotes=""/>
          </arguments>
          <return token="I" description="The floor value (integer)"/>
        </command>

        <command name="strcmp">
          <description>Determines if two strings are equal.</description>
          <examples>
            <example>
              <code><![CDATA[if (strcmp yes yes) [echo the two strings are equal] [echo the two strings are not equal]]]></code>
              <explanation>Output: the two strings are equal</explanation>
            </example>
          </examples>
          <arguments>
            <argument token="A" description="the first string"/>
            <argument token="B" description="the second string"/>
          </arguments>
          <return token="N" description="the equality" valueNotes="1 (equal) or 0 (unequal)"/>
          <references>
            <identifierReference identifier="strstr"/>
          </references>
        </command>

        <command name="strstr">
          <description>Determines if string B was found in string A.</description>
          <remarks>
            <remark>It returns position of string B in string A (counting from 1) or zero, if not found.</remark>
          </remarks>
          <examples>
            <example>
              <code><![CDATA[if (strstr "Hello world!" Hello) [echo found Hello in Hello world!] [echo did not find Hello in Hello world!]]]></code>
              <explanation>Output: found Hello in Hello world!</explanation>
            </example>
          </examples>
          <arguments>
            <argument token="A" description="the first string"/>
            <argument token="B" description="the second string"/>
          </arguments>
          <return token="N" description="integer" valueNotes="0 (not found) or position (if found)"/>
          <references>
            <identifierReference identifier="strcmp"/>
          </references>
        </command>

        <command name="strlen">
          <description>Returns the length (in characters, including whitespace) of string S.</description>
          <examples>
            <example>
              <code><![CDATA[echo (strlen "Hello world!")]]></code>
              <explanation>Output: 12</explanation>
            </example>
          </examples>
          <arguments>
            <argument token="S" description="string"/>
          </arguments>
          <references>
            <identifierReference identifier="substr"/>
          </references>
        </command>

        <command name="substr">
          <description>Copies a substring out of the original.</description>
          <arguments>
            <argument token="S" description="the original string"/>
            <argument token="A" description="start position"/>
            <argument token="L" description="substring length" optional="true"/>
          </arguments>
          <return token="S" description="the substring"/>
          <remarks>
            <remark>
            Character indexes begins at 0. If "start position" is negative, the reference is the end of the string.
            It also counts negative length from total length, if "substring length" parameter is negative.
            </remark>
          </remarks>
          <examples>
            <example>
              <code><![CDATA[echo (substr abcdefgh 2 5)]]></code>
              <explanation>Output: cdefg</explanation>
            </example>
            <example>
              <code><![CDATA[echo (substr abcdefgh -3 2)]]></code>
              <explanation>Output: fg</explanation>
            </example>
            <example>
              <code><![CDATA[echo (substr abcdefgh 2)]]></code>
              <explanation>Output: cdefgh</explanation>
            </example>
            <example>
              <code><![CDATA[echo (substr abcdefgh 1 -2)]]></code>
              <explanation>Output: bcdefg</explanation>
            </example>
          </examples>
          <references>
            <identifierReference identifier="strlen"/>
            <identifierReference identifier="strreplace"/>
            <identifierReference identifier="parsestring"/>
          </references>
        </command>

        <command name="if">
          <description>Controls the script flow based on a boolean expression.</description>
          <examples>
            <example>
              <code><![CDATA[if (> $x 10) [ echo x is bigger than 10 ] [ echo x too small ]]]></code>
            </example>
          </examples>
          <arguments>
            <argument token="cond" description="the condition" valueNotes="0 (false) or anything else (true)"/>
            <argument token="true" description="the body to execute if the condition is true"/>
            <argument token="false" description="the body to execute if the condition is false"/>
          </arguments>
        </command>

        <command name="switch">
          <description>Takes an integer argument to determine what block of code to execute.</description>
          <remarks>
            <remark>This command can only handle up to 23 'cases' (because of cubescript's 24 argument limit).</remark>
          </remarks>
          <examples>
            <example>
              <code><![CDATA[switch 2 [echo case 0] [echo case 1] [echo case 2] [echo case 3] [echo case 4]]]></code>
              <explanation>Output: case 2</explanation>
            </example>
          </examples>
          <arguments>
            <argument token="I" description="integer"/>
            <argument token="C" description="a variable number of 'case' arguments..."/>
          </arguments>
        </command>

        <command name="loop">
          <description>Loops the specified body.</description>
          <remarks>
            <remark>This command sets the alias you choose, as first argument, from 0 to N-1 for every iteration.</remark>
          </remarks>
          <examples>
            <example>
              <code><![CDATA[loop i 10 [ echo $i ]]]></code>
            </example>
          </examples>
          <arguments>
            <argument token="V" description="the alias used as counter"/>
            <argument token="N" description="the amount of loops"/>
            <argument token="body" description="the body to execute on each iteration"/>
          </arguments>
          <references>
            <identifierReference identifier="break"/>
            <identifierReference identifier="continue"/>
            <identifierReference identifier="while"/>
            <identifierReference identifier="looplist"/>
          </references>
        </command>

        <command name="while">
          <description>Loops the specified body while the condition evaluates to true.</description>
          <remarks>
            <remark>
              This command sets the alias "i" from 0 to N-1 for every iteration.
              Note that the condition here has to have [], otherwise it would only be evaluated once.
            </remark>
          </remarks>
          <examples>
            <example>
              <code><![CDATA[alias i 0; while [ (< $i 10) ] [ echo $i; alias i (+ $i 1) ]]]></code>
            </example>
          </examples>
          <arguments>
            <argument token="cond" description="the condition" valueNotes="the code evaluated before each iteration"/>
            <argument token="body" description="the body to execute on each iteration"/>
          </arguments>
          <references>
            <identifierReference identifier="break"/>
            <identifierReference identifier="continue"/>
            <identifierReference identifier="loop"/>
          </references>
        </command>

        <command name="looplist">
          <description>Browses a list and executes a body for each element.</description>
           <remarks>
             <remark>It works optionally with several variables.</remark>
          </remarks>
          <examples>
            <example>
              <code><![CDATA[looplist "zero one two three" number [echo $number]]]></code>
            </example>
            <example>
              <code><![CDATA[looplist [0 "is knife" 1 "is pistol"] [n w] [echo weapon $n $w]]]></code>
            </example>
          </examples>
          <arguments>
            <argument token="V" description="the list to browse"/>
            <argument token="N" description="the alias(es) containing the current element value"/>
            <argument token="body" description="the body to execute on each iteration"/>
          </arguments>
          <references>
            <identifierReference identifier="break"/>
            <identifierReference identifier="continue"/>
            <identifierReference identifier="loop"/>
            <identifierReference identifier="looplisti"/>
          </references>
        </command>

        <command name="looplisti">
          <description>Browses a list and executes a body for each element.</description>
          <remarks>
            <remark>
            The same as looplist, but it automatically counts the loops in "i", starting with 0.
            It works optionally with several variables.
            </remark>
          </remarks>
          <examples>
            <example>
              <code><![CDATA[a = [u v w]; b = [x y z]; looplisti $a m [echo $m (at $b $i) $i]]]></code>
              <explanation>Output: u x 0 , v y 1 , w z 2</explanation>
            </example>
          </examples>
          <arguments>
            <argument token="V" description="the list to browse"/>
            <argument token="N" description="the alias(es) containing the current element value"/>
            <argument token="body" description="the body to execute on each iteration"/>
          </arguments>
          <references>
            <identifierReference identifier="break"/>
            <identifierReference identifier="continue"/>
            <identifierReference identifier="loop"/>
            <identifierReference identifier="looplist"/>
          </references>
        </command>

        <command name="break">
          <description>Aborts a loop created with a 'loop', 'looplist' or 'while' command.</description>
          <examples>
            <example>
              <code><![CDATA[loop i 10 [ if (= $i 4) [ break ]; echo $i]]]></code>
              <explanation>output: 0 1 2 3</explanation>
            </example>
          </examples>
          <references>
            <identifierReference identifier="continue"/>
            <identifierReference identifier="loop"/>
            <identifierReference identifier="while"/>
          </references>
        </command>

        <command name="continue">
          <description>Skip current loop iteration.</description>
          <examples>
            <example>
              <code><![CDATA[loop i 5 [ if (= $i 2) [ continue ]; echo $i]]]></code>
              <explanation>output: 0 1 3 4</explanation>
            </example>
          </examples>
          <references>
            <identifierReference identifier="break"/>
            <identifierReference identifier="loop"/>
            <identifierReference identifier="while"/>
          </references>
        </command>

        <command name="concat">
          <description>Concatenates multiple strings with spaces inbetween.</description>
          <examples>
            <example>
              <code><![CDATA[alias a "hello"; echo (concat $a "world")]]></code>
              <explanation>output: hello world</explanation>
            </example>
          </examples>
          <arguments>
            <argument token="S" description="the first string"/>
            <variableArgument token="..." description="collection of strings to concatenate"/>
          </arguments>
          <return token="R" description="The newly created string"/>
        </command>

        <command name="concatword">
          <description>Concatenates multiple strings.</description>
          <remarks>
            <remark>The newly created string is saved to the alias 's'.</remark>
          </remarks>
          <examples>
            <example>
              <code><![CDATA[alias a "Cube"; echo (concatword $a "Script")]]></code>
              <explanation>output: CubeScript</explanation>
            </example>
          </examples>
          <arguments>
            <argument token="S" description="the first string"/>
            <variableArgument token="..." description="collection of strings to concatenate"/>
          </arguments>
          <return token="R" description="The newly created string"/>
        </command>

        <command name="at">
          <description>Grabs a word out of a string.</description>
          <remarks>
            <remark>Negative index number returns "".</remark>
          </remarks>
          <examples>
            <example>
              <code><![CDATA[echo (at "zero one two three" 2)]]></code>
              <explanation>output: two</explanation>
            </example>
          </examples>
          <arguments>
            <argument token="S" description="the string"/>
            <argument token="N" description="the index of the word"/>
          </arguments>
          <return token="W" description="the word from the specified idex"/>
        </command>

        <command name="listlen">
          <description>returns the element count of the given list.</description>
          <arguments>
            <argument token="L" description="the list"/>
          </arguments>
        </command>

        <command name="findlist">
          <description>Searches a list for a specified value.</description>
          <arguments>
            <argument token="L" description="the list"/>
            <argument token="I" description="the item to find"/>
          </arguments>
          <return token="I" description="the index of the item in the list"/>
        </command>

        <command name="sleep">
          <description>Executes a command after specified time period.</description>
          <examples>
            <example>
              <code><![CDATA[sleep 1000 [ echo foo ]]]></code>
              <explanation>Prints 'foo' to the screen after 1 second.</explanation>
            </example>
          </examples>
          <arguments>
            <argument token="N" description="the amount of milliseconds"/>
            <argument token="C" description="the command to execute"/>
            <argument token="P" optional="true" description="ignore map change"/>
          </arguments>
        </command>

        <command name="resetsleeps">
          <description>Resets all current "sleep".</description>
        </command>

        <variable name="numargs">
          <description>The number of arguments passed to the current alias.</description>
          <value description="numargs" minValue="0" maxValue="24" defaultValue="0" readOnly="true"/>
        </variable>

        <command name="format">
        <description>Replaces "%" format specifiers in the string by the values specified in subsequent arguments.</description>
        <remarks>
          <remark>
          In addition, it allows access to more than nine parameters. Parameter numbers of 10 and higher have to be prefixed
          with an additional zero. For example "%010" accesses parameter number ten.
          </remark>
        </remarks>
          <arguments>
            <argument token="F" description="format" valueNotes="use %1..%9 for the values"/>
            <argument token="V" description="value(s)"/>
          </arguments>
          <examples>
            <example>
              <code><![CDATA[echo (format "%1 bottles of %2 on the %3, %1 bottles of %2!" 99 beer wall)]]></code>
              <explanation>output: 99 bottles of beer on the wall, 99 bottles of beer!</explanation>
            </example>
          </examples>
          <references>
            <identifierReference identifier="format2"/>
          </references>
        </command>

        <command name="format2">
        <description>Replaces "%" format specifiers in the string by the values specified in subsequent arguments.</description>
        <remarks>
          <remark>Like "format" command, but all parameters are treated as lists and are exploded first.</remark>
          <remark>
          In addition, it allows access to more than nine parameters. Parameter numbers of 10 and higher have to be prefixed
          with an additional zero. For example "%010" accesses parameter number ten.
          </remark>
        </remarks>
          <arguments>
            <argument token="F" description="format" valueNotes="use %1..%9 for the values"/>
            <argument token="V" description="value(s)"/>
          </arguments>
          <examples>
            <example>
              <code><![CDATA[echo (format "_%1_%2_%3_%4_%5_" "A B C" D E F)]]></code>
              <explanation>output: _A B C_D_E_F__</explanation>
            </example>
            <example>
              <code><![CDATA[echo (format2 "_%1_%2_%3_%4_%5_" "A B C" D E F)]]></code>
              <explanation>output: _A_B_C_D_E_</explanation>
            </example>
          </examples>
          <references>
            <identifierReference identifier="format"/>
          </references>
        </command>

        <command name="\f">
          <description>Adds color to a string.</description>
          <remarks>
            <remark>The whole string has to be included in quotes.</remark>
          </remarks>
          <examples>
            <example>
              <code><![CDATA[echo "\f3Hello \f0world!"]]></code>
              <explanation>Output: a red "Hello" and a green "world!"</explanation>
            </example>
          </examples>
          <arguments>
            <argument token="N" description="color id" valueNotes="0-9, A-Z"/>
          </arguments>
          <references>
            <identifierReference identifier="cncolumncolor"/>
          </references>
        </command>

        <command name="l0">
          <description>Leading zeros for the number V to make it W chars wide.</description>
          <remarks>
            <remark>It may look like 10 - which might be considered a mnemonic - but it's lowercase-L and 0!</remark>
          </remarks>
          <examples>
            <example>
              <code><![CDATA[echo (l0 5 1000)]]></code>
              <explanation>Output: 01000</explanation>
            </example>
            <example>
              <code><![CDATA[echo (l0 3 1000)]]></code>
              <explanation>Output: 1000</explanation>
            </example>
          </examples>
          <arguments>
            <argument token="W" description="width"/>
            <argument token="V" description="value"/>
          </arguments>
          <references>
            <identifierReference identifier="h0"/>
          </references>
        </command>

        <command name="storesets">
          <description>Generates an alias (list) of the current values for the given aliases/CVARs.</description>
          <examples>
            <example>
              <code><![CDATA[storesets "sensitivity hudgun fov" tmp]]></code>
              <explanation>Example result: stores "3.000 1 120" into alias "tmp".</explanation>
            </example>
          </examples>
          <arguments>
            <argument token="L" description="the list of aliases/CVARs"/>
            <argument token="A" description="the alias to store them in"/>
          </arguments>
          <references>
            <identifierReference identifier="getalias"/>
          </references>
        </command>

        <command name="alias">
          <description>Binds a name to commands.</description>
          <arguments>
            <argument token="N" description="the name of the alias" valueNotes="string, must not contain '$'"/>
            <argument token="A" description="the commands" valueNotes="string"/>
          </arguments>
          <examples>
            <example>
              <code><![CDATA[alias myalias [ echo "hello world"; alias myalias [ echo "I already said hello" ] ]]]></code>
              <explanation>It is possible to re-bind an alias, even during its evaluation.</explanation>
            </example>
            <example>
              <code><![CDATA[test = [ echo "successful" ]]]></code>
              <explanation>There is also the shorthand version of defining an alias via the "=" sign.</explanation>
            </example>
          </examples>
          <references>
            <identifierReference identifier="const"/>
            <identifierReference identifier="tempalias"/>
            <identifierReference identifier="isconst"/>
            <identifierReference identifier="checkalias"/>
            <identifierReference identifier="persistidents"/>
          </references>
        </command>

        <command name="const">
          <description>Set an alias as a constant.</description>
          <remarks>
            <remark>
            A constant cannot be redefined in the same AC session: its value cannot be changed.
            To get rid of a constant, use "delalias".
            </remark>
            <remark>Constant alias is temporary that will not be written to saved.cfg, and thus will not persist after quitting.</remark>
          </remarks>
          <arguments>
            <argument token="N" description="the name of the alias" valueNotes="string, must not contain '$'"/>
            <argument token="A" description="the value" valueNotes="string" optional="true"/>
          </arguments>
          <examples>
            <example>
              <code><![CDATA[myalias = myvalue; const myalias;]]></code>
              <explanation>Set "myalias" value to "myvalue" then "lock" it as a constant.</explanation>
            </example>
            <example>
              <code><![CDATA[const myalias myvalue;]]></code>
              <explanation>You can directly set a value for your alias when you define it as a constant.</explanation>
            </example>
            <example>
              <code><![CDATA[const myalias myvalue; myalias = anothervalue;]]></code>
              <explanation>Assigning a value to a const will throw you an error. Output: myalias is already defined as a constant</explanation>
            </example>
          </examples>
          <references>
            <identifierReference identifier="alias"/>
            <identifierReference identifier="tempalias"/>
            <identifierReference identifier="isconst"/>
          </references>
        </command>

        <command name="enumalias">
          <description>Lists all persistent aliases that start with prefix.</description>
          <remarks>
            <remark>Returns a table with two entries per alias: 1) full name and 2) name without prefix.</remark>
          </remarks>
          <references>
            <identifierReference identifier="alias"/>
          </references>
        </command>

        <command name="checkalias">
          <description>Determines if the argument given is an existing alias or not.</description>
          <examples>
            <example>
              <code><![CDATA[hello = ""; echo (checkalias hello)]]></code>
              <explanation>Output: 1</explanation>
            </example>
            <example>
              <code><![CDATA[echo (checkalias oMgThIsAlIaSpRoLlYdOeSnTeXiSt)]]></code>
              <explanation>Output: 0</explanation>
            </example>
          </examples>
          <arguments>
            <argument token="A" description="the alias to check for"/>
          </arguments>
          <references>
            <identifierReference identifier="checkinit"/>
            <identifierReference identifier="aliasinit"/>
          </references>
        </command>

        <command name="isconst">
          <description>Determines if the argument given is a constant or not.</description>
          <examples>
            <example>
              <code><![CDATA[const hello ""; echo (isconst hello)]]></code>
              <explanation>Output: 1</explanation>
            </example>
            <example>
              <code><![CDATA[hello = value; echo (isconst hello)]]></code>
              <explanation>Output: 0</explanation>
            </example>
          </examples>
          <arguments>
            <argument token="A" description="the alias to check for"/>
          </arguments>
          <references>
            <identifierReference identifier="const"/>
          </references>
        </command>

        <command name="checkinit">
          <description>Ensures the initialization of an alias.</description>
          <examples>
            <example>
              <code><![CDATA[checkinit mapstartalways]]></code>
              <explanation>Output: if alias mapstartalways does not exist, this command initializes it.</explanation>
            </example>
            <example>
              <code><![CDATA[checkinit mapstartalways [ echo New map, good luck! ]]]></code>
              <explanation>Output: if alias mapstartalways does not exist, it is initialized, and if the block of code "[ echo New map, good luck! ]" does not exist within the aliases contents, this command adds it.</explanation>
            </example>
          </examples>
          <arguments>
            <argument token="A" description="the alias to check for"/>
            <argument token="B" description="the block of code to ensure that the alias contains" optional="true"/>
          </arguments>
          <references>
            <identifierReference identifier="checkalias"/>
            <identifierReference identifier="aliasinit"/>
            <identifierReference identifier="check2init"/>
            <identifierReference identifier="check2initlist"/>
          </references>
        </command>

        <command name="check2init">
          <description>Defines an alias only if it does not already exist.</description>
          <arguments>
            <argument token="A" description="alias name"/>
            <argument token="V" description="alias value"/>
          </arguments>
          <references>
            <identifierReference identifier="check2initlist"/>
            <identifierReference identifier="checkalias"/>
            <identifierReference identifier="checkinit"/>
            <identifierReference identifier="aliasinit"/>
          </references>
        </command>

        <command name="delalias">
          <description>Deletes the passed alias.</description>
          <arguments>
            <argument token="N" description="the name of the alias" valueNotes="string, must not contain '$'"/>
          </arguments>
        </command>

        <command name="forceinit">
          <description>Forcibly sets a list of aliases to a specified value.</description>
          <examples>
            <example>
              <code><![CDATA[alias1 = 0; alias2 = 0; alias3 = 0; alias4 = 0; alias 5 = 0]]></code>
              <explanation>Can be written as:</explanation>
            </example>
            <example>
              <code><![CDATA[forceinit [alias1 alias2 alias3 alias4 alias5] 0]]></code>
            </example>
          </examples>
          <arguments>
            <argument token="L" description="list of alias names"/>
            <argument token="V" description="alias value"/>
          </arguments>
        </command>

        <command name="aliasinit">
          <description>Initializes a group of aliases using checkinit.</description>
          <arguments>
            <argument token="L" description="the list of aliases to check for"/>
            <argument token="B" description="the block of code to ensure the aliases contain" optional="true"/>
          </arguments>
          <references>
            <identifierReference identifier="checkalias"/>
            <identifierReference identifier="checkinit"/>
            <identifierReference identifier="check2init"/>
            <identifierReference identifier="check2initlist"/>
          </references>
        </command>

        <command name="check2initlist">
          <description>Uses check2init on a list of aliases.</description>
          <arguments>
            <argument token="L" description="list of alias names"/>
            <argument token="V" description="alias value"/>
          </arguments>
          <references>
            <identifierReference identifier="checkalias"/>
            <identifierReference identifier="checkinit"/>
            <identifierReference identifier="aliasinit"/>
            <identifierReference identifier="check2init"/>
          </references>
        </command>

        <command name="persistidents">
          <description>Controls whether aliases defined afterwards will be saved (1) or not (0).</description>
          <remarks>
            <remark>Rules:</remark>
            <remark>* aliases created by "const" and "tempalias" are never persistent;</remark>
            <remark>
            * aliases created or altered by "alias" or "=" become persistent, if the "persistidents" flag is set
            during that operation;
            </remark>
            <remark>
            * "persistidents" is false during the execution of almost all config files during game start - those files
            can create aliases with default values which will not be persistent (until changed later while the flag is set);
            </remark>
            <remark>
            * before saved.cfg is executed, the flag is set and stays set all throughout the game - which means,
            that all changes (for example from menus or in console) will change the altered alias to "persistent";
            </remark>
            <remark>
            * exceptions for map or model config files are unnecessary, since those run restricted
            and can't create aliases anyway;
            </remark>
            <remark>* exceptions are necessary for "late run" config files like those in config/opt/ folder.</remark>
            <remark>
            This command may be used to manually set or clear the flag. It also returns the current state
            of the flag. If used in a config file, the flag is restored to its original value when the file ends execution.
            </remark>
            <remark>
            In short: only late-run config files (meaning: run after saved.cfg was restored) may need to manually set/reset
            the flag. Use "const" and "tempalias" where appropriate and clear "persistidents" before creating an alias with
            a not-to-save default value that may be changed and made persistent later.
            </remark>
          </remarks>
          <arguments>
            <argument token="B" description="control option" valueNotes="1: persistent, 0: not persistent"/>
          </arguments>
          <examples>
            <example>
              <code><![CDATA[persistidents 0; foo = [ echo "bar"]]]></code>
              <explanation>foo will not be saved and has to be redefined when restarting AC.</explanation>
            </example>
            <example>
              <code><![CDATA[persistidents 1; bar = [ echo "foo"]]]></code>
              <explanation>bar will be saved and persistent across sessions.</explanation>
            </example>
          </examples>
          <references>
            <identifierReference identifier="alias"/>
          </references>
        </command>

        <command name="addpunct">
          <description>Injects cubescript punctuation.</description>
          <examples>
            <example>
              <code><![CDATA[echo (addpunct hello)]]></code>
              <explanation>Output: "hello"</explanation>
            </example>
            <example>
              <code><![CDATA[echo (addpunct hello 1)]]></code>
              <explanation>Output: [hello]</explanation>
            </example>
            <example>
              <code><![CDATA[echo (addpunct hello 2)]]></code>
              <explanation>Output: (hello)</explanation>
            </example>
            <example>
              <code><![CDATA[echo (addpunct hello 3)]]></code>
              <explanation>Output: $hello</explanation>
            </example>
            <example>
              <code><![CDATA[test = (concat echo (addpunct fov 3)); test]]></code>
              <explanation>Output: 90.0</explanation>
            </example>
          </examples>
          <arguments>
            <argument token="S" description="a string"/>
            <argument token="N" description="ID or name" valueNotes="0 (quotes), 1 (brackets), 2 (parenthesis), 3 (_$_), 4 (quote), 5 (percent)"/>
          </arguments>
        </command>

        <command name="tolower">
          <description>Converts a string to all lowercase characters.</description>
          <examples>
            <example>
              <code><![CDATA[echo (tolower HELLO)]]></code>
              <explanation>Output: hello</explanation>
            </example>
          </examples>
          <arguments>
            <argument token="S" description="a string"/>
          </arguments>
          <references>
            <identifierReference identifier="toupper"/>
          </references>
        </command>

        <command name="toupper">
          <description>Converts a string to all uppercase characters.</description>
          <examples>
            <example>
              <code><![CDATA[echo (toupper hello)]]></code>
              <explanation>Output: HELLO</explanation>
            </example>
          </examples>
          <arguments>
            <argument token="S" description="a string"/>
          </arguments>
          <references>
            <identifierReference identifier="tolower"/>
          </references>
        </command>

        <command name="testchar">
          <description>Tests a character argument for various things.</description>
          <examples>
            <example>
              <code><![CDATA[echo (testchar 1)]]></code>
              <explanation>Output: 1 // It is a 0-9 digit</explanation>
            </example>
            <example>
              <code><![CDATA[echo (testchar a 1)]]></code>
              <explanation>Output: 1 // It is a a-z or A-Z character</explanation>
            </example>
            <example>
              <code><![CDATA[echo (testchar z 2)]]></code>
              <explanation>Output: 1 // It is a a-z or A-Z character or 0-9 digit</explanation>
            </example>
            <example>
              <code><![CDATA[echo (testchar b 3)]]></code>
              <explanation>Output: 1 // It is a lowercase a-z character</explanation>
            </example>
            <example>
              <code><![CDATA[echo (testchar B 4)]]></code>
              <explanation>Output: 1 // It is a uppercase A-Z character</explanation>
            </example>
            <example>
              <code><![CDATA[echo (testchar , 5)]]></code>
              <explanation>Output: 1 // It is a printable character</explanation>
            </example>
            <example>
              <code><![CDATA[echo (testchar . 6)]]></code>
              <explanation>Output: 1 // It is a punctuation character</explanation>
            </example>
            <example>
              <code><![CDATA[echo (testchar " " 7)]]></code>
              <explanation>Output: 1 // It is a whitespace character</explanation>
            </example>
          </examples>
          <arguments>
            <argument token="C" description="the character to test"/>
            <argument token="N" description="type of test to run" valueNotes="min 0/max 7/default 0"/>
          </arguments>
          <remarks>
            <remark>See the following c++ functions for more information about the usage of this command:</remark>
            <remark>isalpha(), isalnum(), isdigit(), islower(), isprint(), ispunct(), isupper(), and isspace()</remark>
          </remarks>
        </command>

        <command name="strreplace">
          <description>Returns a string, with a portion of it replaced with a new sub-string.</description>
          <examples>
            <example>
              <code><![CDATA[echo (strreplace "Hello cruel world" cruel "")]]></code>
              <explanation>Output: Hello world</explanation>
            </example>
          </examples>
          <arguments>
            <argument token="S" description="the original string to modify"/>
            <argument token="T" description="the target sub-string to replace"/>
            <argument token="N" description="the new sub-string to replace the target"/>
          </arguments>
          <references>
            <identifierReference identifier="substr"/>
          </references>
        </command>

        <command name="listaverage">
          <description>Returns the average of a list of numbers.</description>
          <examples>
            <example>
              <code><![CDATA[echo (listaverage "2 5 5")]]></code>
              <explanation>Output: 4.0</explanation>
            </example>
          </examples>
          <arguments>
            <argument token="L" description="the list of numbers" valueNotes="supports ints and floats"/>
          </arguments>
        </command>

        <scriptalias name="add2alias">
          <description>This will append the passed 2nd argument to any existing content of the alias named in the 1st argument.</description>
          <arguments>
            <argument token="A" description="the alias to add to"/>
            <argument token="E" description="the new element to add"/>
          </arguments>
          <remarks>
            <remark>
            Several popular aliases have predefined shortcuts using this scriptalias: addOnLoadOnce, addOnLoadAlways.
            Check config/scripts.cfg for possible omissions in that list.
            </remark>
          </remarks>
          <examples>
            <example>
              <code>
                <![CDATA[
                foo = "one"
                add2alias foo two
                echo foo
                ]]>
              </code>
              <explanation>Output: one two</explanation>
              <explanation>This will output the string and override any other actions that might've been defined.</explanation>
            </example>
          </examples>
          <references>
            <identifierReference identifier="add2bind"/>
            <identifierReference identifier="add2list"/>
          </references>
        </scriptalias>

        <scriptalias name="add2list">
          <description>Appends a new element to a list.</description>
          <examples>
            <example>
              <code><![CDATA[tmp_list = []; add2list tmp_list Hello; add2list tmp_list world!; echo $tmp_list]]></code>
              <explanation>Output: Hello world!</explanation>
            </example>
          </examples>
          <arguments>
            <argument token="A" description="the alias (list) to add to"/>
            <argument token="E" description="the new element to add"/>
          </arguments>
          <references>
            <identifierReference identifier="add2alias"/>
            <identifierReference identifier="add2bind"/>
          </references>
        </scriptalias>
        
        <command name="listoptions">
          <description>Lists the argument options for several argument types.</description>
          <examples>
            <example>
              <code><![CDATA[echo (listoptions)]]></code>
              <explanation>
              Output: "entities ents weapons teamnames teamnames-abbrv punctuations crosshairnames
              menufilesortorders texturestacktypes cubetypes"
              </explanation>
            </example>
            <example>
              <code><![CDATA[echo (listoptions teamnames)]]></code>
              <explanation>Output: "CLA RVSF CLA-SPECT RVSF-SPECT SPECTATOR"</explanation>
            </example>
          </examples>
        </command>

        <command name="escape">
          <description>Replaces control characters in a string with escaped sequences.</description>
          <arguments>
            <argument token="S" description="string to escape"/>
          </arguments>
          <examples>
            <example>
              <code><![CDATA[echo (escape (concat (c 3) "Hello World"))]]></code>
              <explanation>Output: "\f3Hello World"</explanation>
            </example>
          </examples>
        </command>

        <command name="tempalias">
          <description>Creates a temporary alias that will not be written to saved.cfg, and thus will not persist after quitting.</description>
          <arguments>
            <argument token="N" description="temporary alias name"/>
            <argument token="C" description="cubescript command(s)"/>
          </arguments>
          <references>
            <identifierReference identifier="alias"/>
            <identifierReference identifier="const"/>
          </references>
        </command>

        <command name="editsvar">
          <description>Interactively edits an existing alias in the console buffer.</description>
          <remarks>
            <remark>This takes the current value of the existing alias, and inserts it into the command line / text entry box.</remark>
          </remarks>
          <arguments>
            <argument token="A" description="alias to edit" valueNotes="the alias name, without $"/>
          </arguments>
          <examples>
            <example>
              <code><![CDATA[alias test "Hello World"; editsvar test]]></code>
              <explanation>Result: edit test: Hello World</explanation>
            </example>
          </examples>
          <references>
            <identifierReference identifier="editalias"/>
            <identifierReference identifier="inputcommand"/>
          </references>
        </command>

        <command name="editalias">
          <description>Interactively edits an alias in the console buffer.</description>
          <remarks>
            <remark>This takes the current value of the alias, and inserts it into the command line / text entry box.</remark>
            <remark>If the alias doesn't exist, it is created.</remark>
          </remarks>
          <arguments>
            <argument token="A" description="alias to edit" valueNotes="the alias name, without $"/>
          </arguments>
          <examples>
            <example>
              <code><![CDATA[alias test "Hello World"; editalias test]]></code>
              <explanation>Result: edit test: Hello World</explanation>
            </example>
          </examples>
          <references>
            <identifierReference identifier="editsvar"/>
            <identifierReference identifier="inputcommand"/>
          </references>
        </command>

        <command name="inputcommand">
          <description>Makes an input perform a certain command.</description>
          <remarks>
            <remark>
            It opens a custom console buffer with custom prompt, initial buffer text and execution script (which gets the input
            buffer content in alias cmdbuf). If "nopersist" is not zero, the command will not be stored in console history.
            </remark>
          </remarks>
          <arguments>
            <argument token="I" description="input"/>
            <argument token="C" description="command"/>
            <argument token="P" description="prompt"/>
            <argument token="N" description="nopersist"/>
          </arguments>
          <references>
            <identifierReference identifier="complete"/>
            <identifierReference identifier="listcomplete"/>
            <identifierReference identifier="saycommand"/>
          </references>
          <examples>
          </examples>
        </command>

        <command name="sortlist">
          <description>Returns a sorted version of a list.</description>
          <examples>
            <example>
              <code><![CDATA[echo (sortlist [1 3 2])]]></code>
              <explanation>Output: 1 2 3</explanation>
            </example>
          </examples>
          <arguments>
            <argument token="L" description="list to sort"/>
          </arguments>
        </command>

        <command name="isolatecontext">
          <description>Isolates the given context.</description>
          <remarks>
            <remark>
            This disables access from this context to identifiers located in other contexts,
            also it removes all aliases created in this context once the running context changes.
            </remark>
          </remarks>
          <arguments>
            <argument token="C" description="context (integer or name)" valueNotes="CORE (0), CFG (1), PROMPT (2), MAPCFG (3), MDLCFG(4)"/>
          </arguments>
          <references>
            <identifierReference identifier="scriptcontext"/>
            <identifierReference identifier="sealcontexts"/>
          </references>
        </command>

        <command name="sealcontexts">
          <description>Secures this configuration for the rest of the game.</description>
          <references>
            <identifierReference identifier="scriptcontext"/>
            <identifierReference identifier="isolatecontext"/>
          </references>
        </command>

        <command name="scriptcontext">
          <arguments>
            <argument token="C" description="context (integer or name)" valueNotes="CORE (0), CFG (1), PROMPT (2), MAPCFG (3), MDLCFG(4)"/>
            <argument token="N" description="id name"/>
          </arguments>
          <references>
            <identifierReference identifier="isolatecontext"/>
            <identifierReference identifier="sealcontexts"/>
          </references>
        </command>

      </identifiers>
    </section>
    <!-- CubeScript language Section Ends -->
    <!-- General Section Starts -->
    <section name="General" sortindex="01">
      <description>This section describes general identifiers.</description>
      <identifiers sort="true">
        <command name="setclipboardtext">
          <arguments>
            <argument token="T" description="Text to put in the clipboard."/>
          </arguments>
        </command>
        <variable name="autoscreenshot">
          <description>Toggle for taking an automatic screenshot during intermission.</description>
          <value token="B" description="0=Off, 1=On" minValue="0" maxValue="1" defaultValue="1"/>
        </variable>

        <variable name="screenshottype">
          <description>Toggle format of screenshot image. Your choice is for BMP (0), JPEG (1), PNG (2), or PPM (3).</description>
          <value token="T" description="0=BMP, 1=JPEG, 2=PNG 3=PPM" minValue="0" maxValue="2" defaultValue="1"/>
          <references>
            <identifierReference identifier="getscrext"/>
          </references>
        </variable>

        <variable name="screenshotscale">
          <description>Scales screenshots by the given factor before saving. 1 = original size, 0.5 = half size, etc.</description>
          <value token="S" description="Scale" minValue="0.1" maxValue="1" defaultValue="1"/>
        </variable>

        <command name="getscrext">
          <description>Returns the file extension of the client's current screenshottype setting.</description>
          <examples>
            <example>
              <code><![CDATA[echo (getscrext)]]></code>
              <explanation>Example output: .jpg</explanation>
            </example>
          </examples>
          <references>
            <identifierReference identifier="screenshottype"/>
          </references>
        </command>

        <variable name="jpegquality">
          <description>Sets the JPEG screenshot image quality.</description>
          <remarks>
            <remark>The image quality is set by it's compression level, a value of 10 sets maximum compression and a small file size but results in a bad quality image</remark>
            <remark>while a value of 100 results in a large file but gives the best quality image.</remark>
          </remarks>
          <value token="N" description="Compression level" minValue="10" maxValue="100" defaultValue="70"/>
        </variable>

        <variable name="pngcompress">
          <description>Sets the PNG screenshot file compression.</description>
          <remarks>
            <remark>A value of 9 sets maximum data compression and a smaller file size while a value of 0 results in a large file image, quality is always the same since PNG its a loosless format.</remark>
          </remarks>
          <value token="N" description="Compression level" minValue="0" maxValue="9" defaultValue="9"/>
        </variable>

        <command name="writecfg">
          <description>Writes current configuration to config/saved.cfg - automatic on quit.</description>
        </command>

        <command name="echo">
          <description>Outputs text to the console.</description>
          <arguments>
            <argument token="L" description="List of strings"/>
          </arguments>
          <references>
            <identifierReference identifier="hudecho"/>
          </references>
        </command>

        <command name="hudecho">
          <description>Outputs text to the console and heads up display.</description>
          <arguments>
            <argument token="L" description="List of strings"/>
          </arguments>
          <references>
            <identifierReference identifier="allowhudechos"/>
            <identifierReference identifier="echo"/>
          </references>
        </command>

        <variable name="allowhudechos">
          <description>Enables or disables the ability of hudecho to output text to the heads up display.</description>
          <value token="N" description="0 off, 1 on" minValue="0" maxValue="1" defaultValue="1"/>
          <references>
            <identifierReference identifier="hudecho"/>
          </references>
        </variable>

       <command name="saycommand">
          <description>Puts a prompt on screen.</description>
          <remarks>
            <remark>
              This puts a prompt on screen that you can type into, and will capture all keystrokes until you press return (or ESC to cancel).
              If what you typed started with a "/", the rest of it will be executed as a command, otherwise its something you "say" to all players.
            </remark>
          </remarks>
          <defaultKeys>
            <key alias="T" description="opens empty prompt"/>
            <key alias="BACKQUOTE|SLASH|CARET" name="` or / or ^" description="opens a command prompt /"/>
            <key alias="Y" description="opens a command prompt % (for team chat)"/>
            <key alias="TAB" name="Tab" description="autocompletes forwards commands/variables/aliases"/>
            <key alias="LSHIFT+TAB" name="left Shift + Tab" description="autocompletes backwards commands/variables/aliases"/>
            <key alias="LSHIFT+ESCAPE" name="left Shift + Esc" description="resets the commandline to the state before using TAB-completion"/>
            <key alias="UP" name="Up Arrow" description="browse forwards command history"/>
            <key alias="DOWN" name="Down Arrow" description="browse backwards command history"/>
          </defaultKeys>
          <arguments>
            <variableArgument token="S..." description="the text to display in the prompt" optional="true"/>
          </arguments>
          <references>
            <identifierReference identifier="complete"/>
            <identifierReference identifier="listcomplete"/>
            <identifierReference identifier="inputcommand"/>
          </references>
        </command>

        <command name="complete">
          <arguments>
            <argument token="C" description="command" valueNotes="any command or alias"/>
            <argument token="P" description="path" valueNotes="path to search"/>
            <argument token="E" description="extension" valueNotes="extension to match"/>
          </arguments>
          <remarks>
            <remark>The completion will work on the first word of your console input.</remark>
          </remarks>
          <examples>
            <example>
              <code><![CDATA[complete demo "demos" dmo]]></code>
              <explanation>If you enter "/demo " and press TAB you will cycle through all available demos.</explanation>
            </example>
            <example>
              <code><![CDATA[alias mapcomplete [complete $arg1 "packages/maps" cgz]]]></code>
              <explanation>Helper alias for quickly adding complete-definitions for all gamemodes - see config/script.cfg (below "Auto-completions").</explanation>
            </example>
          </examples>
          <references>
            <identifierReference identifier="saycommand"/>
            <identifierReference identifier="listcomplete"/>
          </references>
        </command>

        <command name="listcomplete">
          <argument token="A" description="" valueNotes="value"/>
          <references>
            <identifierReference identifier="saycommand"/>
            <identifierReference identifier="complete"/>
          </references>
        </command>

        <command name="debugargs">
          <description>Dumps all command arguments to STDOUT.</description>
          <arguments>
            <variableArgument token="..." description="..."/>
          </arguments>
        </command>

        <variable name="physinterp">
          <description>Toggles physics interpolation.</description>
          <value token="B" description="" minValue="0" maxValue="1" defaultValue="1"/>
        </variable>

        <command name="millis">
          <description>Returns the number of milliseconds since engine start.</description>
          <examples>
            <example>
              <code><![CDATA[echo (millis)]]></code>
            </example>
          </examples>
          <return token="N" description="the milliseconds"/>
        </command>

        <command name="systime">
          <description>Seconds since the epoch (00:00:00 UTC on January 1, 1970).</description>
          <examples>
            <example>
              <code><![CDATA[echo (systime)]]></code>
            </example>
          </examples>
        </command>

        <command name="timestamp">
          <description>A list of values for current time.</description>
          <remarks>
            <remark>Format: YYYY mm dd HH MM SS</remark>
          </remarks>
          <examples>
            <example>
              <code><![CDATA[echo (timestamp) "2008 08 08 08 08 08"]]></code>
            </example>
            <example>
              <code><![CDATA[echo (timestamp) "2063 04 05 12 00 00"]]></code>
            </example>
            <example>
              <code><![CDATA[echo (at (timestamp) 0) (at (timestamp) 2) (at (timestamp) 1) "2063 05 04"]]></code>
            </example>
          </examples>
        </command>

        <command name="datestring">
          <description>Representation of date.</description>
          <remarks>
            <remark>Format: Www Mmm dd hh:mm:ss yyyy</remark>
            <remark>Use timestamp to create your own formatting.</remark>
          </remarks>
          <examples>
            <example>
              <code><![CDATA[echo (datestring) "Sat Jun  7 17:08:35 2008"]]></code>
            </example>
          </examples>
        </command>

        <command name="timestring">
          <description>The current time in (H)H:MM:SS format.</description>
          <examples>
            <example>
              <code><![CDATA[echo (timestring) "12:34:56"]]></code>
            </example>
            <example>
              <code><![CDATA[echo (timestring) "1:02:03"]]></code>
            </example>
          </examples>
        </command>

        <command name="quit">
          <description>Quits the game without asking.</description>
        </command>

        <command name="screenshot">
          <description>Takes a screenshot.</description>
          <remarks>
            <remark>
              Screenshots are saved to "screenshots/[date]_[time]_[map]_[mode].[ext]",
              where [ext] is the image type selected.
            </remark>
          </remarks>
          <defaultKeys>
            <key alias="F12"/>
          </defaultKeys>
          <references>
            <identifierReference identifier="cleanshot"/>
          </references>
        </command>

        <command name="cleanshot">
          <description>Takes a "clean" screenshot with no HUD items.</description>
          <remarks>
            <remark>Your current HUD configuration is stored into a buffer, and is re-enabled afterwards.</remark>
          </remarks>
          <references>
            <identifierReference identifier="screenshot"/>
            <identifierReference identifier="blankouthud"/>
          </references>
        </command>

        <command name="mapshot">
          <description>Saves an image of the entire radar-overview of the map.</description>
        </command>

        <command name="exec">
          <description>Executes all commands in a specified config file.</description>
          <remarks>
            <remark>
            It also allows to pass arguments to and deliver results from script files -
            when a script file is executed, any additional arguments are passed as execarg1..execargX to the script.
            The number of arguments is in execnumargs and if the script in the file sets the value of execresult,
            the exec command returns that value.
            </remark>
            <remark>Example:</remark>
            <remark>if there is a file testscript.cfg with this content: execresult = (* $execarg1 $execarg2)</remark>
            <remark>then the command: "echo (exec testscript.cfg 6 7)" will output "42".</remark>
          </remarks>
          <arguments>
            <argument token="C" description="the config file"/>
          </arguments>
        </command>

        <command name="execdir">
          <description>Executes all commands in all config files in the specified directory.</description>
          <arguments>
            <argument token="s" description="the directory path from the assaultcube root"/>
          </arguments>
          <examples>
            <example>
              <code><![CDATA[execdir scripts]]></code>
            </example>
          </examples>
          <references>
            <identifierReference identifier="exec"/>
          </references>
        </command>

        <command name="run">
          <description>Executes a config file within "config" folder.</description>
          <arguments>
            <argument token="N" description="the file name (without extension)"/>
          </arguments>
        </command>

        <command name="resetsecuremaps">
          <description>Clears the list of secured maps.</description>
          <references>
            <identifierReference identifier="securemap"/>
          </references>
        </command>

        <command name="securemap">
          <description>Adds a map to the list of secured maps.</description>
          <remarks>
            <remark>Secured maps can not be overwritten by the commands sendmap and getmap.</remark>
          </remarks>
          <references>
            <identifierReference identifier="resetsecuremaps"/>
            <identifierReference identifier="sendmap"/>
            <identifierReference identifier="getmap"/>
          </references>
          <arguments>
            <argument token="S" description="the name of the map"/>
          </arguments>
        </command>

        <command name="getEngineState">
          <description>Returns a list of values describing the current engine (rendering) state.</description>
          <remarks>
            <remark>It will only be filled after the first frame was drawn.</remark>
            <remark>The list is: FPS LOD WQD WVT EVT</remark>
            <remark>FPS = Frames Per Second</remark>
            <remark>LOD = Level Of Detail</remark>
            <remark>WQD = World QuaD Count</remark>
            <remark>WVT = World VerTex Count </remark>
            <remark>EVT = Extra VerTex Count (HUD &amp; menu)</remark>
          </remarks>
          <examples>
            <example>
              <code><![CDATA[echo (getEngineState)
            ]]></code>
            </example>
          </examples>
        </command>

        <variable name="networkdebug">
          <description>Enables output of processed network packets.</description>
          <remarks>
            <remark>This variable only has an effect if the client binary is compiled in debug mode.</remark>
          </remarks>
          <value token="B" description="enable network debugging" minValue="0" maxValue="1" defaultValue="0"/>
        </variable>

        <variable name="autogetmap">
          <description>Determines if the current played map should be automatically downloaded if it is not available locally.</description>
          <value token="B" description="enable auto map download" minValue="0" maxValue="1" defaultValue="1"/>
        </variable>

        <variable name="autogetnewmaprevisions">
          <description>Automatically get new map revisions from the server.</description>
          <value token="N" description="0: no, 1: yes" minValue="0" maxValue="1" defaultValue="0"/>
        </variable>

        <variable name="clockerror">
          <description>Sets the correction value for clockfix.</description>
          <remarks>
            <remark>Engine source-code snippet (main.cpp): if(clockfix) millis = int(millis*(double(clockerror)/1000000));</remark>
          </remarks>
          <references>
            <identifierReference identifier="clockfix"/>
          </references>
          <value token="V" description="correction value" minValue="990000" maxValue="1010000" defaultValue="1000000"/>
        </variable>

        <variable name="clockfix">
          <description>Enables correction of the system clock.</description>
          <references>
            <identifierReference identifier="clockerror"/>
          </references>
          <value token="B" description="enable correction" minValue="0" maxValue="1" defaultValue="0"/>
        </variable>

        <variable name="resetcfg">
          <description>Determines if all settings should be reset when the game quits.</description>
          <remarks>
            <remark>
              It is recommended to quit the game immediately after enabling this setting. Note that the reset happens
              only once as the value of this variable is reset as well.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="resetbinds"/>
            <identifierReference identifier="quit"/>
          </references>
          <value token="B" description="enable reset" minValue="0" maxValue="1" defaultValue="0"/>
        </variable>

        <variable name="throttle_accel">
          <description>Determines how fast network throttling accelerates.</description>
          <references>
            <identifierReference identifier="throttle_interval"/>
            <identifierReference identifier="throttle_decel"/>
          </references>
          <value token="V" description="acceleration" minValue="0" maxValue="32" defaultValue="2"/>
        </variable>

        <variable name="throttle_decel">
          <description>Determines how fast network throttling decelerates.</description>
          <references>
            <identifierReference identifier="throttle_accel"/>
            <identifierReference identifier="throttle_interval"/>
          </references>
          <value token="V" description="deceleration" minValue="0" maxValue="32" defaultValue="2"/>
        </variable>

        <variable name="throttle_interval">
          <description>Determines the interval of re-evaluating network throttling.</description>
          <references>
            <identifierReference identifier="throttle_accel"/>
            <identifierReference identifier="throttle_decel"/>
          </references>
          <value token="V" description="interval" minValue="0" maxValue="30" defaultValue="5" valueNotes="seconds"/>
        </variable>

        <variable name="version">
          <description>Gets an integer representing the game version. READ ONLY</description>
          <remarks>
            <remark>As example, version 1.2.0.2 is represented as value 1202.</remark>
          </remarks>
          <references>
            <identifierReference identifier="current_version"/>
          </references>
        </variable>

        <command name="current_version">
          <description>Compare given version to current version.</description>
          <remarks>
            <remark>Will show update notifications if the given version is higher than the running one.</remark>
          </remarks>
          <arguments>
            <argument token="s" description="newest available version"/>
          </arguments>
        </command>

        <variable name="protocol">
          <description>Gets an integer representing the game protocol. READ ONLY</description>
          <remarks>
            <remark>As example, the protocol of version 1.2.0.2 is represented as value 1201.</remark>
          </remarks>
        </variable>

        <variable name="connected">
          <description>Indicates if a connection to a server exists.</description>
          <value description="the connection state" valueNotes="1 (connected), 0 (disconnected)" minValue="0" maxValue="1" defaultValue="0" readOnly="true"/>
        </variable>

        <variable name="numconlines">
          <description>Hold the current number of lines on the console.</description>
        </variable>

        <variable name="conline">
          <description>Returns text from the last line in the console.</description>
        </variable>

        <variable name="lang">
          <description>Sets the language for which a translated server MOTD will be fetched, if the server has one for this language.</description>
          <remarks>
            <remark>This is always a two-letter language code as defined in the ISO 639 standard, three-letter codes are currently not allowed.</remark>
            <remark>If lang is not set, or if the server does not have a matching MOTD file, it will fall back to English.</remark>
            <remark>Note: this does not affect the client language, which is derived from the system settings (e.g. on many *nix systems, it may be changed via the "LANG" environment variable).</remark>
          </remarks>
          <examples>
            <example>
              <code>en, de, fr, ...</code>
            </example>
          </examples>
          <value token="L" description="the language code"/>
        </variable>

        <variable name="applydialog">
          <description>Toggles the showing of the "Apply changes now?" menu when changing certain graphical settings.</description>
          <value token="N" description="1 = show, 0 = don't show" minValue="0" maxValue="1" defaultValue="1"/>
        </variable>

        <variable name="conopen">
          <description>Indicates the state of the console.</description>
          <value description="console state" minValue="0" maxValue="2" defaultValue="0" readOnly="true" valueNotes="0: closed, 1: open in an alternate size, 2: open regularly"/>
          <references>
            <identifierReference identifier="altconsize"/>
            <identifierReference identifier="toggleconsole"/>
          </references>
        </variable>

        <command name="history">
          <description>Executes the specified command in the command line history.</description>
          <remarks>
            <remark>
            For example, binding "history 1" to a key allows you to quickly repeat the last
            command typed in (useful for placing many identical entities etc.)
            </remark>
          </remarks>
          <arguments>
            <argument token="N" description="the N'th command from the history"/>
          </arguments>
        </command>

        <command name="conskip">
          <description>Allows to browse through the console history by offsetting the console output.</description>
          <defaultKeys>
            <key alias="KP_MINUS" name="- on the keypad" description="scrolls backwards the console (conskip 5)"/>
            <key alias="KP_PLUS" name="+ on the keypad" description="scrolls forwards the console (conskip -5)"/>
            <key alias="KP_MULTIPLY" name="* on the keypad" description="resets the console (conskip -1000)"/>
            <key alias="HASH|BACKSLASH+MOUSE4|MOUSE5" name="'# or \' + mouse scroll" description="scrolls the console"/>
          </defaultKeys>
          <arguments>
            <argument token="N" description="the offset"/>
          </arguments>
        </command>

        <variable name="maxhistory">
          <description>Sets how many typed console commands to store.</description>
          <remarks>
            <remark>
            This value sets how many command lines to store in memory, everytime a command is entered
            it gets store so it can be recalled using the "/" key along with the arrow keys to scroll back and forth through the list.
            </remark>
          </remarks>
          <value token="N" description="Total of stored commands" minValue="0" maxValue="10000" defaultValue="1000"/>
        </variable>

        <variable name="maxcon">
          <description>Sets the total number of text lines from the console to store as history.</description>
          <value token="V" description="" minValue="10" maxValue="1000" defaultValue="200"/>
        </variable>

        <variable name="omitunchangeddefaults">
          <description>Omit variables with unchanged default values from saved.cfg.</description>
          <remarks>
            <remark>
            If this value is 1, variables that are at their default values are omitted from saved.cfg.
            If 0, the variables are written to saved.cfg, but commented out.
            </remark>
          </remarks>
          <value token="N" description="0 = print, but commented out; 1 = omit" minValue="0" maxValue="1" defaultValue="1"/>
          <references>
            <identifierReference identifier="groupvariables"/>
            <identifierReference identifier="omitunchangeddefaultbinds"/>
          </references>
        </variable>

        <variable name="groupvariables">
          <description>Controls how many variables (with similar names) are grouped together on one line in saved.cfg.</description>
          <remarks>
            <remark>This only pertains to commented variables in saved.cfg caused by omitunchangeddefaults being 0.</remark>
          </remarks>
          <value token="N" description="Variables per line" minValue="0" maxValue="10" defaultValue="4"/>
          <references>
            <identifierReference identifier="omitunchangeddefaults"/>
          </references>
        </variable>

        <variable name="omitunchangeddefaultbinds">
          <description>Omit unchanged default binds from saved.cfg.</description>
          <value token="N" description="0 = print; 1 = print, but commented out; 2 = omit" minValue="0" maxValue="2" defaultValue="1"/>
          <references>
            <identifierReference identifier="omitunchangeddefaults"/>
          </references>
        </variable>

        <command name="addpckserver">
          <description>Adds a packages source server where to download custom content from.</description>
          <remarks>
            <remark>Only add servers you trust.</remark>
            <remark>The list of servers is saved into config/pcksources.cfg on game quit.</remark>
            <remark>
            If a priority is given, it influences the sorting of servers. Servers with higher priority are queried first.
            If servers have the same priority, they are sorted by ping. Default priority is zero.
            </remark>
          </remarks>
          <arguments>
            <argument token="S" description="The server address. Trailing slash not needed."/>
            <argument token="P" description="priority of the server"/>
          </arguments>
          <examples>
            <example>
              <code>addpckserver http://packages.ac-akimbo.net</code>
            </example>
          </examples>
          <references>
            <identifierReference identifier="resetpckservers"/>
            <identifierReference identifier="autodownload"/>
            <identifierReference identifier="getpckserver"/>
          </references>
        </command>

        <command name="getpckserver">
          <description>Returns a table with four columns of all configured package servers.</description>
          <remarks>
            <remark>The columns are: host name, priority, ping and resolved.
            "resolved" is a flag, indicating, if the server answered the ping during game start.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="addpckserver"/>
            <identifierReference identifier="autodownload"/>
            <identifierReference identifier="resetpckservers"/>
          </references>
        </command>

        <command name="resetpckservers">
          <description>Resets the list of packages source servers where to download custom content from.</description>
          <remarks>
            <remark>Restart AssaultCube to take the effect.</remark>
          </remarks>
          <references>
            <identifierReference identifier="addpckserver"/>
            <identifierReference identifier="autodownload"/>
            <identifierReference identifier="getpckserver"/>
          </references>
        </command>

        <variable name="autodownload">
          <description>Determines if the game should try to download missing packages such as textures or mapmodels on the fly.</description>
          <value token="V" description="Note: This is turned on by default" minValue="0" maxValue="1" defaultValue="1"/>
        </variable>

        <variable name="autodownloaddebug">
          <description>When the variable autodownloaddebug is set to 1 and/or in debug binaries, more debug output is produced.</description>
          <value token="V" description="Add debug info to autodownload" minValue="0" maxValue="1" defaultValue="0"/>
        </variable>

        <command name="addzipmod">
          <description>Add the zip package file "mods/zipname.zip" to the virtual file system.</description>
          <remarks>
            <remark>
            Add the zip package file "mods/zipname.zip" to the virtual file system.
            Only files below the path "packages/" are added (and also files below "config/", if zipname starts with "###").
            If the size of the zip file is below "zipcachemaxsize", the whole zip file is cached in memory.
            (Un-cached zip files are kept open at all time, so caching keeps the number of simultaneously opened files lower.)
            </remark>
          </remarks>
          <arguments>
            <argument token="N" description="the name of the zip mod"/>
          </arguments>
          <references>
            <identifierReference identifier="getmod"/>
            <identifierReference identifier="zipcachemaxsize"/>
            <identifierReference identifier="zipmodremove"/>
            <identifierReference identifier="zipmodclear"/>
            <identifierReference identifier="zipmodlist"/>
            <identifierReference identifier="zipmodgetdesc"/>
            <identifierReference identifier="zipmodgetfiles"/>
            <identifierReference identifier="zipmodgetrevision"/>
          </references>
        </command>

        <variable name="zipcachemaxsize">
          <description>Maximal size of the file, which is cached in memory.</description>
          <remarks>
            <remark>
            If the size of the zip file is below "zipcachemaxsize",
            then during loading the whole zip file is cached in memory.
            When the size is greater, then zip is just opened as a file and read from disk.
            </remark>
          </remarks>
          <value token="S" description="size [kB]" minValue="0" maxValue="1024" defaultValue="512"/>
          <references>
            <identifierReference identifier="addzipmod"/>
          </references>
        </variable>

        <command name="zipmodremove">
          <description>Removes one zip file from the virtual file system.</description>
          <arguments>
            <argument token="N" description="the name of the zip mod"/>
          </arguments>
          <references>
            <identifierReference identifier="addzipmod"/>
            <identifierReference identifier="zipmodclear"/>
          </references>
        </command>

        <command name="zipmodclear">
          <description>Removes all zip files from the virtual file system.</description>
          <references>
            <identifierReference identifier="addzipmod"/>
            <identifierReference identifier="zipmodremove"/>
          </references>
        </command>

        <command name="zipmodlist">
          <description>Lists zip files in "mods/".</description>
          <remarks>
            <remark>
            By default or if "what" is "all", all zips are listed. If "what" is "active", only those zips,
            that are already in use, are listed. If "what" is "inactive", only the unused zip files are listed.
            </remark>
          </remarks>
          <arguments>
            <argument token="W" description="what" valueNotes="all, active, inactive"/>
          </arguments>
          <references>
            <identifierReference identifier="getmod"/>
            <identifierReference identifier="addzipmod"/>
            <identifierReference identifier="zipmodgetdesc"/>
            <identifierReference identifier="zipmodgetfiles"/>
            <identifierReference identifier="zipmodgetrevision"/>
          </references>
        </command>

        <command name="zipmodgetdesc">
          <description>Reads and returns the first 11 lines from the file "desc.txt" in the named zip file.</description>
          <remarks>
            <remark>
            The first line is supposed to contain a descriptive title for the zip (for use in menus)
            and the next 10 lines should contain a more detailed description (also for use in menus).
            The command also unpacks "preview.jpg" from the zip and mounts it as a temporary file
            under the name "packages/modpreviews/zipname.jpg".
            </remark>
          </remarks>
          <arguments>
            <argument token="N" description="the name of the zip mod"/>
          </arguments>
          <references>
            <identifierReference identifier="getmod"/>
            <identifierReference identifier="addzipmod"/>
            <identifierReference identifier="zipmodlist"/>
            <identifierReference identifier="zipmodgetfiles"/>
            <identifierReference identifier="zipmodgetrevision"/>
          </references>
        </command>

        <command name="zipmodgetfiles">
          <description>Returns the list of files contained in a zip file.</description>
          <arguments>
            <argument token="N" description="the name of the zip mod"/>
          </arguments>
          <references>
            <identifierReference identifier="getmod"/>
            <identifierReference identifier="addzipmod"/>
            <identifierReference identifier="zipmodlist"/>
            <identifierReference identifier="zipmodgetdesc"/>
            <identifierReference identifier="zipmodgetrevision"/>
          </references>
        </command>

        <command name="zipmodgetrevision">
          <description>Returns the revision number of the zip file.</description>
          <remarks>
            <remark>
            The number is supposed to be part of a filename: "revision_n".
            If no such file is found in the zip file, the return value is zero.
            The content of the revision file is not relevant and a file size of zero is recommended.
            </remark>
          </remarks>
          <arguments>
            <argument token="N" description="the name of the zip mod"/>
          </arguments>
          <references>
            <identifierReference identifier="getmod"/>
            <identifierReference identifier="addzipmod"/>
            <identifierReference identifier="zipmodlist"/>
            <identifierReference identifier="zipmodgetdesc"/>
            <identifierReference identifier="zipmodgetfiles"/>
          </references>
        </command>

        <command name="demonameformat">
          <description>Sets the formatstring for demo filenames.</description>
          <arguments>
            <argument token="S" description="string"/>
          </arguments>
          <remarks>
            <remark>we use the following internal mapping of formatchars:</remark>
            <remark>%g : gamemode (int) ; %G : gamemode (chr) ; %F : gamemode (full) ;</remark>
            <remark>%m : minutes remaining ; %M : minutes played ;</remark>
            <remark>%s : seconds remaining ; %S : seconds played ;</remark>
            <remark>%h : IP of server ; %H : hostname of server (client only) ;</remark>
            <remark>%n : mapname ;</remark>
            <remark>%w : timestamp "when" (formatted by demotimeformat) .</remark>
          </remarks>
          <references>
            <identifierReference identifier="demotimeformat"/>
          </references>
        </command>

        <command name="demotimeformat">
          <description>Sets the formatstring for demo timestamp.</description>
          <arguments>
            <argument token="S" description="string" valueNotes="strftime format"/>
          </arguments>
          <remarks>
            <remark>If the string starts with 'U', UTC is used - otherwise local time.</remark>
            <remark>The same format options as in strftime().</remark>
          </remarks>
          <references>
            <identifierReference identifier="demonameformat"/>
            <webReference url="http://www.cplusplus.com/reference/clibrary/ctime/strftime/" name="strftime() C++-Reference"/>
          </references>
        </command>

        <scriptalias name="afterinit">
          <description>If defined, this will be executed after saved.cfg is loaded.</description>
        </scriptalias>

        <scriptalias name="autoexec">
          <description>If defined, this will be executed after autoexec.cfg is loaded.</description>
        </scriptalias>

        <command name="enumfiles">
          <description>Lists files in a directory.</description>
          <remarks>
            <remark>If extension is specified, only files of that extension are listed.</remark>
            <remark>If the extension is "dir", only directories are listed.</remark>
          </remarks>
          <arguments>
            <argument token="P" description="path to directory"/>
            <argument token="E" description="extension"/>
          </arguments>
        </command>

        <variable name="dbgzip">
          <description>Output statistics and errors when handling zip compressed data.</description>
          <value token="B" description="boolean" minValue="0" maxValue="1" valueNotes="1:yes" defaultValue="0"/>
          <remarks>
            <remark>Advanced usage: may be helpful in debugging map files not loading.</remark>
          </remarks>
        </variable>

        <variable name="debugevents">
          <description>Whether or not to output input events.</description>
          <value token="T" description="threshhold" minValue="0" maxValue="2" valueNotes="0:off,1/2:on" defaultValue="0"/>
          <remarks>
            <remark>If set to at least 1 all events will output their type number. Window events and mouse button/wheel events will output status information.</remark>
            <remark>If set to 2 the KEYUP, TEXTINPUT and MOUSEMOVE events will trigger status output too.</remark>
          </remarks>
          <references>
            <identifierReference identifier=""/>
          </references>
        </variable>

        <variable name="disconnectonmaperror">
          <description>Disconnect from a server making us load an incompatible map.</description>
          <value token="B" description="boolean" minValue="0" maxValue="1" valueNotes="1:yes" defaultValue="1"/>
          <remarks>
            <remark>Maps that have not been converted to the new entity attribute scaling map format can cause this.</remark>
            <remark>Edit it offline and make use of the config/opt/convmap.cfg.</remark>
          </remarks>
        </variable>

      </identifiers>
    </section>
    <!-- General Section Ends -->
    <!-- Gameplay Section Starts -->
    <section name="Gameplay" sortindex="02">
      <description>This section describes gameplay related identifiers.</description>
      <identifiers sort="true">
      
        <scriptalias name="start_intermission">
          <description>If this alias exists it will be run when the game reaches intermission.</description>
          <examples>
            <example>
              <code>
                <![CDATA[
                start_intermission = [
                echo "INTERMISSION - STATISTICS TIME"
                loop p 255 [
                pn = (player $p name)
                if (strcmp $pn "") [ ] [
                echo (concatword Player $p ":") (pstat_score $p) ":" (pstat_weap $p)
                ]
                ]
                echo "------------------------------"
                ]
                ]]>
              </code>
              <explanation>This will output the full statistics line for all players.</explanation>
            </example>
          </examples>
          <references>
            <identifierReference identifier="pstat_score"/>
            <identifierReference identifier="pstat_weap"/>
          </references>
        </scriptalias>

        <scriptalias name="mapstartonce">
          <description>If this alias exists it will be run when the game starts a new map, then it is deleted.</description>
          <examples>
            <example>
              <code>
                <![CDATA[
                mapstartonce = [
                echo "------------------------------"
                ]
                ]]>
              </code>
              <explanation>This will output the string and override any other actions that might've been defined.</explanation>
            </example>
            <example>
              <code>
                <![CDATA[
                addOnLoadOnce [
                echo "------------------------------"
                ]
                ]]>
              </code>
              <explanation>This will output the string after any previously defined actions have run.</explanation>
            </example>
          </examples>
          <references>
            <identifierReference identifier="add2alias"/>
            <identifierReference identifier="mapstartalways"/>
            <identifierReference identifier="onNewMap"/>
          </references>
        </scriptalias>

        <scriptalias name="mapstartalways">
          <description>If this alias exists it will be run every time the game starts a new map.</description>
          <examples>
            <example>
              <code>
                <![CDATA[
                mapstartalways = [
                echo "------------------------------"
                ]
                ]]>
              </code>
              <explanation>This will output the string and override any other actions that might've been defined.</explanation>
            </example>
            <example>
              <code>
                <![CDATA[
                addOnLoadAlways [
                echo "------------------------------"
                ]
                ]]>
              </code>
              <explanation>This will output the string after any previously defined actions have run.</explanation>
            </example>
          </examples>
          <references>
            <identifierReference identifier="add2alias"/>
            <identifierReference identifier="mapstartonce"/>
            <identifierReference identifier="onNewMap"/>
          </references>
        </scriptalias>

        <scriptalias name="onCallVote">
          <description>If this alias exists it will be run every time a vote is called.</description>
          <references>
            <identifierReference identifier="onChangeVote"/>
            <identifierReference identifier="onVoteEnd"/>
          </references>
        </scriptalias>

        <scriptalias name="onChangeVote">
          <description>If this alias exists it will be run every time a vote is changed.</description>
          <references>
            <identifierReference identifier="onCallVote"/>
            <identifierReference identifier="onVoteEnd"/>
          </references>
        </scriptalias>

        <scriptalias name="onVoteEnd">
          <description>If this alias exists it will be run every time a vote passes or fails.</description>
          <references>
            <identifierReference identifier="onCallVote"/>
            <identifierReference identifier="onChangeVote"/>
          </references>
        </scriptalias>

        <variable name="votepending">
          <description>Determines if there is a vote pending or not.</description>
          <examples>
            <example>
              <code><![CDATA[echo $votepending]]></code>
              <explanation>Output: if there is currently a vote pending, returns 1, else returns 0.</explanation>
            </example>
          </examples>
        </variable>

        <scriptalias name="onKill">
          <description>If it exists, this alias will be executing when any player get killed, receiving a few arguments.</description>
          <arguments>
            <argument token="actor" description="The client number of the actor" valueNotes="integer"/>
            <argument token="target" description="The client number of the target" valueNotes="integer"/>
            <argument token="gun" description="The number of the gun used" valueNotes="integer"/>
            <argument token="gib" description="Is it a gib or a normal frag" valueNotes="integer (0 or 1)"/>
          </arguments>
          <remarks>
            <remark>Remark: it works only in singleplayer.</remark>
          </remarks>
          </scriptalias>

        <scriptalias name="onFlag">
          <arguments>
            <argument token="action" description="The action that occured" valueNotes="integer (0 = stolen, 1 = dropped, 2 = lost, 3 = returned, 4 = scored, 5 = ktfscore, 6 = failed to score, 7 = reset)"/>
            <argument token="actor" description="The client number of the actor" valueNotes="integer"/>
            <argument token="flag" description="The flag owner team" valueNotes="integer (0 = CLA, 1 = RVSF)"/>
          </arguments>
          <description>If defined, this will be executed each time a flag action occurs.</description>
          <remarks>
            <remark>Remark: it works only in singleplayer.</remark>
          </remarks>
        </scriptalias>

        <scriptalias name="onPickup">
          <arguments>
            <argument token="item" description="The item that was picked up" valueNotes="integer (0 = pistol clips, 1 = ammo box, 2 = grenade, 3 = health, 4 = helmet, 5 = armour, 6 = akimbo)"/>
            <argument token="q" description="The quantity that was received"/>
          </arguments>
          <description>If defined, this will be executed each time you pick up an item.</description>
          <remarks>
            <remark>Remark: it works only in singleplayer.</remark>
          </remarks>
        </scriptalias>

        <scriptalias name="onAttack">
          <arguments>
            <argument token="weapon" description="The weapon that was used"/>
          </arguments>
          <description>If defined, this will be executed each time you shot a bullet, throw a grenade or use your knife.</description>
          <remarks>
            <remark>Remark: it works only in singleplayer.</remark>
          </remarks>
        </scriptalias>

        <scriptalias name="onHit">
          <arguments>
            <argument token="actor" description="The client number of the actor" valueNotes="integer"/>
            <argument token="target" description="The client number of the target" valueNotes="integer"/>
            <argument token="damage" description="The damage done" valueNotes="integer"/>
            <argument token="gun" description="The number of the gun used" valueNotes="integer"/>
            <argument token="gib" description="Is it a gib or a normal frag" valueNotes="integer (0 or 1)"/>
          </arguments>
          <description>If it's defined, this alias will be executed each time a damage is done.</description>
          <remarks>
            <remark>Remark: it works only in singleplayer.</remark>
          </remarks>
        </scriptalias>

        <scriptalias name="onWeaponSwitch">
          <arguments>
            <argument token="W" description="The weapon number that you switched to"/>
          </arguments>
          <description>If defined, this will be executed each time you switch to a different weapon.</description>
          <remarks>
            <remark>Remark: it works only in singleplayer.</remark>
          </remarks>
        </scriptalias>
        
        <scriptalias name="onReload">
          <arguments>
            <argument token="B" description="was autoreload?" valueNotes="0 (false), 1 (true)"/>
          </arguments>
          <description>If defined, this will be executed each time you reload a weapon.</description>
          <remarks>
            <remark>Remark: it works only in singleplayer.</remark>
          </remarks>
        </scriptalias>

        <scriptalias name="onConnect">
          <arguments>
            <argument token="player" description="The client number of the player who connected" valueNotes="integer (-1 for local player)"/>
          </arguments>
          <description>If defined, this will be executed when you or another player join(s) a server.</description>
        </scriptalias>

        <scriptalias name="onDisconnect">
          <arguments>
            <argument token="player" description="The client number of the player who disconnected" valueNotes="integer (-1 for local player)"/>
          </arguments>
          <description>If defined, this will be executed when you or another player disconnect(s) from a server.</description>
        </scriptalias>

        <scriptalias name="onSpawn">
          <arguments>
            <argument token="player" description="The client number of the player who spawned" valueNotes="integer"/>
          </arguments>
          <description>If defined, this will be executed each time a player spawns.</description>
          <remarks>
            <remark>Remark: it works only in singleplayer.</remark>
          </remarks>
        </scriptalias>

        <scriptalias name="onNameChange">
          <arguments>
            <argument token="player" description="The client number of the player who changed name" valueNotes="integer"/>
            <argument token="new name" description="The new name of the client" valueNotes="string"/>
          </arguments>
          <description>If defined, this will be executed when you or another player change(s) his name.</description>
          <remarks>
            <remark>The alias is executed before the name is effectively changed, so you can still get the previous name of the client from this alias.</remark>
            <remark>Remark: it works only in singleplayer.</remark>
          </remarks>
        </scriptalias>

         <scriptalias name="onPM">
          <arguments>
            <argument token="player" description="The client number who sent you private message" valueNotes="integer"/>
            <argument token="message" description="The private message" valueNotes="string"/>
          </arguments>
          <description>If defined, this will be executed when another player sent you private message.</description>
        </scriptalias>

        <command name="pstat_weap">
          <description>Returns the shot statistics for the player with the given clientnumber.</description>
          <arguments>
            <argument token="C" description="client" valueNotes="0..N"/>
          </arguments>
          <examples>
            <example>
              <code>
                <![CDATA[
                echo (pstat_weap 0)
                ]]>
              </code>
              <explanation>Output: 0 0 0 0 0 0 0 0 0 0 1 240 15 312 0 0 3 112 0 0</explanation>
              <explanation>The output is a list of tuples for all weapons, SHOTS-FIRED and DAMAGE-DEALT for each.</explanation>
            </example>
          </examples>
          <remarks>
            <remark>The list is:</remark>
            <remark>knife/atk dmg pistol/atk dmg carbine/atk dmg shotgun/atk dmg smg/atk dmg sniper/atk dmg assault/atk dmg nade/atk dmg akimbo/atk dmg</remark>
          </remarks>
          <references>
            <identifierReference identifier="start_intermission"/>
            <identifierReference identifier="pstat_score"/>
            <identifierReference identifier="weapon"/>
          </references>
        </command>

        <command name="shiftweapon">
          <description>Shifts your selected weapon by a given delta.</description>
          <remarks>
            <remark>By default the mouse-wheel shifts one up or down according to your scroll direction.</remark>
          </remarks>
          <defaultKeys>
            <key alias="MOUSE4" description="cycle one up"/>
            <key alias="MOUSE5" description="cycle one down"/>
          </defaultKeys>
          <arguments>
            <argument token="D" description="delta" valueNotes="-N..-1,+1..N"/>
          </arguments>
        </command>

        <command name="setscope">
          <description>Displays a scope for the sniper-rifle.</description>
          <remarks>
            <remark>It is used in the zoom-script (config/scripts.cfg: "const zoom").</remark>
          </remarks>
          <arguments>
            <argument token="Y" description="scope on?" valueNotes="0 or 1"/>
          </arguments>
          <defaultKeys>
            <key alias="MOUSE2" name="right mouse button"/>
          </defaultKeys>
        </command>

        <command name="togglespect">
          <description>Cycles through all available spectator modes.</description>
          <remarks>
            <remark>These modes are: Follow-1stPerson, Follow-3rdPerson, Follow-3rdPerson-transparent and Fly.</remark>
          </remarks>
          <defaultKeys>
            <key alias="SPACE" description="cycle spectator modes"/>
          </defaultKeys>
        </command>

        <command name="whois">
          <description>Get the IP address of a given clientnumber - only admins get shown the last octet.</description>
          <arguments>
            <argument token="C" description="clientnum"/>
          </arguments>
        </command>

        <command name="vote">
          <description>Agree or disagree to the currently running vote.</description>
          <arguments>
            <argument token="V" description="vote value" valueNotes="1 (yes) OR 2 (no)"/>
          </arguments>
          <defaultKeys>
            <key alias="F1" description="votes YES"/>
            <key alias="F2" description="votes NO"/>
          </defaultKeys>
        </command>

        <command name="gonext">
          <description>Go to the next match in the servers rotation for the desired gamemode.</description>
          <arguments>
            <argument token="M" description="gamemode" valueNotes="0:TDM,5:CTF,10:OSOK"/>
          </arguments>
          <remarks>
            <remark>TODO: elaborate</remark>
          </remarks>
        </command>

        <command name="setnext">
          <description>Call a vote for mode and map.</description>
          <arguments>
            <argument token="G" description="gamemode" valueNotes="0:TDM,5:CTF,10:OSOK"/>
            <argument token="M" description="map" valueNotes="ac_mines,ac_douze,megamap"/>
          </arguments>
          <remarks>
            <remark>TODO: elaborate</remark>
          </remarks>
        </command>

        <command name="voicecom">
          <arguments>
            <argument token="S" description="sound" valueNotes="must be a registered voicecom-sound"/>
            <argument token="T" description="text"/>
          </arguments>
          <defaultKeys>
            <key alias="V" description="opens the voicecom menu, use number keys for your choice"/>
          </defaultKeys>
        </command>

        <variable name="voicecomsounds">
          <description>Enables or disables voicecom audio.</description>
          <value token="N" description="voicecom sounds" minValue="0" maxValue="2" defaultValue="1"/>
          <arguments>
            <argument valueNotes="0 (off)"/>
            <argument valueNotes="1 (always play voicecom audio)"/>
            <argument valueNotes="2 (only play voicecom audio from you and your teammates)"/>
          </arguments>
        </variable>

        <command name="loadcrosshair">
          <description>Loads a crosshair for given type.</description>
          <examples>
            <example>
              <code><![CDATA[loadcrosshair red_dot.png]]></code>
              <explanation>Loads the red_dot.png crosshair for all weapons.</explanation>
            </example>
            <example>
              <code><![CDATA[loadcrosshair default red_dot.png]]></code>
              <explanation>Same as above. Loads the red_dot.png crosshair for all weapons.</explanation>
            </example>
            <example>
              <code><![CDATA[loadcrosshair knife red_dot.png]]></code>
              <explanation>Loads the red_dot.png crosshair for your knife only.</explanation>
            </example>
            <example>
              <code><![CDATA[loadcrosshair assault red_dot.png]]></code>
              <explanation>Loads the red_dot.png crosshair for your assault rifle only.</explanation>
            </example>
            <example>
              <code><![CDATA[loadcrosshair scope red_dot.png]]></code>
              <explanation>Loads the red_dot.png crosshair for your sniper rifle scope only.</explanation>
            </example>
            <example>
              <code><![CDATA[loadcrosshair reset]]></code>
              <explanation>Loads all default crosshairs (including teammate and scope).</explanation>
            </example>
          </examples>
          <arguments>
            <argument token="T" description="type" valueNotes="default, teammate, scope, edit, knife, pistol, carbine, shotgun, subgun, sniper, assault, grenade, akimbo, reset"/>
            <argument token="I" description="image"/>
          </arguments>
        </command>

        <command name="listdemos">
          <description>Get the game demos listing from the server we are currently connected.</description>
          <references>
            <identifierReference identifier="getdemo"/>
            <identifierReference identifier="cleardemo"/>
          </references>
        </command>

        <command name="getdemo">
        <description>Gets the recorded demo from a game on the server.</description>
        <remarks>
          <remark>If F10 is pressed earlier than two minutes into the game, the last game will be downloaded.</remark>
          <remark>
          If F10 is pressed later than two minutes into the game, the current game is scheduled to be automatically downloaded when it ends.
          </remark>
        </remarks>
          <arguments>
            <argument token="X" description="number in list"/>
            <argument token="P" description="subpath" optional="true"/>
          </arguments>
          <references>
            <identifierReference identifier="listdemos"/>
          </references>
        </command>

        <command name="dropflag">
          <description>Drops the taken flag.</description>
          <defaultKeys>
            <key alias="BACKSPACE" name="Backspace"/>
            <key alias="X"/>
          </defaultKeys>
        </command>

        <command name="crouch">
          <description>Triggers a crouch.</description>
          <defaultKeys>
            <key alias="LSHIFT" name="left Shift"/>
          </defaultKeys>
        </command>

        <command name="jump">
          <description>Triggers a jump.</description>
          <defaultKeys>
            <key alias="SPACE|RCTRL" name="Space or right Ctrl"/>
          </defaultKeys>
        </command>

        <command name="changefollowplayer">
          <arguments>
            <argument token="D" description="delta" valueNotes="how many players to shift +/-"/>
          </arguments>
          <references>
            <identifierReference identifier="setfollowplayer"/>
          </references>
        </command>

        <command name="setfollowplayer">
          <arguments>
            <argument token="C" description="clientnum" valueNotes="which player to follow"/>
          </arguments>
          <references>
            <identifierReference identifier="changefollowplayer"/>
            <identifierReference identifier="spectatecn"/>
          </references>
        </command>

        <command name="spectatecn">
          <description>Returns client number of spectated player.</description>
          <references>
            <identifierReference identifier="setfollowplayer"/>
          </references>
        </command>

        <command name="teaminfo">
          <description>Returns attributes of a team.</description>
          <arguments>
            <argument token="T" description="Team" valueNotes="cla, rvsf, 0, 1"/>
            <argument token="A" description="Attribute" valueNotes="Valid attributes: flags, frags, deaths, points, name, players"/>
          </arguments>
        </command>

        <command name="curmap">
          <description>Returns the current map being played.</description>
          <references>
            <identifierReference identifier="gamemode"/>
            <identifierReference identifier="map"/>
            <identifierReference identifier="mode"/>
          </references>
        </command>

        <variable name="curmaprevision">
          <description>Current map revision number.</description>
        </variable>

        <command name="curmastermode">
          <description>Returns the server's current mastermode state.</description>
        </command>

        <command name="curautoteam">
          <description>Returns the server's current autoteam state.</description>
        </command>

        <command name="curpausemode">
          <description>Returns the server's current pause state (1=paused, 0=resumed).</description>
        </command>

        <command name="currentprimary">
          <description>Returns the weapon-index the local player currently has selected as primary.</description>
          <remarks>
            <remark>This is not the same as curweapon - which could be a grenade or the knife.</remark>
          </remarks>
          <references>
            <identifierReference identifier="nextprimary"/>
            <identifierReference identifier="curweapon"/>
            <identifierReference identifier="prevweapon"/>
            <identifierReference identifier="weapon"/>
            <identifierReference identifier="magcontent"/>
            <identifierReference identifier="magreserve"/>
            <identifierReference identifier="hasprimary"/>
          </references>
        </command>

        <command name="hasprimary">
          <description>Determines if the local player (you) are currently carrying a primary weapon.</description>
          <examples>
            <example>
              <code><![CDATA[add2bind MOUSE1 [ if (hasprimary) [ echo you attacked with a primary weapon ] ]]]></code>
              <explanation>Everytime you press the left mouse button, assuming you are carrying your primary weapon, the above echo will be executed.</explanation>
            </example>
          </examples>
          <references>
            <identifierReference identifier="currentprimary"/>
            <identifierReference identifier="curweapon"/>
            <identifierReference identifier="checkmag"/>
          </references>
          <remarks>
            <remark>Returns 0 (false) or 1 (true).</remark>
          </remarks>
        </command>

        <command name="curserver">
          <description>Returns information on the current server - if you're connected to one.</description>
          <remarks>
            <remark>If I is 0 (omitted or any other value than the ones below) you will get a string with 'IP PORT'</remark>
            <remark>If I is 1,2 or 3 you will get the IP, HostName or port respectively.</remark>
            <remark>If I is 4 you get a string representing the current state of the peer - usually this should be 'connected'.</remark>
            <remark>If I is 5 you will get a server name.</remark>
            <remark>If I is 6 or 7 you will get a server description.</remark>
            <remark>If I is 8, you will get a serverbrowser-line with the server - this is handled with caution, sometimes empty, #8 will be outdated w/o serverbrowser open.</remark>
          </remarks>
          <arguments>
            <argument token="I" description="info" valueNotes="0, 1, 2, 3, 4, 5, 6, 7, 8"/>
          </arguments>
          <examples>
            <example>
              <code><![CDATA[echo [I am (curserver 4) to (curserver 2)]]]></code>
              <explanation>Output: I am connected to ctf-only.assault-servers.net</explanation>
            </example>
            <example>
              <code>
                <![CDATA[
                last_server = ""
                remember_server = [ if (strcmp (curserver 4) "connected")
                [ last_server = (curserver 0) echo "I'm remembering:" $last_server ]
                [ echo "you are not 'connected' - you" (concatword "are '" (curserver 4) "' !") ] ]
                bind PRINT [ if (strcmp $last_server "") [ remember_server ]
                [ say (concat "^L2I was just ^Lfon^L3" $last_server) last_server = "" ] ]]]></code>
              <explanation>This will either remember or retrieve the last server you pressed the PrintScreen-key on.</explanation>
            </example>
          </examples>
        </command>

        <command name="curweapon">
          <description>Returns the weapon-index the local player is currently holding.</description>
          <references>
            <identifierReference identifier="currentprimary"/>
            <identifierReference identifier="nextprimary"/>
            <identifierReference identifier="prevweapon"/>
            <identifierReference identifier="weapon"/>
            <identifierReference identifier="magcontent"/>
            <identifierReference identifier="magreserve"/>
            <identifierReference identifier="hasprimary"/>
          </references>
        </command>

        <command name="prevweapon">
          <description>Returns the weapon-index the local player was previously holding.</description>
          <references>
            <identifierReference identifier="currentprimary"/>
            <identifierReference identifier="nextprimary"/>
            <identifierReference identifier="curweapon"/>
            <identifierReference identifier="weapon"/>
            <identifierReference identifier="magcontent"/>
            <identifierReference identifier="magreserve"/>
          </references>
        </command>

        <command name="map">
          <description>Loads up a map in the gamemode set previously by the 'mode' command.</description>
          <remarks>
            <remark>
              If connected to a multiplayer server, it votes to load the map (others will have to type "map M" as well
              to agree with loading this map). To vote for a map with a specific mode, set the mode before you issue the map command.
            </remark>
            <remark>
              A map given as "blah" refers to "packages/maps/blah.cgz", "mypackage/blah" refers to "packages/mypackage/blah.cgz".
              At every map load, "config/default_map_settings.cfg" is loaded which sets up all texture definitions, etc. Everything
              defined there can be overridden per package or per map by creating a "mapname.cfg" which
              contains whatever you want to do differently from the default.
            </remark>
            <remark>
              When the map finishes it will load the next map when one is defined, otherwise it reloads the current map.
              You can define what map follows a particular map by making an alias like (in the map script): alias nextmap_blah1 blah2
              (loads "blah2" after "blah1").
            </remark>
          </remarks>
          <arguments>
            <argument token="M" description="Name of the map to load" valueNotes="string"/>
          </arguments>
          <references>
            <identifierReference identifier="votemap"/>
            <identifierReference identifier="loadmap"/>
            <identifierReference identifier="mode"/>
          </references>
        </command>

        <command name="votemap">
          <description>Sets the next gamemode then calls a vote for a map.</description>
          <arguments>
            <argument token="I" description="mode id"/>
            <argument token="M" description="map name"/>
          </arguments>
          <references>
            <identifierReference identifier="map"/>
            <identifierReference identifier="loadmap"/>
            <identifierReference identifier="mode"/>
          </references>
        </command>

        <command name="loadmap">
          <description>Loads a map directly in the current gamemode (singleplayer only).</description>
          <arguments>
            <argument token="M" description="map name"/>
          </arguments>
          <references>
            <identifierReference identifier="map"/>
            <identifierReference identifier="votemap"/>
            <identifierReference identifier="mode"/>
          </references>
        </command>

        <variable name="nextprimary">
          <description>Sets the primary weapon on next respawn.</description>
          <arguments>
            <argument token="A" description="the weapon number or name" valueNotes="2 (carbine), 3 (shotgun), 4 (subgun), 5 (sniper), 6 (assault)"/>
          </arguments>
        </variable>

        <command name="reload">
          <description>Reloads the weapon.</description>
          <arguments>
            <argument token="A" description="" valueNotes="value"/>
          </arguments>
          <defaultKeys>
            <key alias="R"/>
          </defaultKeys>
          <references>
            <identifierReference identifier="autoreload"/>
          </references>
        </command>

        <command name="name">
          <description>Sets the nick name for the local player.</description>
          <arguments>
            <argument token="N" description="the name"/>
          </arguments>
          <references>
            <identifierReference identifier="curname"/>
          </references>
        </command>

        <variable name="curname">
          <description>Returns the nick name of the local player.</description>
          <references>
            <identifierReference identifier="name"/>
          </references>
        </variable>

        <command name="say">
          <description>Outputs text to other players.</description>
          <remarks>
            <remark>
              If the text begins with a percent character (%),
              only team mates will receive the message.
            </remark>
          </remarks>
          <arguments>
            <variableArgument token="S..." description="the text"/>
          </arguments>
        </command>

        <command name="pm">
          <description>Sends a private message to a specified client.</description>
          <arguments>
            <argument token="C" description="Client number"/>
            <argument token="L" description="List of strings"/>
          </arguments>
          <references>
            <identifierReference identifier="say"/>
            <identifierReference identifier="quickanswer"/>
            <identifierReference identifier="lastpm"/>
          </references>
        </command>

        <variable name="lastpm">
          <description>Holds the CN of the last client who sent you a private message.</description>
          <references>
            <identifierReference identifier="pm"/>
            <identifierReference identifier="quickanswer"/>
          </references>
          <remarks>
            <remark>If you haven't recieved any private messages, 'lastpm' is -1</remark>
          </remarks>
        </variable>

        <command name="quickanswer">
          <description>Easily respond the last client who sent you a private message.</description>
          <defaultKeys>
            <key alias="N"/>
          </defaultKeys>
          <references>
            <identifierReference identifier="pm"/>
            <identifierReference identifier="lastpm"/>
          </references>
        </command>

        <command name="ignore">
          <description>Ignore a player.</description>
          <arguments>
            <argument token="A" description="client number"/>
          </arguments>
          <remarks>
            <remark>You won't see any further game chat or hear any more voice com messages from that player.</remark>
          </remarks>
        </command>

        <command name="listignored">
          <description>Print a list of all players that you are currently ignoring.</description>
        </command>

        <command name="clearignored">
          <description>Clear list of ignored players.</description>
          <arguments>
            <argument token="A" description="client number, or -1 to clear the whole list"/>
          </arguments>
          <remarks>
            <remark>Omit the client number to clear the whole list.</remark>
          </remarks>
        </command>

        <command name="ignoreall">
          <description>Ignore all clients currently on the server.</description>
          <references>
            <identifierReference identifier="unignoreall"/>
            <identifierReference identifier="ignoreteam"/>
            <identifierReference identifier="ignoreenemy"/>
          </references>
        </command>

        <command name="unignoreall">
          <description>Unignore all clients currently on the server.</description>
          <references>
            <identifierReference identifier="ignoreall"/>
            <identifierReference identifier="ignoreteam"/>
            <identifierReference identifier="ignoreenemy"/>
          </references>
        </command>

        <command name="ignoreteam">
          <description>Ignore all clients on the specified team.</description>
          <references>
            <identifierReference identifier="ignoreall"/>
            <identifierReference identifier="unignoreall"/>
            <identifierReference identifier="ignoreenemy"/>
          </references>
          <arguments>
            <argument token="T" description="the team to ignore" valueNotes="0 or 1 || cla or rvsf"/>
          </arguments>
        </command>

        <command name="ignoreenemy">
          <description>Ignore all clients on the enemy team.</description>
          <references>
            <identifierReference identifier="ignoreall"/>
            <identifierReference identifier="unignoreall"/>
            <identifierReference identifier="ignoreteam"/>
          </references>
        </command>

        <command name="muteplayer">
          <description>Mutes a player.</description>
          <arguments>
            <argument token="A" description="client number"/>
          </arguments>
          <remarks>
            <remark>You won't hear any further voice com messages from that player.</remark>
          </remarks>
        </command>

        <command name="clearmuted">
          <description>Clears a list of muted players.</description>
          <arguments>
            <argument token="A" description="client number, or -1 to clear the whole list"/>
          </arguments>
          <remarks>
            <remark>Omit the client number to clear the whole list.</remark>
          </remarks>
        </command>

        <command name="listmuted">
          <description>Prints a list of all players that you have muted.</description>
        </command>

        <command name="me">
          <description>Action chat message.</description>
          <arguments>
            <variableArgument token="..." description="..."/>
          </arguments>
        </command>

        <command name="nickcomplete">
          <argument token="C" description="command" valueNotes="any command or alias"/>
          <description>Adds a command to complete nicknames on.</description>
          <remarks>
            <remark>Your own nick will be ignored.</remark>
          </remarks>
          <examples>
            <example>
              <code><![CDATA[nickgreet = [ say (concat "Hello," (concatword $arg1 "!")) ]; nickcomplete nickgreet]]></code>
              <explanation>with this you can enter "/nickgreet " and cycle via TAB to the nickname you want to greet.</explanation>
            </example>
          </examples>
          <references>
            <identifierReference identifier="complete"/>
          </references>
        </command>

        <command name="connect">
          <description>Connects to a server.</description>
          <remarks>
            <remark>
              If the server name is omitted, the client will try to connect to an available server in the LAN.
              If the port is omitted or set to 0, the default port will be used.
            </remark>
          </remarks>
          <examples>
            <example>
              <code><![CDATA[connect 127.0.0.1 555 myServerPassword]]></code>
            </example>
          </examples>
          <references>
            <identifierReference identifier="connectadmin"/>
            <identifierReference identifier="disconnect"/>
            <identifierReference identifier="reconnect"/>
          </references>
          <arguments>
            <argument token="N" description="the address of the server (hostname or IP)" optional="true"/>
            <argument token="O" description="the port" optional="true"/>
            <argument token="P" description="the server password" optional="true"/>
          </arguments>
        </command>

        <command name="connectadmin">
          <description>Connects to a server and tries to claim admin state.</description>
          <remarks>
            <remark>
              This command will connect to a server just like the command 'connect' and
              try to claim admin state. If the specified password is correct, the admin
              will be able to connect even if he is locked out by ban, private master mode or taken client slots.
              If successfully connected, bans assigned to the admin's host will be removed automatically. If all
              client slots are taken a random client will be kicked to let the admin in.
            </remark>
            <remark>
              If the server name ist omitted, the client will try to connect to an available server in the LAN.
              If the port is omitted or set to 0, the default port will be used.
            </remark>
          </remarks>
          <examples>
            <example>
              <code><![CDATA[connectadmin 127.0.0.1 777 myAdminPassword]]></code>
              <explanation>connect as admin on port 777 of localhost</explanation>
            </example>
            <example>
              <code><![CDATA[connectadmin "" 0 myAdminPassword]]></code>
              <explanation>will try to connect to a LAN server on the default port as admin with the given password of "myAdminPassword".</explanation>
            </example>
          </examples>
          <references>
            <identifierReference identifier="connect"/>
            <identifierReference identifier="disconnect"/>
            <identifierReference identifier="reconnect"/>
          </references>
          <arguments>
            <argument token="N" description="the address of the server (hostname or IP)" optional="true"/>
            <argument token="O" description="the port" optional="true"/>
            <argument token="P" description="the admin password"/>
          </arguments>
        </command>

        <command name="disconnect">
          <description>Leaves a server.</description>
          <references>
            <identifierReference identifier="reconnect"/>
            <identifierReference identifier="connect"/>
            <identifierReference identifier="connectadmin"/>
          </references>
        </command>

        <command name="reconnect">
          <description>Disconnects then reconnects you to the current server.</description>
          <arguments>
            <argument token="P" description="the server password" optional="true"/>
          </arguments>
          <references>
            <identifierReference identifier="disconnect"/>
            <identifierReference identifier="connect"/>
            <identifierReference identifier="connectadmin"/>
          </references>
        </command>

        <command name="lanconnect">
          <description>Tries to connect to a LAN server.</description>
        </command>

        <command name="team">
          <description>Sets the team for the local player.</description>
          <examples>
            <example>
              <code><![CDATA[team CLA]]></code>
            </example>
          </examples>
          <arguments>
            <argument token="N" description="the team number or name" valueNotes="0 (CLA), 1 (RVSF), 2 (CLA-SPECT), 3 (RVSF-SPECT), 4 (SPECTATOR)"/>
          </arguments>
          <references>
            <identifierReference identifier="changeteam"/>
          </references>
        </command>

        <variable name="changeteam">
          <description>Swaps your player to the enemy team.</description>
          <references>
            <identifierReference identifier="team"/>
          </references>
        </variable>

        <command name="benchme">
          <description>Moves from active team to spectator during match.</description>
        </command>

        <command name="modconnect">
          <description>Connects to a modded server.</description>
          <arguments>
            <argument token="A" description="IP"/>
            <argument token="B" description="port"/>
            <argument token="C" description="password"/>
          </arguments>
          <remarks>
            <remark>
              The modified server needs to use the original client-server protocol. The protocol version number
              will be the negated value of an unmodded server.
            </remark>
          </remarks>
        </command>

        <command name="modconnectadmin">
          <description>Connects to a modded server and tries to claim admin state.</description>
          <arguments>
            <argument token="A" description="IP"/>
            <argument token="B" description="port"/>
            <argument token="C" description="admin password"/>
          </arguments>
          <remarks>
            <remark>
              The modified server needs to use the original client-server protocol. The protocol version number
              will be the negated value of an unmodded server.
            </remark>
          </remarks>
        </command>

        <command name="modlanconnect">
          <description>Tries to connect to a modified LAN server.</description>
          <remarks>
            <remark>
              The modified server needs to use the original client-server protocol. The protocol version number
              will be the negated value of an unmodded server.
            </remark>
          </remarks>
        </command>

        <variable name="akimboautoswitch">
          <description>Whether or not to automatically switch to akimbo upon pickup.</description>
          <value token="B" description="boolean" minValue="0" maxValue="1" valueNotes="1:yes" defaultValue="1"/>
          <remarks>
            <remark>If you are brandishing your pistol while walking over the pickup you will switch to akimbo every time.</remark>
          </remarks>
        </variable>

        <command name="weapon">
          <description>Changes the weapon (must be bound to a key).</description>
          <arguments>
            <argument token="N" description="the number/name of available weapon" valueNotes="0 (knife), 1 (pistol), 2 (carbine), 3 (shotgun), 4 (subgun), 5 (sniper), 6 (assault), 7 (grenades), 8 (akimbo)"/>
          </arguments>
        </command>

        <command name="primary">
          <description>Switches to your current primary weapon (must be bound to a key).</description>
          <defaultKeys>
            <key alias="1"/>
          </defaultKeys>
          <references>
            <identifierReference identifier="secondary"/>
            <identifierReference identifier="melee"/>
            <identifierReference identifier="grenades"/>
          </references>
        </command>

        <command name="secondary">
          <description>Switches to your secondary weapon (must be bound to a key).</description>
          <defaultKeys>
            <key alias="2"/>
          </defaultKeys>
          <references>
            <identifierReference identifier="primary"/>
            <identifierReference identifier="melee"/>
            <identifierReference identifier="grenades"/>
          </references>
        </command>

        <command name="melee">
          <description>Switches to knife (must be bound to a key).</description>
          <defaultKeys>
            <key alias="4" description="switches to knife"/>
            <key alias="MOUSE3" name="middle mouse button" description="switches to knife and attacks (if the key is held)"/>
          </defaultKeys>
          <references>
            <identifierReference identifier="primary"/>
            <identifierReference identifier="secondary"/>
            <identifierReference identifier="grenades"/>
          </references>
        </command>

        <command name="grenades">
          <description>Switches to grenades, if available (must be bound to a key).</description>
          <remarks>
            <remark>See also "quicknadethrow" command.</remark>
          </remarks>
          <defaultKeys>
            <key alias="3" description="switches to grenades"/>
          </defaultKeys>
          <references>
            <identifierReference identifier="primary"/>
            <identifierReference identifier="secondary"/>
            <identifierReference identifier="melee"/>
            <identifierReference identifier="quicknadethrow"/>
          </references>
        </command>

        <command name="sndtoggle">
          <description>Toggles between your primary weapon and secondary weapon (must be bound to a key).</description>
          <references>
            <identifierReference identifier="knftoggle"/>
            <identifierReference identifier="gndtoggle"/>
          </references>
        </command>

        <command name="knftoggle">
          <description>Toggles between your primary weapon and knife (must be bound to a key).</description>
          <references>
            <identifierReference identifier="sndtoggle"/>
            <identifierReference identifier="gndtoggle"/>
          </references>
        </command>

        <command name="gndtoggle">
          <description>Toggles between your primary weapon and grenades (must be bound to a key).</description>
          <references>
            <identifierReference identifier="sndtoggle"/>
            <identifierReference identifier="knftoggle"/>
          </references>
        </command>

        <command name="magcontent">
          <description>Returns contents of current magazine.</description>
          <remarks>
            <remark>A knife will always return 1.</remark>
            <remark>Weapons that aren't available will return -1.</remark>
          </remarks>
          <references>
            <identifierReference identifier="curweapon"/>
            <identifierReference identifier="currentprimary"/>
            <identifierReference identifier="nextprimary"/>
            <identifierReference identifier="prevweapon"/>
            <identifierReference identifier="weapon"/>
            <identifierReference identifier="magreserve"/>
          </references>
          <arguments>
            <argument token="N" description="the weapon number or name" valueNotes="0 (knife), 1 (pistol), 2 (carbine), 3 (shotgun), 4 (subgun), 5 (sniper), 6 (assault), 7 (grenades), 8 (akimbo)"/>
          </arguments>
        </command>

        <command name="magreserve">
          <description>Returns contents of magazine reserve.</description>
          <references>
            <identifierReference identifier="curweapon"/>
            <identifierReference identifier="currentprimary"/>
            <identifierReference identifier="nextprimary"/>
            <identifierReference identifier="prevweapon"/>
            <identifierReference identifier="weapon"/>
            <identifierReference identifier="magcontent"/>
          </references>
          <arguments>
            <argument token="N" description="the weapon number or name" valueNotes="0 (knife), 1 (pistol), 2 (carbine), 3 (shotgun), 4 (subgun), 5 (sniper), 6 (assault), 7 (grenades), 8 (akimbo)"/>
          </arguments>
        </command>

        <command name="checkmag">
          <description>Determines if you have any ammunition available for the specified weapon. (uses magcontent and magreserve)</description>
          <references>
            <identifierReference identifier="magcontent"/>
            <identifierReference identifier="magreserve"/>
          </references>
          <arguments>
            <argument token="N" description="the weapon number or name" valueNotes="0 (knife), 1 (pistol), 2 (carbine), 3 (shotgun), 4 (subgun), 5 (sniper), 6 (assault), 7 (grenades), 8 (akimbo)"/>
          </arguments>
        </command>

        <command name="getmap">
          <description>Retrieves the last map that was sent to the server using 'sendmap'.</description>
          <remarks>
            <remark>If the command is passed an argument, different than the map being played, the game tries to download the specified map from an available packages source server.</remark>
          </remarks>
          <references>
            <identifierReference identifier="sendmap"/>
            <identifierReference identifier="dlmap"/>
          </references>
          <arguments>
            <argument token="S" description="the name of the map"/>
            <argument token="C" description="cubescript to execute once map is installed" optional="true"/>
          </arguments>
        </command>

        <command name="dlmap">
          <description>Downloads and loads the specified map from an available packages source server.</description>
          <arguments>
            <argument token="S" description="the name of the map"/>
          </arguments>
          <references>
            <identifierReference identifier="getmap"/>
            <identifierReference identifier="sendmap"/>
          </references>
        </command>

        <command name="getmod">
          <description>Try to download mods/modname.zip from all configured package servers.</description>
          <remarks>
            <remark>Does not automatically activate the mod.</remark>
          </remarks>
          <arguments>
            <argument token="N" description="the name of the mod"/>
          </arguments>
          <references>
            <identifierReference identifier="addzipmod"/>
          </references>
        </command>

        <command name="spectatemode">
          <description>Sets the desired spectating mode.</description>
          <arguments>
            <argument token="M" description="the mode" valueNotes="2 (1st-person), 3 (3rd-person), 4 (3rd-person transparent), 5 (free flying)"/>
          </arguments>
          <defaultKeys>
            <key alias="SPACE" description="switch spectator mode"/>
          </defaultKeys>
          <references>
            <identifierReference identifier="spectate"/>
          </references>
        </command>

        <command name="spectate">
          <description>Toggles spectator mode.</description>
          <references>
            <identifierReference identifier="spectatemode"/>
            <identifierReference identifier="spectatepersistent"/>
          </references>
        </command>

        <variable name="spectatepersistent">
          <description>Enables persistent spectating concrete player.</description>
          <remarks>
            <remark>
            For "spectatepersistent" = 1 persistent spectating is enabled in all game modes in multiplayer (that means,
            that spectated player isn't changed after his death), for "0" it is enabled only in non-arena modes.
            </remark>
          </remarks>
          <value token="N" description="0: enabled in non-arena modes, 1: always enabled" minValue="0" maxValue="1" defaultValue="1"/>
          <references>
            <identifierReference identifier="spectate"/>
          </references>
        </variable>

        <command name="stopdemo">
          <description>Stops demo playback.</description>
        </command>

        <command name="watchingdemo">
          <description>Returns 1 when the current game is being played from a demo, else 0.</description>
          <examples>
            <example>
              <code><![CDATA[echo I am (at [not now] (watchingdemo)) watching a demo. "so, are you?"]]></code>
            </example>
          </examples>
          <return token="B" description="truth value"/>
        </command>

        <command name="suicide">
          <description>Kills your player. You will lose 1 frag point and receive 1 death point when using this command.</description>
        </command>

        <command name="demo">
          <description>Plays a recorded demo.</description>
          <remarks>
            <remark>Playback is interpolated for the player whose perspective you view.</remark>
          </remarks>
          <arguments>
            <argument token="S" description="the demo name"/>
          </arguments>
          <references>
            <identifierReference identifier="setmr"/>
            <identifierReference identifier="rewind"/>
            <identifierReference identifier="curdemofile"/>
          </references>
        </command>

        <command name="setmr">
          <description>Go to a predefined number of minutes before the end of the game while watching a demo.</description>
          <arguments>
            <argument token="M" description="the minutes remaining to skip to"/>
          </arguments>
          <references>
            <identifierReference identifier="demo"/>
            <identifierReference identifier="rewind"/>
          </references>
        </command>

        <command name="rewind">
          <description>Rewind the current demo to S seconds ago.</description>
          <remarks>
            <remark>Note: you can use a negative value to forward.</remark>
          </remarks>
          <arguments>
            <argument token="S" description="the number of seconds to rewind"/>
          </arguments>
          <references>
            <identifierReference identifier="demo"/>
            <identifierReference identifier="setmr"/>
          </references>
        </command>

        <variable name="curdemofile">
          <description>Returns the name of played demo.</description>
          <references>
            <identifierReference identifier="demo"/>
          </references>
        </variable>

        <variable name="minutesremaining">
          <description>Returns the remaining minutes of the currently played game. READ ONLY</description>
          <references>
            <identifierReference identifier="gametimecurrent"/>
            <identifierReference identifier="gametimemaximum"/>
            <identifierReference identifier="lastgametimeupdate"/>
            <identifierReference identifier="millis"/>
          </references>
        </variable>

        <variable name="gametimecurrent">
          <description>Returns the time (in milliseconds) of the currently played game. READ ONLY</description>
          <examples>
            <example>
              <code>
                <![CDATA[showtime = [
                if (> $lastgametimeupdate 0) [
                gmr = (- $gametimemaximum (+ $gametimecurrent (- (millis) $lastgametimeupdate)))
                gsr = (div $gmr 1000)
                gts = (mod $gsr 60)
                if (< $gts 10) [ gts = (concatword 0 $gts) ] [ ]
                gtm = (div $gsr 60)
                if (< $gtm 10) [ gtm = (concatword 0 $gtm) ] [ ]
                echo (concatword $gtm : $gts) remaining
                ] [
                echo gametime not updated yet
                ]
                ]]]>
              </code>
            </example>
          </examples>
          <references>
            <identifierReference identifier="minutesremaining"/>
            <identifierReference identifier="gametimemaximum"/>
            <identifierReference identifier="lastgametimeupdate"/>
            <identifierReference identifier="millis"/>
          </references>
        </variable>

        <variable name="gametimemaximum">
          <description>Returns the maximum time (in milliseconds) of the currently played game. READ ONLY</description>
          <references>
            <identifierReference identifier="minutesremaining"/>
            <identifierReference identifier="gametimecurrent"/>
            <identifierReference identifier="lastgametimeupdate"/>
            <identifierReference identifier="millis"/>
          </references>
        </variable>

        <variable name="gametimestart">
          <description>Returns the time (in milliseconds) when the last map was loaded.</description>
          <references>
            <identifierReference identifier="minutesremaining"/>
            <identifierReference identifier="gametimecurrent"/>
            <identifierReference identifier="lastgametimeupdate"/>
            <identifierReference identifier="millis"/>
          </references>
        </variable>

        <variable name="lastgametimeupdate">
          <description>Returns the last time (in milliseconds) the gametime was updated. READ ONLY</description>
          <references>
            <identifierReference identifier="minutesremaining"/>
            <identifierReference identifier="gametimecurrent"/>
            <identifierReference identifier="gametimemaximum"/>
            <identifierReference identifier="millis"/>
          </references>
        </variable>

        <variable name="paused">
          <description>Determines if the singleplayer game should be paused.</description>
          <value token="B" description="pause game" minValue="0" maxValue="1" defaultValue="0"/>
          <defaultKeys>
            <key alias="PAUSE" name="Pause"/>
          </defaultKeys>
        </variable>

        <command name="pause">
          <description>Vote to pause or resume the match.</description>
          <remarks>
            <remark>This command is only supported on servers that are in 'match' mastermode.</remark>
            <remark>You can use the alias 'togglepause' to switch between pause and resume.</remark>
          </remarks>
          <arguments>
            <argument token="P" description="pause or resume" valueNotes="1 (pause) or 0 (resume)"/>
          </arguments>
          <references>
            <identifierReference identifier="mastermode"/>>
          </references>
        </command>

        <variable name="autoreload">
          <description>Indicates if the weapons should be reloaded automatically.</description>
          <value token="B" description="the autoreload state" minValue="0" maxValue="1" defaultValue="1" valueNotes="0: off, 1: on"/>
          <references>
            <identifierReference identifier="reload"/>
          </references>
        </variable>

        <variable name="scopefov">
          <description>Determines the FOV when scoping.</description>
          <references>
            <identifierReference identifier="fov"/>
          </references>
          <value token="V" description="" minValue="5" maxValue="60" defaultValue="50"/>
        </variable>

        <variable name="gamespeed">
          <description>Sets the gamespeed in percent.</description>
          <remarks>
            <remark>This does not work in multiplayer.</remark>
          </remarks>
          <value token="N" description="the game speed" minValue="10" maxValue="1000" defaultValue="100"/>
        </variable>

        <variable name="flyspeed">
          <description>Determines by how much to multiply the fly speeds by.</description>
          <value token="N" description="the multiplier" minValue="1.0" maxValue="5.0" defaultValue="2.0"/>
        </variable>

        <variable name="akimboendaction">
          <description>Sets the behavior of weapon switching upon akimbo expiration.</description>
          <value token="N" description="akimbo end action" minValue="0" maxValue="3" defaultValue="3"/>
          <arguments>
            <argument valueNotes="0 (switch to knife)"/>
            <argument valueNotes="1 (stay with pistol)"/>
            <argument valueNotes="2 (switch to grenades)"/>
            <argument valueNotes="3 (switch to primary)"/>
          </arguments>
          <remarks>
            <remark>If no ammunition is detected for the target weapon, it will fallback to the previous weapon until it finds a weapon with ammunition to use.</remark>
          </remarks>
        </variable>

        <command name="drawzone">
          <description>Draws a zone marker with the specified color and dimensions on the minimap/radar.</description>
          <remarks>
            <remark>This is primarily intended for the survival mode.</remark>
            <remark>You can draw a few zones at a time. They will be reset (i.e. removed) once a new game starts.</remark>
            <remark>Note that the coordinates must be specified as integers, not as floating-point values.</remark>
          </remarks>
          <arguments>
            <argument token="X1" description="X-coordinate - top-left corner"/>
            <argument token="X2" description="X-coordinate - bottom-right corner"/>
            <argument token="Y1" description="Y-coordinate - top-left corner"/>
            <argument token="Y2" description="Y-coordinate - bottom-right corner"/>
            <argument token="C" description="a color for the zone, in hexadecimal notation" valueNotes="default: 0x00FF00 (green)"/>
          </arguments>
          <references>
            <identifierReference identifier="resetzones"/>
            <identifierReference identifier="survival"/>
          </references>
        </command>

        <command name="resetzones">
          <description>Reset all drawn zones.</description>
          <references>
            <identifierReference identifier="drawzone"/>
            <identifierReference identifier="survival"/>
          </references>
        </command>

        <scriptalias name="onLastMin">
          <description>If this alias exists, it will be automatically executed on the last minute remaining mark.</description>
        </scriptalias>

        <command name="curplayers">
          <description>Returns the size of the players vector.</description>
          <remarks>
            <remark>
              The return value includes the local player "(you)" and works in both singleplayer and multiplayer scenarios.
              It can be used, for example, in a loop to find all valid clients (players) on server.
              Note: it DOESN'T return current number of players.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="isclient"/>
          </references>
        </command>

        <command name="isclient">
          <description>Determines if the client number given is a valid client (player).</description>
          <examples>
            <example>
              <code><![CDATA[echo (isclient 0)]]></code>
              <explanation>Example output: 1</explanation>
            </example>
            <example>
              <code><![CDATA[echo (isclient 32)]]></code>
              <explanation>Example output: 0</explanation>
            </example>
          </examples>
          <arguments>
            <argument token="C" description="client number"/>
          </arguments>
          <references>
            <identifierReference identifier="curplayers"/>
          </references>
        </command>

        <command name="findcn">
          <description>Finds client number (cn) of player with given name.</description>
          <arguments>
            <argument token="N" description="player name"/>
          </arguments>
        </command>

        <command name="highestcn">
          <description>Returns the highest valid client number available.</description>
        </command>

        <command name="quicknadethrow">
          <description>Switches to grenades, if available (must be bound to a key).</description>
          <remarks>
            <remark>If grenades are already selected or the key is held, it throws a grenade and switches back to previous weapon.</remark>
          </remarks>
          <defaultKeys>
            <key alias="G" description="for all weapons"/>
            <key alias="MOUSE2" name="right mouse button" description="for all weapons except sniper rifle"/>
          </defaultKeys>
          <references>
            <identifierReference identifier="grenades"/>
          </references>
        </command>

        <command name="forward">
          <description>Moves the player forward.</description>
          <defaultKeys>
            <key alias="W|UP" name="W or Up Arrow"/>
          </defaultKeys>
        </command>

        <command name="backward">
          <description>Moves the player backward.</description>
          <defaultKeys>
            <key alias="S|DOWN" name="S or Down Arrow"/>
          </defaultKeys>
        </command>

        <command name="left">
          <description>Moves the player left.</description>
          <defaultKeys>
            <key alias="A|LEFT" name="A or Left Arrow"/>
          </defaultKeys>
        </command>

        <command name="right">
          <description>Moves the player right.</description>
          <defaultKeys>
            <key alias="D|RIGHT" name="D or Right Arrow"/>
          </defaultKeys>
        </command>

        <command name="attack">
          <description>Fires the current weapon.</description>
          <defaultKeys>
            <key alias="MOUSE1" name="left mouse button"/>
          </defaultKeys>
        </command>

        <command name="whereami">
          <description>Prints the local client's (x,y) coordinates.</description>
        </command>

        <command name="burstshots">
          <description>Sets the firing mode of automatic weapons between full auto mode and burst fire mode.</description>
          <arguments>
            <argument token="N" description="the weapon number or name" valueNotes="4 (subgun), 6 (assault), 8 (akimbo)"/>
            <argument token="S" description="shots per burst" valueNotes="Special values: 0: set weapon to full auto, -1: don't set, instead check and return shots per burst"/>
          </arguments>
        </command>

        <command name="winners">
          <description>Returns the team number with the highest score, or if in a non-team mode, returns the CN of the player with the highest score.</description>
        </command>

        <command name="fragmessage">
          <description>Sets the frag message corresponding to a weapon (appearing on the hud).</description>
          <arguments>
            <argument token="N" description="the weapon number or name" valueNotes="0 (knife), 1 (pistol), 2 (carbine), 3 (shotgun), 4 (subgun), 5 (sniper), 6 (assault), 7 (grenades), 8 (akimbo)"/>
            <argument token="M" description="the message you want to appear" valueNotes="example: sniped"/>
          </arguments>
          <examples>
            <example>
              <code>fragmessage sniper sniped</code>
              <explanation>It will display "you sniped unarmed" on the hud when you frag unarmed with sniper.</explanation>
            </example>
          </examples>
          <references>
            <identifierReference identifier="gibmessage"/>
            <identifierReference identifier="weapon"/>
          </references>
        </command>

        <command name="gibmessage">
          <description>Sets the gib message corresponding to a weapon (appearing on the hud).</description>
          <arguments>
            <argument token="N" description="the weapon number or name" valueNotes="0 (knife), 1 (pistol), 2 (carbine), 3 (shotgun), 4 (subgun), 5 (sniper), 6 (assault), 7 (grenades), 8 (akimbo)"/>
            <argument token="M" description="the message you want to appear" valueNotes="example: slashed"/>
          </arguments>
          <remarks>
            <remark>
              This command is identical to fragmessage, please see it.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="fragmessage"/>
            <identifierReference identifier="weapon"/>
          </references>
        </command>

        <command name="player">
          <description>Retrieve an attribute of a player identified by clientnum.</description>
          <arguments>
            <argument token="C" description="clientnum" valueNotes="1,2,3,.."/>
            <argument token="A" description="attribute" valueNotes="magcontent, ammo, primary, .."/>
          </arguments>
          <remarks>
            <remark>If the clientnum does not match a valid player the result will be empty, just as without an attribute passed.</remark>
            <remark>The following attributes can be retrieved: magcontent, ammo, primary, curweapon, nextprimary, health, armour, attacking, scoping, x, y, z, name, team, ping, pj, state, role, frags, flags, deaths, tks, alive, spect, cn, skin_cla, skin_rvsf, skin, ip</remark>
          </remarks>
          <references>
            <identifierReference identifier="player1"/>
          </references>
        </command>

        <command name="player1">
          <description>Retrieve an attribute of yourself.</description>
          <arguments>
            <argument token="A" description="attribute" valueNotes="magcontent, ammo, primary, .."/>
          </arguments>
          <remarks>
            <remark>See player for all retrievable attributes.</remark>
          </remarks>
          <references>
            <identifierReference identifier="player"/>
          </references>
        </command>

      </identifiers>
    </section>
    <!-- Gameplay Section Ends -->
    <!-- Keyboard and mouse Section Starts -->
    <section name="Keyboard and mouse" sortindex="04">
      <description>This section describes keyboard and mouse related identifiers.</description>
      <identifiers sort="true">

        <command name="bind">
          <description>Binds a key to a command.</description>
          <remarks>
            <remark>
              To find out what key names and their default bindings are, look at config/keymap.cfg,
              then add bind commands to your autoexec.cfg.
            </remark>
          </remarks>
          <arguments>
            <argument token="K" description="the key to bind" valueNotes="string"/>
            <argument token="A" description="the command" valueNotes="string, usually an alias"/>
          </arguments>
          <references>
            <identifierReference identifier="editbind"/>
            <identifierReference identifier="specbind"/>
            <identifierReference identifier="megabind"/>
            <identifierReference identifier="onrelease"/>
          </references>
        </command>

        <command name="editbind">
          <description>Similar to bind, but is only active while editing, where it overrides the regular bind for the specified key.</description>
          <arguments>
            <argument token="K" description="the key to bind" valueNotes="string"/>
            <argument token="A" description="the command" valueNotes="string, usually an alias"/>
          </arguments>
          <references>
            <identifierReference identifier="bind"/>
            <identifierReference identifier="specbind"/>
          </references>
        </command>

        <command name="specbind">
          <description>Similar to bind, but is only active while spectating, where it overrides the regular bind for the specified key.</description>
          <arguments>
            <argument token="K" description="the key to bind" valueNotes="string"/>
            <argument token="A" description="the command" valueNotes="string, usually an alias"/>
          </arguments>
          <references>
            <identifierReference identifier="bind"/>
            <identifierReference identifier="editbind"/>
          </references>
        </command>

        <command name="megabind">
          <description>Binds a key to many different actions depending on the current game state.</description>
          <examples>
            <example>
              <code><![CDATA[megabind F9 [echo Demo!] [echo Editing or coop!] [echo Connected!] [echo Bots!] [echo Other!]]]></code>
            </example>
          </examples>
          <arguments>
            <argument token="K" description="the key to bind" valueNotes="string"/>
            <argument token="D" description="body of code to execute if watching a demo" valueNotes="a body of code"/>
            <argument token="E" description="body of code to execute if editing or in coop-edit mode" valueNotes="a body of code"/>
            <argument token="C" description="body of code to execute if connected to a server" valueNotes="a body of code"/>
            <argument token="B" description="body of code to execute if in a bot mode" valueNotes="a body of code"/>
            <argument token="O" description="body of code to execute if none of the other arguments have been met" valueNotes="a body of code"/>
          </arguments>
          <remarks>
            <remark>This command requires 6 arguments, no less. Use an empty set of brackets [] for any of the arguments that you want to "do nothing".</remark>
          </remarks>
          <references>
            <identifierReference identifier="bind"/>
            <identifierReference identifier="onrelease"/>
          </references>
        </command>

        <command name="onrelease">
          <description>Executes a command on the release of a key/button.</description>
          <remarks>
            <remark>This command must be placed in an action in a bind or in an alias in a bind.</remark>
          </remarks>
          <examples>
            <example>
              <code><![CDATA[bind CTRL [ echo "key pressed"; onrelease [ echo "key released" ] ]]]></code>
            </example>
          </examples>
          <references>
            <identifierReference identifier="bind"/>
            <identifierReference identifier="megabind"/>
          </references>
          <arguments>
            <argument token="A" description="the command"/>
          </arguments>
        </command>

        <scriptalias name="add2bind">
          <description>Adds a block of code, if it does not already exist, to a keybind.</description>
          <arguments>
            <argument token="K" description="the key to add to"/>
            <argument token="C" description="the code to add"/>
          </arguments>
          <references>
            <identifierReference identifier="add2alias"/>
            <identifierReference identifier="add2list"/>
          </references>
        </scriptalias>

        <command name="keybind">
          <description>Returns the contents of a keybind, bound with 'bind'.</description>
          <arguments>
            <argument token="K" description="name of key"/>
          </arguments>
          <references>
            <identifierReference identifier="bind"/>
            <identifierReference identifier="findkey"/>
            <identifierReference identifier="findkeycode"/>
            <identifierReference identifier="keyeditbind"/>
            <identifierReference identifier="keyspecbind"/>
          </references>
        </command>

        <command name="keyeditbind">
          <description>Returns the contents of a keybind, bound with 'editbind'.</description>
          <arguments>
            <argument token="K" description="name of key"/>
          </arguments>
          <references>
            <identifierReference identifier="editbind"/>
            <identifierReference identifier="keybind"/>
            <identifierReference identifier="keyspecbind"/>
          </references>
        </command>

        <command name="keyspecbind">
          <description>Returns the contents of a keybind, bound with 'specbind'.</description>
          <arguments>
            <argument token="K" description="name of key"/>
          </arguments>
          <references>
            <identifierReference identifier="keybind"/>
            <identifierReference identifier="keyeditbind"/>
            <identifierReference identifier="specbind"/>
          </references>
        </command>

        <command name="searchbinds">
          <description>Searches keybinds (bound with 'bind'), returns keys with matching contents.</description>
          <arguments>
            <argument token="S" description="search string"/>
          </arguments>
          <examples>
            <example>
              <code><![CDATA[echo (searchbinds "reload")]]></code>
              <explanation>Output: R</explanation>
            </example>
          </examples>
          <remarks>
            <remark>This is the inverse of 'keybind'</remark>
          </remarks>
          <references>
            <identifierReference identifier="bind"/>
            <identifierReference identifier="keybind"/>
          </references>
        </command>

        <command name="searcheditbinds">
          <description>Searches keybinds (bound with 'editbind'), returns keys with matching contents.</description>
          <arguments>
            <argument token="s" description="search string"/>
          </arguments>
          <examples>
            <example>
              <code><![CDATA[echo (searcheditbinds "toggleocull")]]></code>
              <explanation>Output: F5</explanation>
            </example>
          </examples>
          <remarks>
            <remark>This is the inverse of 'keyeditbind'</remark>
          </remarks>
          <references>
            <identifierReference identifier="editbind"/>
            <identifierReference identifier="keyeditbind"/>
          </references>
        </command>

        <command name="searchspecbinds">
          <description>Searches keybinds (bound with 'specbind'), returns keys with matching contents.</description>
          <arguments>
            <argument token="s" description="search string"/>
          </arguments>
          <remarks>
            <remark>This is the inverse of 'keyspecbind'</remark>
          </remarks>
          <references>
            <identifierReference identifier="specbind"/>
            <identifierReference identifier="keyspecbind"/>
          </references>
        </command>

        <command name="findkey">
          <description>Returns the name of a key via a specified code.</description>
          <examples>
            <example>
              <code><![CDATA[echo (findkey 8)]]></code>
              <explanation>Output: BACKSPACE</explanation>
            </example>
            <example>
              <code><![CDATA[echo (findkey 280)]]></code>
              <explanation>Output: PAGEUP</explanation>
            </example>
          </examples>
          <arguments>
            <argument token="I" description="integer"/>
          </arguments>
          <remarks>
            <remark>Returns -255 if the key does not exist.</remark>
            <remark>See /config/keymap.cfg for a full list of valid key codes.</remark>
          </remarks>
          <references>
            <identifierReference identifier="keybind"/>
            <identifierReference identifier="findkeycode"/>
          </references>
        </command>

        <command name="findkeycode">
          <description>Returns the integer code of a key.</description>
          <examples>
            <example>
              <code><![CDATA[echo (findkeycode BACKSPACE)]]></code>
              <explanation>Output: 8</explanation>
            </example>
            <example>
              <code><![CDATA[echo (findkeycode PAGEUP)]]></code>
              <explanation>Output: 280</explanation>
            </example>
          </examples>
          <arguments>
            <argument token="K" description="the name of the key"/>
          </arguments>
          <remarks>
            <remark>Returns -255 if the key does not exist.</remark>
            <remark>See /config/keymap.cfg for a full list of valid key names.</remark>
          </remarks>
          <references>
            <identifierReference identifier="keybind"/>
            <identifierReference identifier="findkey"/>
          </references>
        </command>

        <variable name="resetbinds">
          <description>Resets all binds back to their default values.</description>
          <remarks>
            <remark>
              This command executes the file /config/resetbinds.cfg which will bind all keys to the values specified in that
              file, thus resetting the binds to their default values.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="resetcfg"/>
            <identifierReference identifier="_resetallbinds"/>
          </references>
        </variable>

        <command name="_resetallbinds">
          <description>Clears all binds for all keys and all modes, including self-assigned ones.</description>
          <remarks>
            <remark>Do not use the command manually.</remark>
          </remarks>
          <references>
            <identifierReference identifier="resetbinds"/>
            <identifierReference identifier="_defaultbinds"/>
          </references>
        </command>

        <variable name="_defaultbinds">
          <description>Whether or not the next call to _resetallbinds will remove any and all binds; cleaning up before setting the default bindings.</description>
          <value token="B" description="boolean" minValue="0" maxValue="1" valueNotes="1:yes" defaultValue="0"/>
          <remarks>
            <remark>Internal – used in config/resetbinds.cfg</remark>
          </remarks>
          <references>
            <identifierReference identifier="_resetallbinds"/>
          </references>
        </variable>

        <command name="keymap">
          <description>Sets up the keymap for the specified key.</description>
          <remarks>
            <remark>You should never have to use this command manually, use "bind" instead.</remark>
          </remarks>
          <references>
            <identifierReference identifier="bind"/>
          </references>
          <arguments>
            <argument token="K" description="the key to map"/>
            <argument token="N" description="the name for the key"/>
            <argument token="A" description="the default action"/>
          </arguments>
        </command>

        <scriptalias name="KEYPRESS">
          <description>If defined, this will be executed every time you press a key.</description>
          <arguments>
            <argument token="I" description="integer key code"/>
          </arguments>
          <examples>
            <example>
              <code><![CDATA[checkinit KEYPRESS [echo You pressed key: (findkey $arg1)]]]></code>
            </example>
          </examples>
          <references>
            <identifierReference identifier="KEYRELEASE"/>
            <identifierReference identifier="findkey"/>
          </references>
        </scriptalias>

        <scriptalias name="KEYRELEASE">
          <description>If defined, this will be executed every time you release a key.</description>
          <arguments>
            <argument token="I" description="integer key code"/>
          </arguments>
          <examples>
            <example>
              <code><![CDATA[checkinit KEYRELEASE [echo You released key: (findkey $arg1)]]]></code>
            </example>
          </examples>
          <references>
            <identifierReference identifier="KEYPRESS"/>
            <identifierReference identifier="findkey"/>
          </references>
        </scriptalias>

        <variable name="sensitivity">
          <description>Sets the mouse sensitivity.</description>
          <value token="S" description="the sensitivity" minValue="0.001" maxValue="1000" valueNotes="floating-point" defaultValue="3.0"/>
          <references>
            <identifierReference identifier="sensitivityscale"/>
            <identifierReference identifier="scopesens"/>
            <identifierReference identifier="autoscopesens"/>
            <identifierReference identifier="scopesensscale"/>
          </references>
        </variable>

        <variable name="sensitivityscale">
          <description>Scales all mouse sensitivity values.</description>
          <remarks>
            <remark>Changes all sensitivity values. If unsure, keep this at "1".</remark>
          </remarks>
          <value token="N" description="the sensitivity scale" minValue="0.001" maxValue="1000.0" defaultValue="1.0"/>
          <references>
            <identifierReference identifier="sensitivity"/>
            <identifierReference identifier="scopesens"/>
            <identifierReference identifier="autoscopesens"/>
            <identifierReference identifier="scopesensscale"/>
          </references>
        </variable>

        <variable name="scopesens">
          <description>Mouse sensitivity while scoped.</description>
          <remarks>
            <remark>If zero, autoscopesens determines, how sensitivity is changed during scoping.</remark>
          </remarks>
          <value token="N" description="scoped sensitivity" minValue="0" maxValue="1000" defaultValue="0"/>
          <references>
            <identifierReference identifier="sensitivity"/>
            <identifierReference identifier="sensitivityscale"/>
            <identifierReference identifier="autoscopesens"/>
            <identifierReference identifier="scopesensscale"/>
          </references>
        </variable>

        <variable name="autoscopesens">
          <description>Switches between scopesensscale and autoscopesensscale.</description>
          <remarks>
            <remark>Determines how to calculate scoped sensitivity if scopesens is zero. If enabled, derives scoped sensitivity from scopefov and fov.</remark>
          </remarks>
          <value token="N" description="auto on/off" minValue="0 (scopesensscale)" maxValue="1 (autoscopesens)" defaultValue="0"/>
          <references>
            <identifierReference identifier="sensitivity"/>
            <identifierReference identifier="sensitivityscale"/>
            <identifierReference identifier="scopesens"/>
            <identifierReference identifier="scopesensscale"/>
          </references>
        </variable>

        <variable name="scopesensscale">
          <description>Change sensitivity when scoping.</description>
          <remarks>
            <remark>If used, scoped sens = sensitivity * scopesensscale (roughly). Ignored, if autoscopesens is set.</remark>
          </remarks>
          <value token="N" description="factor to change sensitivity while scoped" minValue="0.001" maxValue="1000.0" defaultValue="0.5"/>
          <references>
            <identifierReference identifier="sensitivity"/>
            <identifierReference identifier="sensitivityscale"/>
            <identifierReference identifier="scopesens"/>
            <identifierReference identifier="autoscopesens"/>
          </references>
        </variable>

        <variable name="invmouse">
          <description>Sets mouse to "flight sim" mode.</description>
          <value token="B" description="sets invmouse" minValue="0" maxValue="1" valueNotes="1:inverted Y-axis" defaultValue="0"/>
          <remarks>
            <remark>Inverts movement on the y-axis.</remark>
          </remarks>
        </variable>

        <variable name="relativemouse">
          <description>The way the mouse movement is handled.</description>
          <value token="B" description="boolean" minValue="0" maxValue="1" valueNotes="0:warped, 1:relative" defaultValue="1"/>
          <remarks>
            <remark>On Windows this is forced to 1 due to erratic behaviour of SDL_WarpMouseInWindow.</remark>
            <remark>If set to 0 the mouse will be warped to center of the screen if appropriate.</remark>
          </remarks>
          <references>
            <identifierReference identifier="sdl_xgrab_bug"/>
          </references>
        </variable>

        <variable name="sdl_xgrab_bug">
          <description>Enable a workaround for buggy SDL X11 pointer grabbing.</description>
          <value token="B" description="boolean" minValue="0" maxValue="1" valueNotes="1:use workaround" defaultValue="0"/>
          <remarks>
            <remark>On Windows this is variable is not available. X11 is a *nix windowing system.</remark>
            <remark>If set to 1 and relativemouse is on too, the workaround using XGrabPointer will be used.</remark>
          </remarks>
          <references>
            <identifierReference identifier="relativemouse"/>
          </references>
        </variable>

        <variable name="mfilter">
          <description>Sets the degree of mouse filtering (0.0 being no filtering).</description>
          <value token="N" description="Amount of mouse filtration" minValue="0.0" maxValue="6.0" defaultValue="0.0"/>
        </variable>

        <variable name="mouseaccel">
          <description>Sets the mouse acceleration.</description>
          <value token="N" description="acceleration factor" minValue="0.0" maxValue="1000.0" defaultValue="0.0"/>
          <references>
            <identifierReference identifier="sensitivity"/>
          </references>
        </variable>

        <command name="togglegrab">
          <description>Toggles grabbing of mouse and keyboard input in a game.</description>
          <remarks>
            <remark>
            Grabbing means that the mouse is confined to the AC, and nearly all keyboard input is passed directly to AC,
            and not interpreted by a window manager, if any. This is only useful when you run AC windowed.
            </remark>
          </remarks>
        </command>

        <variable name="modkeypressed">
          <description>Indicates if a CTRL key is pressed.</description>
          <value description="state of the CTRL key" minValue="0" maxValue="1" defaultValue="0" readOnly="true" valueNotes="0: unpressed, 1: pressed"/>
        </variable>

        <command name="modkeypressed">
          <description>Is the CTRL currently key pressed?</description>
          <remarks>
            <remark>Can be used to change the behaviour of keybinds, like the F12 keybind in spectator mode uses it.</remark>
          </remarks>
          <references>
            <identifierReference identifier="screenshot"/>
          </references>
        </command>

      </identifiers>
    </section>
    <!-- Keyboard and mouse Section Ends -->
    <!-- Editing Section Starts -->
    <section name="Editing" sortindex="11">
      <identifiers sort="true">

        <command name="getentattr">
          <description>Returns the value of the selected attribute of the nearest entity.</description>
          <remarks>
            <remark>
            It returns float values for some attributes.
            If "unscaled" flag is "1", raw integer values (representing the highest resolution) are returned.
            </remark>
          </remarks>
          <arguments>
            <argument token="A" description="attribute index" valueNotes="0..6"/>
            <argument token="U" description="unscaled flag" valueNotes="0 or 1" optional="true"/>
          </arguments>
          <references>
            <identifierReference identifier="entproperty"/>
            <identifierReference identifier="getenttype"/>
          </references>
        </command>

        <command name="getenttype">
          <description>Returns the entity type of the nearest entity.</description>
          <references>
            <identifierReference identifier="entproperty"/>
            <identifierReference identifier="getentattr"/>
          </references>
        </command>

        <command name="edittag">
          <arguments>
            <argument token="T" description="tag" valueNotes="integer value"/>
          </arguments>
        </command>

        <command name="edittagclip">
          <description>Sets tag clip type of all selected cubes.</description>
          <remarks>
            <remark>Type can be numeric or a keyword.</remark>
          </remarks>
          <arguments>
            <argument token="T" description="type" valueNotes="0 (none), 64 (clip), 128 (plclip)"/>
          </arguments>
          <defaultKeys>
            <key alias="KP1" name="1 on the keypad" description="sets a tag clip: none"/>
            <key alias="KP2" name="2 on the keypad" description="sets a tag clip: clip"/>
            <key alias="KP3" name="3 on the keypad" description="sets a tag clip: plclip"/>
          </defaultKeys>
          <references>
            <identifierReference identifier="transformclipentities"/>
          </references>
        </command>

        <command name="transformclipentities">
          <description>Transforms all full height clip entities to tag clips.</description>
          <references>
            <identifierReference identifier="edittagclip"/>
          </references>
        </command>

        <command name="applymapsoundchanges">
          <description>During map editing, drop all mapsounds so they can be re-added.</description>
        </command>

        <command name="edittoggle">
          <description>Switches between map edit mode and normal.</description>
          <remarks>
            <remark>
            In map edit mode you can select bits of the map by clicking or dragging your crosshair on the floor
            or ceiling (using the "attack" identifier, normally MOUSE1), then use the identifiers below to
            modify the selection. While in edit mode, normal physics and collision don't apply (clips), and key repeat is ON.
            Note that if you fly outside the map, cube still renders the world as if you were standing on the floor
            directly below the camera.
            </remark>
          </remarks>
          <defaultKeys>
            <key alias="E"/>
          </defaultKeys>
          <references>
            <identifierReference name="select" identifier="select"/>
            <wikiReference article="Coopedit"/>
          </references>
        </command>

        <command name="edittex">
          <description>Changes the texture on current selection by browsing through a list of textures directly shown on the cubes.</description>
          <remarks>
            <remark>
            Default keys are the six keys above the cursor keys, which each 2 of them cycle one type (and numpad 7/4 for upper-wall).
            </remark>
            <remark>
            The way this works is slightly strange at first, but allows for very fast texture assignment.
            All textures are in 3 individual lists for each type (both wall kinds treated the same),
            and each time a texture is used, it is moved to the top of the list. So after a bit of editing,
            all your most frequently used textures will come first when pressing these keys,
            and the most recently used texture is set immediately when you press the forward key for the type.
            These lists are saved with the map. Make a selection (including wall bits) and press these keys to get a feel for what they do.
            </remark>
          </remarks>
          <arguments>
            <argument token="T" description="an integer denoting the type" valueNotes="0 (floor), 1 (lower or wall), 2 (ceiling), 3 (upper wall)"/>
            <argument token="D" description="the direction you want to cycle the textures in" valueNotes="1 (forwards), -1 (backwards)"/>
          </arguments>
          <defaultKeys>
            <key alias="INSERT" name="Insert" description="browses forward through floor textures"/>
            <key alias="DELETE" name="Delete" description="browses backward through floor textures"/>
            <key alias="HOME" name="Home" description="browses forward through wall textures"/>
            <key alias="END" name="End" description="browses backward through wall textures"/>
            <key alias="PAGEUP" name="Page Up" description="browses forward through ceiling textures"/>
            <key alias="PAGEDOWN" name="Page Down" description="browses backward through ceiling textures"/>
            <key alias="KP4" name="7 on the keypad" description="browses forward through upper-wall textures"/>
            <key alias="KP7" name="4 on the keypad" description="browses backward through upper-wall textures"/>
            <key alias="X+MOUSE4|MOUSE5" name="X + mouse scroll" description="scrolls wall and upper-wall textures"/>
            <key alias="Z+MOUSE4|MOUSE5" name="Z + mouse scroll" description="scrolls floor or ceiling textures"/>
          </defaultKeys>
          <references>
            <identifierReference identifier="hudtexttl"/>
          </references>
        </command>

        <variable name="hudtexttl">
          <description>Show preview of textures during editing.</description>
          <remarks>
            <remark>
            When textures of the map geometry are changed, five textures around the current pick from the "last used" stack are shown.
            </remark>
            <remark>The texture assigned to the "sky" slot is not shown. Instead, a plain blue rectangle is used.</remark>
          </remarks>
          <value token="T" description="time to show texture preview [ms]" minValue="0" maxValue="10000" defaultValue="2500"/>
          <references>
            <identifierReference identifier="edittex"/>
          </references>
        </variable>

        <command name="settex">
          <description>Sets a texture for the current selection.</description>
          <arguments>
            <argument token="T" description="position of the texture to set in map cfg" valueNotes="integer"/>
            <argument token="t" description="the type of the texture" valueNotes="0 (floor), 1 (wall), 2 (ceil), 3 (upper wall)"/>
          </arguments>
        </command>

        <command name="editheight">
          <description>Changes the height of the current selection.</description>
          <arguments>
            <argument token="T" description="an integer denoting the type" valueNotes="0 (floor), 2 (ceiling)"/>
            <argument token="D" description="the delta value to move it in" valueNotes="1 (forwards), -1 (backwards)"/>
          </arguments>
          <defaultKeys>
            <key alias="LEFTBRACKET" name="[" description="moves downwards the selection in the floor"/>
            <key alias="RIGHTBRACKET" name="]" description="moves upwards the selection in the floor"/>
            <key alias="O" description="moves downwards the selection in the ceiling"/>
            <key alias="P" description="moves upwards the selection in the ceiling"/>
          </defaultKeys>
        </command>

        <command name="solid">
          <description>Makes the current selection all solid (i.e. wall) or all non-solid.</description>
          <remarks>
            <remark>
            This operation retains floor/ceiling heights/textures while swapping between the two.
            </remark>
          </remarks>
          <arguments>
            <argument token="B" description="an integer denoting the solid-ness" valueNotes="0 (non-solid), 1..* (solid)"/>
          </arguments>
          <defaultKeys>
            <key alias="F" description="makes the selection a solid"/>
            <key alias="G" description="makes the selection a space/non-heightfield"/>
          </defaultKeys>
        </command>

        <command name="equalize">
          <description>Levels the floor/ceiling of the selection.</description>
          <arguments>
            <argument token="T" description="an integer denoting the type" valueNotes="0 (floor), 2 (ceiling)"/>
          </arguments>
          <defaultKeys>
            <key alias="COMMA" name="," description="equalizes the selection on the floor"/>
            <key alias="PERIOD" name="." description="equalizes the selection on the ceiling"/>
          </defaultKeys>
        </command>

        <command name="heightfield">
          <description>Marks the current selection as a heightfield.</description>
          <remarks>
            <remark>
            It marks the current selection as a heightfield, with T being floor or ceiling, as above.
            A surface marked as heightfield will use the vdelta values (see below) of its 4 corners to create a sloped surface.
            To mark a heightfield as normal again (ignoring vdelta values, set or not) use "solid 0".
            </remark>
            <remark>
            Heightfields should be made the exact size that is needed, not more not less.
            The most important reason for this is that cube automatically generates "caps" (side-faces for heightfields)
            only on the borders of the heightfield. This also means if you have 2 independent heightfields accidentally
            touch each other, you will not get correct caps. Also, a heightfield is slightly slower to render than a
            non-heightfield floor or ceiling. Last but not least, a heightfield should have all the same baseheight
            (i.e. the height determined by a normal editheight operation) to get correct results.
            </remark>
          </remarks>
          <arguments>
            <argument token="T" description="an integer denoting the type" valueNotes="0 (floor), 2 (ceiling)"/>
          </arguments>
          <defaultKeys>
            <key alias="H" description="makes the selection on the floor a heightfield"/>
            <key alias="I" description="makes the selection on the ceiling a heightfield"/>
          </defaultKeys>
          <references>
            <identifierReference identifier="vdelta"/>
          </references>
        </command>

        <command name="vdelta">
          <description>Changes the vdelta value of the current selection.</description>
          <remarks>
            <remark>
            Note that unlike all other editing functions, this function doesn't affect a cube, but its top-left vertex
            (market by the dot in the editing cursor). So to edit a N * M heightfield, you will likely have to edit
            the vdelta of (N+1) * (M+1) cubes, i.e. you have to select 1 row and 1 column more in the opposite direction
            of the red dot to affect all the vertices of a heightfield of a given size (try it, it makes sense :).
            </remark>
            <remark>
            A floor delta offsets vertices to beneath the level set by editheight (and a ceil delta to above).
            Delta offsets have a precision of a quarter of a unit, however you should use non-unitsize vertices only to touch
            other such vertices.
            </remark>
            <remark>This only works if the cube is a heightfield.</remark>
          </remarks>
          <arguments>
            <argument token="N" description="vdelta value"/>
          </arguments>
          <defaultKeys>
            <key alias="8" description="manipulates downwards the corner of the current selection"/>
            <key alias="9" description="manipulates upwards the corner of the current selection"/>
          </defaultKeys>
          <references>
            <identifierReference identifier="heightfield"/>
          </references>
        </command>

        <command name="corner">
          <description>Makes the current selection into a "corner".</description>
          <remarks>
            <remark>
            Currently there is only one type of corner (a 45 degree one), only works on a single unit (cube) at a time.
            It can be positioned either next to 2 solid walls or
            in the middle of 2 higher floorlevels and 2 lower ones forming a diagonal (and similar with ceiling).
            </remark>
            <remark>
            In both cases, the corner will orient itself automatically depending on its neighbours, behaviour with other
            configurations than the 2 above is unspecified. Since the latter configuration generates possibly 2 floor and
            2 ceiling levels, up to 4 textures are used: for example for the 2 floors the higher one will of the cube
            itself, and the lower one of a neighbouring low cube. You can make bigger corners at once by
            issuing "corner" on grid aligned 2x2/4x4/8x8 selections, with equal size solid blocks next to them.
            </remark>
          </remarks>
          <defaultKeys>
            <key alias="K"/>
          </defaultKeys>
        </command>

        <command name="undo">
          <description>Multi-level undo of any of the changes caused by editing operations.</description>
          <remarks>
            <remark>With editmeta pressed it also restores player position and selects the affected area.</remark>
          </remarks>
          <defaultKeys>
            <key alias="U"/>
          </defaultKeys>
          <references>
            <identifierReference identifier="redo"/>
            <identifierReference identifier="undolevel"/>
            <identifierReference identifier="undomegs"/>
            <identifierReference identifier="editmeta"/>
          </references>
        </command>

        <command name="redo">
          <description>Redoes editing operations undone by 'undo'.</description>
          <remarks>
            <remark>With editmeta pressed it also restores player position and selects the affected area.</remark>
          </remarks>
          <defaultKeys>
            <key alias="R"/>
          </defaultKeys>
          <references>
            <identifierReference identifier="undo"/>
            <identifierReference identifier="editmeta"/>
          </references>
        </command>

        <command name="undolevel">
          <description>Returns the number of undo steps that can be undone.</description>
          <remarks>
            <remark>If argument "level" is given, as many steps are undone, until "level" steps remain.</remark>
            <remark>Unless memory limits delete states, undolevel commands can be undone with "redo".</remark>
          </remarks>
          <examples>
            <example>
              <code><![CDATA[echo (undolevel)]]></code>
              <explanation> - prints number of previous editing steps, for example "55". Do some editing and:</explanation>
            </example>
            <example>
              <code><![CDATA[undolevel 55]]></code>
              <explanation>
              - undoes all changes to restore the previous state (if that state is still in memory)
              </explanation>
            </example>
          </examples>
          <arguments>
            <argument token="L" description="level" valueNotes="integer"/>
          </arguments>
          <references>
            <identifierReference identifier="undo"/>
            <identifierReference identifier="redo"/>
            <identifierReference identifier="undomegs"/>
          </references>
        </command>

        <variable name="undomegs">
          <description>Sets the number of megabytes used for the undo buffer.</description>
          <remarks>
            <remark>
            Undo's work for any size areas, so the amount of undo steps per megabyte is more for small areas
            than for big ones (a megabyte fits 280 undo steps on a 16x16 area, but only 4 steps on a 128x128 area).
            </remark>
          </remarks>
          <value token="N" description="number of megabytes" valueNotes="integer" minValue="0" maxValue="50" defaultValue="5"/>
          <references>
            <identifierReference identifier="undo"/>
            <identifierReference identifier="undolevel"/>
          </references>
        </variable>

        <command name="copy">
          <description>Copies the current selection into a buffer.</description>
          <defaultKeys>
            <key alias="C"/>
          </defaultKeys>
          <references>
            <identifierReference identifier="paste"/>
            <identifierReference identifier="copyent"/>
          </references>
        </command>

        <command name="copyent">
          <description>Copies the current closest entity into a buffer.</description>
          <remarks>
            <remark>It also works with the menu list of copied entities. It works only while in edit mode.</remark>
          </remarks>
          <defaultKeys>
            <key alias="MINUS" name="- (minus)"/>
          </defaultKeys>
          <references>
            <identifierReference identifier="pasteent"/>
            <identifierReference identifier="copy"/>
          </references>
        </command>

        <command name="paste">
          <description>Pastes a previously copied selection.</description>
          <remarks>
            <remark>
            To paste a selection back requires a same size selection at the destination location. If it is not the same
            size the selection will be resized automatically prior to the paste operation (with the red dot as anchor),
            which is easier for large selections.
            </remark>
          </remarks>
          <defaultKeys>
            <key alias="V"/>
          </defaultKeys>
          <references>
            <identifierReference identifier="copy"/>
          </references>
        </command>

        <command name="pasteent">
          <description>Pastes a previously copied entity.</description>
          <remarks>
            <remark>It also works with the menu list of copied entities. It works only while in edit mode.</remark>
            <remark>Pressing "editmeta" while using "pasteent" opens the menu with a list of copied entities.</remark>
          </remarks>
          <references>
            <identifierReference identifier="copyent"/>
            <identifierReference identifier="editmeta"/>
          </references>
        </command>

        <scriptalias name="countwalls">
          <description>Returns the number of solid walls contained into the current selection.</description>
          <arguments>
            <argument token="T" description="the integer of type of the walls you want to count" valueNotes=" 0 (solid), 1 (corner), 2 (floor heightfield), 3 (ceil heightfield), 4 (empty cube), 5 (semi solid)"/>
          </arguments>
          <examples>
            <example>
              <code><![CDATA[echo (concat "The selection contains " (countwalls 0) "solid wall(s)")]]></code>
              <explanation>Output: The selection contains 3 solid wall(s)</explanation>
            </example>
          </examples>
        </scriptalias>

        <command name="replace">
          <description>Repeats the last texture edit throughout the map.</description>
          <remarks>
            <remark>
            The way it works is intuitive: simply edit any texture anywhere, then using "replace" will replace
            all textures throughout the map in the same way (taking into account whether it was a floor/wall/ceil/upper too).
            If the there was more than one "old" texture in your selection, the one nearest to the red dot is used.
            This operation can't be undone.
            </remark>
          </remarks>
        </command>

        <command name="newent">
          <description>Adds a new entity.</description>
          <remarks>
            <remark>
            (x,y) is determined by the current selection (the red dot corner) and z by the camera height, of said type.
            The type of entity may optionally take attributes (depending on the entity).
            </remark>
          </remarks>
          <arguments>
            <argument token="E" description="the entity type or number" valueNotes="light (1), playerstart (2), pistol (3), ammobox (4), grenades (5), health (6), helmet (7), armour (8), akimbo (9), mapmodel (10), ladder (12), ctf-flag (13), sound (14), clip (15), plclip (16)"/>
            <argument token="attr1" description="see newent 'type'"/>
            <argument token="attr2" description="see newent 'type'"/>
            <argument token="attr3" description="see newent 'type'"/>
            <argument token="attr4" description="see newent 'type'"/>
            <argument token="attr5" description="see newent 'type'"/>
            <argument token="attr6" description="see newent 'type'"/>
            <argument token="attr7" description="see newent 'type'"/>
          </arguments>
        </command>

        <command name="newent light">
          <description>Adds a new light entity.</description>
          <remarks>
            <remark>if only argument R is specified, it is interpreted as brightness for white light.</remark>
          </remarks>
          <arguments>
            <argument token="radius" description="the light radius" valueNotes="1..32"/>
            <argument token="R" description="red colour component, see remarks below" valueNotes="1..255"/>
            <argument token="G" description="green colour component" valueNotes="1..255"/>
            <argument token="B" description="blue colour component" valueNotes="1..255"/>
          </arguments>
        </command>

        <command name="newent playerstart">
          <description>Adds a new spawn spot.</description>
          <remarks>
            <remark>The yaw is taken from the current camera yaw.</remark>
          </remarks>
        </command>

        <command name="newent ammobox">
          <description>Adds a new ammo box item.</description>
        </command>

        <command name="newent pistol">
          <description>Adds a pistol magazine item.</description>
        </command>

        <command name="newent grenades">
          <description>Adds a new grenades item.</description>
        </command>

        <command name="newent health">
          <description>Adds a new health item.</description>
        </command>

        <command name="newent armour">
          <description>Adds a new armour item.</description>
        </command>

        <command name="newent helmet">
          <description>Adds a new helmet item.</description>
        </command>

        <command name="newent akimbo">
          <description>Adds a new akimbo item.</description>
        </command>

        <command name="newent mapmodel">
          <description>Adds a map model to the map (i.e. a rendered md2/md3 model which you collide against but has no behaviour or movement).</description>
          <remarks>
            <remark>
            The mapmodel identifier is the desired map model which is defined by the 'mapmodel' command. The order in which
            the mapmodel is placed in the map config file defines the mapmodel identifier.
            The map texture refers to a texture which is defined by the 'texture' command, if omitted the
            models default skin will be used. The 'mapmodel' and 'texture' commands are placed in the map config normally.
            Mapmodels are more expensive than normal map geometry, so do not use insane amounts of them to replace normal geometry.
            </remark>
          </remarks>
          <arguments>
            <argument token="N" description="The mapmodel identifier" valueNotes="integer"/>
            <argument token="Z" description="Extra elevation above ground" valueNotes="integer" optional="true"/>
            <argument token="T" description="The map texture to use" valueNotes="integer" optional="true"/>
          </arguments>
        </command>

        <command name="newent ctf-flag">
          <description>Adds a CTF flag entity.</description>
          <remarks>
            <remark>Note that outside of edit mode, this entity is only rendered as flag if the current game mode is CTF.</remark>
          </remarks>
          <arguments>
            <argument token="T" description="denotes the flag's team" valueNotes="0 (CLA), 1 (RVSF)"/>
          </arguments>
        </command>

        <command name="newent ladder">
          <description>Adds a ladder entity.</description>
          <remarks>
            <remark>
            Note that this entity is used for physics only, to create a visual ladder you
            will need to add a mapmodel entity too.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="newent mapmodel"/>
          </references>
          <arguments>
            <argument token="H" description="the height of the ladder" valueNotes="integer"/>
          </arguments>
        </command>

        <command name="newent sound">
          <description>Adds a sound entity.</description>
          <remarks>
            <remark>
            Will play map-specific sound so long as the player is within the radius.
            However, only up to the maxuses allowed for N (specified in the mapsound command) will play, even if the player is within the radius of more N sounds than the max.
            By default (size 0), the sound is a point source. Its volume is maximal at the entity's location, and tapers off to 0 at the radius. If size is specified,
            the volume is maximal within the specified size, and only starts tapering once outside this distance. Radius is always defined as distance from the entity's location,
            so a size greater than or equal to the radius will just make a sound that is always max volume within the radius, and off outside.
            </remark>
            <remark>
            A sound entity can be either ambient or non-ambient. Ambient sounds have no specific direction, they are 'just there'. Non-ambient sounds however appear to come from a specific direction (stereo panning).
            If S is set to 0, the sound is a single point and will therefore be non-ambient. However if S is greater than 0, the sound will be ambient as it covers a specified area instead of being a single point.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="mapsound"/>
          </references>
          <arguments>
            <argument token="N" description="the sound to play" valueNotes="integer"/>
            <argument token="R" description="the radius"/>
            <argument token="S" description="the size" optional="true" valueNotes="default 0"/>
            <argument token="V" description="the volume" optional="true" valueNotes="default 255"/>
          </arguments>
        </command>

        <command name="newent clip">
          <description>Adds a clip entity.</description>
          <remarks>
            <remark>Defines a clipping box against which the player will collide.</remark>
            <remark>
            Use this clip type to clip visible obstacles like fences or the gas tank. If you only want to prevent a player from entering an area, use plclip instead.
            </remark>
          </remarks>
          <arguments>
            <argument token="Z" description="elevation above the ground" valueNotes="integer"/>
            <argument token="X" description="X radius around the box center" valueNotes="integer"/>
            <argument token="Y" description="Y radius around the box center" valueNotes="integer"/>
            <argument token="H" description="height of the box" valueNotes="integer"/>
          </arguments>
        </command>

        <command name="newent plclip">
          <description>Adds a player clip entity.</description>
          <remarks>
            <remark>Defines a clipping box against which (only) the player will collide.</remark>
            <remark>
            Use this clip type to define no-go areas for players without visible obstacles, for example to prevent players from walking on a wall.
            </remark>
            <remark>Nades will not be affected by this clip type.</remark>
          </remarks>
          <arguments>
            <argument token="Z" description="elevation above the ground" valueNotes="integer"/>
            <argument token="X" description="X radius around the box center" valueNotes="integer"/>
            <argument token="Y" description="Y radius around the box center" valueNotes="integer"/>
            <argument token="H" description="height of the box" valueNotes="integer"/>
          </arguments>
        </command>

        <command name="delent">
          <description>Deletes the entity closest to the player.</description>
          <defaultKeys>
            <key alias="BACKSPACE"/>
          </defaultKeys>
          <references>
            <identifierReference identifier="undelent"/>
            <identifierReference identifier="deleteentity"/>
            <identifierReference identifier="clearents"/>
          </references>
        </command>

        <command name="entset">
          <description>Edits the closest entity.</description>
          <remarks>
            <remark>Overwrites the closest entity with the specified attributes. Some attributes may be specified as floats.</remark>
          </remarks>
          <arguments>
            <argument token="E" description="the entity type or number" valueNotes="light (1), playerstart (2), pistol (3), ammobox (4), grenades (5), health (6), helmet (7), armour (8), akimbo (9), mapmodel (10), ladder (12), ctf-flag (13), sound (14), clip (15), plclip (16)"/>
            <argument token="attr1" description="see newent 'type'"/>
            <argument token="attr2" description="see newent 'type'"/>
            <argument token="attr3" description="see newent 'type'"/>
            <argument token="attr4" description="see newent 'type'"/>
            <argument token="attr5" description="see newent 'type'"/>
            <argument token="attr6" description="see newent 'type'"/>
            <argument token="attr7" description="see newent 'type'"/>
          </arguments>
          <references>
            <identifierReference identifier="editentity"/>
          </references>
        </command>

        <command name="entproperty">
          <description>Changes property (attributes) of the closest entity.</description>
          <remarks>
            <remark>For example 'entproperty 0 2' when executed near a lightsource would increase its radius by 2.</remark>
            <remark>
            Keys 1..7, in combination with the scrollwheel, can be used to alter the new entity attributes (attr1 - attr7).
            Key "M", in combination with the scrollwheel, can be used to move the entity.
            Pressing editmeta speeds up the scrolling. Pressing editmeta2 enables unscaled editing of entity attributes.
            </remark>
            <remark>
            Increment is a float for some attributes. If "unscaled" flag is "1", increment is applied as unscaled integer,
            which means, it will change float attributes at their highest resolution.
            </remark>
            <remark>If 100 is added to the attribute index parameter, the sign of the increment value is changed.</remark>
          </remarks>
          <arguments>
            <argument token="A" description="attribute index" valueNotes="0..6 (atrr1 - attr7), 11..13 (x, y, z)"/>
            <argument token="I" description="attribute increment" valueNotes=""/>
            <argument token="U" description="unscaled flag" valueNotes="0 or 1" optional="true"/>
          </arguments>
          <references>
            <identifierReference identifier="getclosestent"/>
            <identifierReference identifier="getentattr"/>
            <identifierReference identifier="getenttype"/>
            <identifierReference identifier="editmeta"/>
            <identifierReference identifier="editmeta2"/>
          </references>
        </command>

        <command name="clearents">
          <description>Deletes all entities of said type.</description>
          <arguments>
            <argument token="T" description="the entity type, see command 'newent'" valueNotes="string"/>
          </arguments>
          <references>
            <identifierReference identifier="delent"/>
            <identifierReference identifier="deleteentity"/>
          </references>
        </command>

        <variable name="cleanedit">
          <description>Turns on/off clean edit mode.</description>
          <remarks>
            <remark>While editing in clean edit mode, objects/guides not normally visible remain invisible.</remark>
            <remark>i.e. The grid guidelines, selection borders, entity sparkles, clips, playerstart arrows are hidden</remark>
          </remarks>
          <arguments>
            <argument token="V" description="sets cleanedit on/off" valueNotes="0 (off), 1 (on)"/>
          </arguments>
          <references>
            <identifierReference identifier="togglecleanedit"/>
          </references>
        </variable> 

        <command name="togglecleanedit">
          <description>Inverses the on/off state of cleanedit</description>
          <references>
            <identifierReference identifier="cleanedit"/>
          </references>
        </command>       

        <command name="recalc">
          <description>Recomputes all there is to recompute about a map, currently only lighting.</description>
        </command>

        <command name="savemap">
          <description>Saves the current map.</description>
          <remarks>
            <remark>
            It makes a versioned backup (mapname_N.BAK) if a map by that name already exists.
            If the name argument is omitted, it is saved under the current map name.
            </remark>
            <remark>
            Where you store a map depends on the complexity of what you are creating: if its a single
            map (maybe with its own .cfg) then the "base" package is the best place. If its multiple maps
            or a map with new media (textures etc.) its better to store it in its own package (a directory under "packages"),
            which makes distributing it less messy.
            </remark>
            <remark>
            For "savemap" to save different maps during editing with undo data, the variable "preserveundosonsave" has to be "1".
            It is "0" by default. "savemap" when not editing saves optimised map, with no undo data.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="map"/>
            <identifierReference identifier="savemapoptimised"/>
            <identifierReference identifier="preserveundosonsave"/>
          </references>
          <arguments>
            <argument token="M" description="file name of the map, see command 'map' for the naming scheme" valueNotes="string"/>
          </arguments>
        </command>

        <command name="savemapoptimised">
          <description>Saves optimised the current map, with no undo data.</description>
          <remarks>
            <remark>
            It makes a versioned backup (mapname_N.BAK) if a map by that name already exists.
            If the name argument is omitted, it is saved under the current map name.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="map"/>
            <identifierReference identifier="savemap"/>
          </references>
          <arguments>
            <argument token="M" description="file name of the map, see command 'map' for the naming scheme" valueNotes="string"/>
          </arguments>
        </command>

        <variable name="preserveundosonsave">
          <description>Determines if undo data should be preserved on using "savemap" command.</description>
          <remarks>
           <remark>Undo data can be saved only in edit mode.</remark>
          </remarks>
          <value token="N" description="0: don't preserve undos, 1: preserve undos" minValue="0" maxValue="1" defaultValue="0"/>
          <references>
            <identifierReference identifier="savemap"/>
          </references>
        </variable>

        <variable name="mapbackupsonsave">
          <description>Determines if map backups (.bak) should be created when a map is saved.</description>
          <value token="N" description="0 off, 1 on" minValue="0" maxValue="1" defaultValue="1"/>
        </variable>

        <command name="savemap9">
          <description>Saves a map in old map format 9 (may lose some map details that are not possible with format 9).</description>
        </command>

        <command name="newmap">
          <description>Creates a new map.</description>
          <remarks>
            <remark>The new map has 2^S cubes. For S, 6 is small, 7 medium, 8 large.</remark>
          </remarks>
          <arguments>
            <argument token="S" description="the size of the new map" valueNotes="6..9"/>
          </arguments>
          <references>
            <identifierReference identifier="mapsize"/>
            <identifierReference identifier="mapenlarge"/>
            <identifierReference identifier="mapshrink"/>
          </references>
        </command>

        <command name="mapsize">
          <description>Outputs the mapsize.</description>
          <references>
            <identifierReference identifier="newmap"/>
            <identifierReference identifier="mapenlarge"/>
            <identifierReference identifier="mapshrink"/>
          </references>
        </command>

        <command name="mapenlarge">
          <description>Enlarges the current map.</description>
          <remarks>
            <remark>
            This command will make the current map 1 power of two bigger.
            So a size 6 map (64x64 units) will become a size 7 map (128x128),
            with the old map in the middle (from 32-96) and the new areas solid.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="newmap"/>
            <identifierReference identifier="mapsize"/>
            <identifierReference identifier="mapshrink"/>
          </references>
        </command>

        <command name="mapshrink">
          <description>Reduces the world size by 1.</description>
          <remarks>
            <remark>
            This command will make the current map 1 power of two smaller.
            So a size 7 map (128x128) will become a 6 size map (64x64 units), by removing 32 cubes from each side.
            The area to be removed needs to be empty (= all solid).
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="newmap"/>
            <identifierReference identifier="mapsize"/>
            <identifierReference identifier="mapenlarge"/>
          </references>
        </command>

        <variable name="mapmsg">
          <description>Sets the map message, which will be displayed when the map loads.</description>
          <remarks>
            <remark>You will need to use quote marks around the message, otherwise it save the message correctly.</remark>
            <remark>For example: /mapmsg "Map By Author"</remark>
            <remark>You can get the current map message with the $mapmsg variable.</remark>
          </remarks>
          <arguments>
            <argument token="M" description="The map message" valueNotes="string"/>
          </arguments>
          <references>
            <identifierReference identifier="editmapmsg"/>
          </references>
        </variable>

        <command name="editmapmsg">
          <description>Allows to edit the map message.</description>
          <references>
            <identifierReference identifier="mapmsg"/>
          </references>
        </command>

        <variable name="mapinfo_license">
          <description>Sets the map license.</description>
          <remarks>
            <remark>
            The name of license is stored withing the header of a map file. The license string is meant to hold
            an abbreviated name of the license, picked from a list of known map licenses.
            </remark>
            <remark>You can get the type of map license with the $mapinfo_license variable.</remark>
          </remarks>
          <arguments>
            <argument token="L" description="type of license" valueNotes="string"/>
          </arguments>
          <references>
            <identifierReference identifier="mapinfo_comment"/>
          </references>
        </variable>

        <variable name="mapinfo_comment">
          <description>Sets the map comment string.</description>
          <remarks>
            <remark>
            The variable is stored withing the header of a map file.
            The comment string is ignored, as long as no map license string is set.
            </remark>
            <remark>You can get the comment string with the $mapinfo_comment variable.</remark>
          </remarks>
          <arguments>
            <argument token="C" description="comment" valueNotes="string"/>
          </arguments>
          <references>
            <identifierReference identifier="mapinfo_license"/>
          </references>
        </variable>

        <command name="entstats">
          <description>Prints some map entity statistics to the console.</description>
        </command>

        <command name="closestenttype">
          <description>Restricts 'closest entity' display to one entity type.</description>
          <remarks>
            <remark>It returns the current value and not change the value if the argument is "-".</remark>
          </remarks>
          <arguments>
            <argument token="A" description="the entity type or number" valueNotes="light (1), playerstart (2), pistol (3), ammobox (4), grenades (5), health (6), helmet (7), armour (8), akimbo (9), mapmodel (10), ladder (12), ctf-flag (13), sound (14), clip (15), plclip (16)"/>
          </arguments>
        </command>

        <command name="nextclosestent">
          <description>Chooses another 'closest ent'.</description>
          <remarks>
            <remark>Use this, when two entities are placed in exactly the same location.</remark>
          </remarks>
        </command>

        <command name="nextplayerstart">
          <description>Visit next player spawn entity.</description>
          <arguments>
            <argument token="N" description="team number" valueNotes="0: CLA, 1: RVSF, 100: FFA"/>
          </arguments>
          <references>
            <identifierReference identifier="gonextplayerstart"/>
          </references>
        </command>

        <command name="gonextplayerstart">
          <description>Visit next or previous player spawn entity.</description>
          <arguments>
            <argument token="N" description="direction" valueNotes="none or 1: next, -1: previous"/>
          </arguments>
          <references>
            <identifierReference identifier="nextplayerstart"/>
          </references>
        </command>

        <command name="convertclips">
          <description>Converts the nearest entity (if its a clip or plclip) to its opposite type.</description>
          <examples>
            <example>
              <code><![CDATA[convertclips]]></code>
              <explanation>Assuming the nearest entity is a clip, it will be converted to a plclip.</explanation>
            </example>
            <example>
              <code><![CDATA[convertclips]]></code>
              <explanation>Assuming the nearest entity is a plclip, it will be converted to a clip.</explanation>
            </example>
          </examples>
        </command>

        <command name="movemap">
          <description>Moves the whole map (including all entities) in the specified direction.</description>
          <arguments>
            <argument token="dX" description="x-offset"/>
            <argument token="dY" description="y-offset"/>
            <argument token="dZ" description="z-offset"/>
          </arguments>
        </command>

        <command name="selectionflip">
          <description>Flips the selected part of the map at an axis.</description>
          <arguments>
            <argument token="AXIS" description="X or Y"/>
          </arguments>
        </command>

        <command name="selectionrotate">
          <description>Rotates the selected part of the map in 90 degree steps.</description>
          <arguments>
            <argument token="D" description="steps"/>
          </arguments>
          <remarks>
            <remark>
            To rotate clockwise, use a positive number of steps. Note, that only quadratic selections can be rotated by 90 degrees.
            </remark>
          </remarks>
        </command>

        <variable name="editaxis">
          <description>Returns a value for the main axis of player orientation.</description>
          <remarks>
            <remark>"100" is added if the player is looking in the negative direction of the axis.</remark>
          </remarks>
          <value description="main axis of player orientation" minValue="0" maxValue="113" defaultValue="0" readOnly="true" valueNotes="11 (X), 12 (Y), 13 (Z), 111 (-X), 112 (-Y), 113 (-Z)"/>
        </variable>

        <variable name="advancemaprevision">
          <description>Selects the increment of the map revision number for the next 'savemap'.</description>
          <value token="N" description="increment" minValue="1" maxValue="100" defaultValue="1"/>
        </variable>

        <variable name="showmodelclipping">
          <description>Show mapmodel clipping during edit mode.</description>
          <value token="N" description="-" minValue="0" maxValue="1" defaultValue="0"/>
        </variable>

        <variable name="showgrid">
          <description>Show editing cursor grid.</description>
          <value token="N" description="-" minValue="0" maxValue="1" defaultValue="1"/>
        </variable>

        <variable name="showclips">
          <description>Show clips/plclips/mapmodel clips in edit mode.</description>
          <value token="N" description="-" minValue="0" maxValue="1" defaultValue="1"/>
        </variable>

        <variable name="showtagclips">
          <description>Show tagclips/tagplclips in edit mode.</description>
          <value token="N" description="-" minValue="0" maxValue="1" defaultValue="1"/>
          <references>
            <identifierReference identifier="showtagclipfocus"/>
            <identifierReference identifier="taglife"/>
            <identifierReference identifier="tagnum"/>
            <identifierReference identifier="tagnumfull"/>
          </references>
        </variable>

        <variable name="tagnum">
          <description>Number of particles in the focused on tagclip volume.</description>
          <value token="C" description="count" minValue="1" maxValue="100" valueNotes="particle count" defaultValue="14"/>
          <remarks>
            <remark>source comments suggest this may become hardwired in the future</remark>
          </remarks>
          <references>
            <identifierReference identifier="showtagclips"/>
            <identifierReference identifier="tagnum"/>
            <identifierReference identifier="tagnumfull"/>
          </references>
        </variable>

        <variable name="tagnumfull">
          <description>Number of particles in any tagclip volume - if showtagclipfocus is not 1.</description>
          <value token="C" description="count" minValue="1" maxValue="100" valueNotes="particle count" defaultValue="0"/>
          <remarks>
            <remark>source comments suggest this may become hardwired in the future</remark>
          </remarks>
          <references>
            <identifierReference identifier="showtagclips"/>
            <identifierReference identifier="showtagclipfocus"/>
          </references>
        </variable>

        <variable name="taglife">
          <description>Fading time of sparklies in focused on tagclip volume</description>
          <value token="T" description="time" minValue="1" maxValue="1000" valueNotes="milliseconds" defaultValue="30"/>
          <remarks>
            <remark>source comments suggest this may become hardwired in the future</remark>
          </remarks>
          <references>
            <identifierReference identifier="showtagclips"/>
            <identifierReference identifier="showtagclipfocus"/>
            <identifierReference identifier="tagnum"/>
          </references>
        </variable>

        <variable name="showladderentities">
          <description>Show ladder entities (as blue wireframes) in edit mode.</description>
          <value token="N" description="-" minValue="0" maxValue="1" defaultValue="0"/>
        </variable>

        <command name="guidetoggle">
          <description>Enables or disables a special set of default textures while editing.</description>
          <remarks>
            <remark>The textures in "packages/textures/map_editor" are used.</remark>
          </remarks>
        </command>

        <variable name="waterlevel">
          <description>Sets the global water level for the map.</description>
          <remarks>
            <remark>
            Every cube that has a lower floor than the water level will be rendered with a nice wavy
            water alpha texture. Water physics will be applied to any entity located below it.
            </remark>
            <remark>
            Performance notes: water is rendered for a whole square encapsulating all visible water areas
            in the map (try flying above the map in edit mode to see how). So the most efficient water is
            a single body of water, or multiple water areas that are mostly not visible from each other.
            Players can influence how accurate the water is rendered using the "watersubdiv" command (map config).
            </remark>
          </remarks>
          <value token="H" description="the water level" valueNotes="float, -10000=&quot;no water&quot;" minValue="-128" maxValue="127" defaultValue="-10000"/>
          <references>
            <identifierReference identifier="watersubdiv"/>
          </references>
        </variable>

        <command name="getwatercolour">
          <description>Returns a string with the four components of the water colour: red, green, blue and alpha.</description>
          <examples>
            <example>
              <code><![CDATA[echo (getwatercolor)]]></code>
              <explanation>Output: 20 25 20 178</explanation>
            </example>
          </examples>
          <references>
            <identifierReference identifier="watercolour"/>
            <identifierReference identifier="setwatercolour"/>
          </references>
        </command>

        <command name="setwatercolour">
          <description>Allows setting the components of the water colour independently.</description>
          <remarks>
            <remark>
            "what" is either a keyword "red|green|blue|alpha" or the index number 0..3 and determines,
            which component is set to value.
            </remark>
          </remarks>
          <examples>
            <example>
              <code><![CDATA[setwatercolour red 200]]></code>
              <explanation>- sets the red component to 200</explanation>
            </example>
          </examples>
          <arguments>
            <argument token="W" description="what" valueNotes="red (0), green (1), blue (2), alpha (3)"/>
            <argument token="V" description="value" valueNotes="(0)1..255"/>
          </arguments>
          <references>
            <identifierReference identifier="watercolour"/>
            <identifierReference identifier="getwatercolour"/>
          </references>
        </command>

        <variable name="ambient">
          <description>Controls the ambient lighting of the map, i.e. how bright areas not affected by any light entities will appear.</description>
          <description>This should be entered in hexadecimal notation, as 0xRRGGBB. If the green and blue are both zero, the input will be interpreted as a grayscale value.</description>
          <value token="N" description="the ambient color" minValue="0x000000" maxValue="0xFFFFFF" defaultValue="0"/>
        </variable>

        <variable name="fullbright">
          <description>Sets all light values to fullbright.</description>
          <value token="B" description="sets fullbright on or off" valueNotes="0 (off), 1 (on)"/>
          <remarks>
            <remark>Will be reset when you issue a 'recalc'. Only works in edit mode.</remark>
          </remarks>
          <defaultKeys>
            <key alias="F7" description="toggles fullbright"/>
          </defaultKeys>
        </variable>

        <variable name="fullbrightlevel">
          <description>Sets the level of brightness to use when using the command "/fullbright 1".</description>
          <value token="V" description="Light intensity level" minValue="0" maxValue="255" defaultValue="176"/>
        </variable>

        <command name="showmip">
          <description>Toggles between showing what parts of the scenery are rendered.</description>
          <remarks>
            <remark>
            Shows what parts of the scenery are rendered using what size cubes and outputs some statistics about it.
            This can give map editors hints as to what architecture to align, textures to change, etc.
            </remark>
            <remark>If "showfocuscubedetails" is enabled, "showmip" stats on the HUD are hidden.</remark>
          </remarks>
          <defaultKeys>
            <key alias="F6"/>
          </defaultKeys>
          <references>
            <identifierReference identifier="calcmipstats"/>
            <identifierReference identifier="showfocuscubedetails"/>
          </references>
        </command>

        <command name="showfocuscubedetails">
          <description>Shows detailed geometry data of the cube inside editing focus.</description>
          <remarks>
            <remark>It shows on the HUD cube type, floor and ceiling heights, vdelta and all textures.</remark>
          </remarks>
          <defaultKeys>
            <key alias="F8"/>
          </defaultKeys>
          <references>
            <identifierReference identifier="showmip"/>
          </references>
        </command>

        <command name="toggleocull">
          <description>Turns occlusion culling on and off.</description>
          <remarks>
            <remark>
            The reason one may want to turn it off is to get an overview of the map from above,
            without having all occluded bits stripped out.
            </remark>
          </remarks>
          <defaultKeys>
            <key alias="F5"/>
          </defaultKeys>
        </command>

        <command name="slope">
          <description>Makes a slope out of the current selection.</description>
          <remarks>
            <remark>
            The selection must be a heightfield before this command can be used.
            The steps specify the slope with the red vertex as left-top,
            i.e. "slope 1 2" will make a slope that increases just 1 step from left to right,
            and is slightly steeper from top to bottom. "slope -6 0" decreases steeply from left to right,
            and does not slope at all from top to bottom. Note that like the vdelta command,
            an increasing vdelta goes further away from the player, regardless of floor or ceiling.
            </remark>
          </remarks>
          <arguments>
            <argument token="X" description="x delta step" valueNotes="integer"/>
            <argument token="Y" description="y delta step" valueNotes="integer"/>
          </arguments>
          <references>
            <identifierReference identifier="enlargearchslopeselections"/>
          </references>
        </command>

        <command name="arch">
          <description>Makes an arch out of the current selection.</description>
          <remarks>
            <remark>
            The selection must be a heightfield before this command can be used.
            Will make the arch in the long direction, i.e when you have 6x2 cubes selected, the arch will span 7 vertices.
            Optionally, sidedelta specifies the delta to add to the outer rows of vertices in the other direction,
            i.e. give the impression of an arch that bends 2 ways (try "arch 2" on an selection of at least 2 thick to see the effect).
            Not all arch sizes are necessarily available, see config/prefabs.cfg.
            </remark>
          </remarks>
          <arguments>
            <argument token="S" description="side delta" optional="true"/>
          </arguments>
          <references>
            <identifierReference identifier="archvertex"/>
            <identifierReference identifier="enlargearchslopeselections"/>
          </references>
        </command>

        <command name="archvertex">
          <description>Defines a vertex delta for a specific arch span prefab, used by the 'arch' command.</description>
          <remarks>
            <remark>It returns the old value of the vertex, and if the vertex argument is omitted, doesn't change it.</remark>
            <remark>See config/prefabs.cfg for an example on usage.</remark>
          </remarks>
          <arguments>
            <argument token="S" description="span value" valueNotes="integer"/>
            <argument token="V" description="vertex value" valueNotes="integer"/>
            <argument token="D" description="delta value" valueNotes="integer"/>
          </arguments>
        </command>

        <variable name="enlargearchslopeselections">
          <description>Automatically enlarge selections after placing arches or slopes.</description>
          <remarks>
            <remark>
            If the variable is set to 1, after placing an arch or a slope, the selection is enlarged, so that the arch
            or slope can be changed by vdelta increments (for example, to raise an arch in 1/4 cube increments).
            </remark>
            <remark>
            If the variable is set to 0 (which is default), the selection remains unchanged. This way, for example,
            the arch can be raised or lowered by regular cube increments.
            </remark>
          </remarks>
          <value token="N" description="0: don't enlarge selection, 1: enlarge selection" minValue="0" maxValue="1" defaultValue="0"/>
          <references>
            <identifierReference identifier="arch"/>
            <identifierReference identifier="slope"/>
          </references>
        </variable>

        <command name="perlin">
          <description>Generates a perlin noise landscape in the current selection.</description>
          <remarks>
            <remark>
            Keep the seed the same to create multiple perlin areas which fit with each other,
            or use different numbers if to create alternative random generations.
            </remark>
          </remarks>
          <arguments>
            <argument token="S" description="the scale, frequency of the features" valueNotes="default is 10"/>
            <argument token="E" description="the random seed" valueNotes="integer"/>
            <argument token="C" description="cube size, how many cubes to generate a surface for at once (unused)"/>
          </arguments>
        </command>

        <command name="select">
          <description>Resets all current selections and selects the given area, as if dragged with the mouse.</description>
          <remarks>
            <remark>
            This command is similar to addselection although "select" resets all selections.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="addselection"/>
            <identifierReference identifier="selectall"/>
            <identifierReference identifier="resetselections"/>
            <identifierReference identifier="expandselection"/>
            <identifierReference identifier="shrinkselection"/>
            <identifierReference identifier="enlargevdeltaselections"/>
            <identifierReference identifier="selx"/>
            <identifierReference identifier="sely"/>
            <identifierReference identifier="selxs"/>
            <identifierReference identifier="selys"/>
            <identifierReference identifier="selectionwalk"/>
            <identifierReference identifier="pushselections"/>
          </references>
          <arguments>
            <argument token="X" description="the X coordinate"/>
            <argument token="Y" description="the Y coordinate"/>
            <argument token="XS" description="the length along the X axis"/>
            <argument token="XY" description="the length along the Y axis"/>
          </arguments>
        </command>

        <command name="addselection">
          <description>Selects the given area, as if dragged with the mouse holding editmeta.</description>
          <remarks>
            <remark>
              This command is useful for making complex geometry-generating scripts.
              It adds a selection to the current list of selections.
              The dimensions of the current selections can be accessed by the commands selx, sely, selxs and selys.
              These commands return the list of coordinates corresponding to each selection.
            </remark>
            <remark>
              Coordinates are as follows: after a "newmap 6" the top-left corner (the one where the red dot points) are (8,8),
              the opposite corner is (56,56) (or (120,120) on a "newmap 7" etc.).
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="select"/>
            <identifierReference identifier="selectall"/>
            <identifierReference identifier="resetselections"/>
            <identifierReference identifier="expandselection"/>
            <identifierReference identifier="shrinkselection"/>
            <identifierReference identifier="enlargevdeltaselections"/>
            <identifierReference identifier="selx"/>
            <identifierReference identifier="sely"/>
            <identifierReference identifier="selxs"/>
            <identifierReference identifier="selys"/>
            <identifierReference identifier="selectionwalk"/>
            <identifierReference identifier="pushselections"/>
            <identifierReference identifier="editmeta"/>
          </references>
          <arguments>
            <argument token="X" description="the X coordinate"/>
            <argument token="Y" description="the Y coordinate"/>
            <argument token="XS" description="the length along the X axis"/>
            <argument token="XY" description="the length along the Y axis"/>
          </arguments>
        </command>

        <command name="selectall">
          <description>Selects the whole map (minus the two cubes wide border).</description>
          <references>
            <identifierReference identifier="select"/>
            <identifierReference identifier="addselection"/>
            <identifierReference identifier="resetselections"/>
          </references>
        </command>

        <command name="resetselections">
          <description>Resets all current selections.</description>
          <references>
            <identifierReference identifier="select"/>
            <identifierReference identifier="selectall"/>
            <identifierReference identifier="addselection"/>
          </references>
        </command>

        <command name="expandselection">
          <description>Increases the size of the current selection by N cubes on all sides.</description>
          <arguments>
            <argument token="N" description="number of cubes" valueNotes="integer"/>
          </arguments>
          <remarks>
            <remark>Instead of manually executing this command, you can bind "domodifier 11" to a key. While holding this key you can expand/shrink the current selection with the mouse wheel.</remark>
            <remark>It works also with multiple selections.</remark>
          </remarks>
          <references>
            <identifierReference identifier="select"/>
            <identifierReference identifier="addselection"/>
            <identifierReference identifier="shrinkselection"/>
          </references>
        </command>

        <command name="shrinkselection">
          <description>Decreases the size of the current selection by N cubes on all sides.</description>
          <arguments>
            <argument token="N" description="number of cubes" valueNotes="integer"/>
          </arguments>
          <remarks>
            <remark>Instead of manually executing this command, you can bind "domodifier 11" to a key. While holding this key you can expand/shrink the current selection with the mouse wheel.</remark>
            <remark>It works also with multiple selections.</remark>
          </remarks>
          <references>
            <identifierReference identifier="select"/>
            <identifierReference identifier="addselection"/>
            <identifierReference identifier="expandselection"/>
          </references>
        </command>

        <command name="enlargevdeltaselections">
          <description>Enlarges all selections by one cube in x- and y- direction, to change a selection from the "cube area" to the "vdelta area".</description>
          <remarks>
            <remark>
            If an argument is given, it is used as increment value, so, for example "enlargevdeltaselections -1" undoes
            a previous enlargement.
            </remark>
           </remarks>
          <arguments>
            <argument token="I" description="incremente" optional="true"/>
          </arguments>
          <references>
            <identifierReference identifier="select"/>
            <identifierReference identifier="addselection"/>
          </references>
        </command>

        <command name="selx">
          <description>Returns the x-coordinate of the westernmost (towards negative x) cube(s) in the current selection.</description>
          <references>
            <identifierReference identifier="select"/>
            <identifierReference identifier="sely"/>
            <identifierReference identifier="selxs"/>
            <identifierReference identifier="selys"/>
          </references>
        </command>

        <command name="selxs">
          <description>Returns the x-span (size on the x-axis) of the current selection.</description>
          <references>
            <identifierReference identifier="select"/>
            <identifierReference identifier="selx"/>
            <identifierReference identifier="sely"/>
            <identifierReference identifier="selys"/>
          </references>
        </command>

        <command name="sely">
          <description>Returns the y-coordinate of the northernmost (towards negative y) cube(s) in the current selection.</description>
          <references>
            <identifierReference identifier="select"/>
            <identifierReference identifier="selx"/>
            <identifierReference identifier="selxs"/>
            <identifierReference identifier="selys"/>
          </references>
        </command>

        <command name="selys">
          <description>Returns the y-span (size on the y-axis) of the current selection.</description>
          <references>
            <identifierReference identifier="select"/>
            <identifierReference identifier="selx"/>
            <identifierReference identifier="sely"/>
            <identifierReference identifier="selxs"/>
          </references>
        </command>

        <command name="selectionwalk">
          <description>Iterates over all cubes in all selections and executes "action" for each cube.</description>
          <remarks>
            <remark>
            The cubes of every selection are framed by executions of "beginsel" and "endsel", i.e. for each new selection,
            before executing "action" for the cubes of that selection, "beginsel" is executed, and then, after actions for all
            cubes of that selection, "endsel" is executed. The action script is allowed to make changes to cube attributes,
            and if it does, an undo point is automatically added. "beginsel" and "endsel" are optional.
            </remark>
            <remark>While the scripts are executed, several aliases provide further info:</remark>
            <remark>
            "sw_cursel" - position and size of the current selection. Valid in all three scripts.
            Holds four integer values for x, y, xs, ys. See "select" command for details.
            </remark>
            <remark>
            (all following aliases are only valid during the execution of the action
            script and provide the attributes of one cube of the map)
            </remark>
            <remark>
            "sw_abs_x", "sw_abs_y", "sw_rel_x", "sw_rel_y" - absolute and relative (within the current selection) coordinates
            of the current cube. Read-only values.
            </remark>
            <remark>
            "sw_type" - type of the current cube. Can be 0..4 for SOLID, CORNER, FHF, CHF and SPACE.
            May be changed to other numerical value or keyword.
            </remark>
            <remark>"sw_floor", "sw_ceil" - floor and ceiling heights of the current cube. Range -128..127.</remark>
            <remark>
            "sw_wtex", "sw_ftex", "sw_ctex", "sw_utex" - texture slot indices for wall, floor, ceiling
            and upper wall of the current cube.
            </remark>
            <remark>"sw_vdelta", "sw_tag" - vdelta and tag values of current cube.</remark>
            <remark>
            "sw_r", "sw_g", "sw_b" - current light values of current cube. Can be edited, but only with temporary effect.
            Will be reset with the next light recalc.
            </remark>
            <remark>
            The command is mostly useful for statistics scripts (like counting cubes with certain attributes), but is can also
            be used for scripted editing, as the following (useless) example shows: selectionwalk [ += sw_floor (rnd 2) ]
            </remark>
          </remarks>
          <arguments>
            <argument token="action" description="action"/>
            <argument token="beginsel" description="begin action before cubes action of each selection" optional="true"/>
            <argument token="endsel" description="end action before cubes action of each selection" optional="true"/>
          </arguments>
          <references>
            <identifierReference identifier="select"/>
            <identifierReference identifier="addselection"/>
          </references>
        </command>

        <scriptalias name="pushselections">
          <description>Stores the positions of all current selections.</description>
          <remarks>
            <remark>Can be used repeatedly. To restore the selections, type "popselections".</remark>
          </remarks>
          <references>
            <identifierReference identifier="select"/>
            <identifierReference identifier="addselection"/>
          </references>
        </scriptalias>

        <command name="scalelights">
          <description>Scales all lights in the map.</description>
          <remarks>
            <remark>This command is useful if a map is too dark or bright but you want to keep the light entities where they are.</remark>
          </remarks>
          <arguments>
            <argument token="S" description="size change (percentage)"/>
            <argument token="I" description="intensity change (percentage)"/>
          </arguments>
        </command>

        <variable name="editing">
          <description>A variable indicating if the game is in editmode.</description>
          <value description="editmode in singleplayer" minValue="0" maxValue="1" defaultValue="0" readOnly="true" valueNotes="1 (true), 0 (false)"/>
          <references>
            <identifierReference identifier="editing_sp"/>
          </references>
        </variable>

        <variable name="editing_sp">
          <description>A variable indicating if the game is in singleplayer editmode.</description>
          <value description="editmode" minValue="0" maxValue="1" defaultValue="0" readOnly="true" valueNotes="1 (true), 0 (false)"/>
          <references>
            <identifierReference identifier="editing"/>
          </references>
        </variable>

        <variable name="flrceil">
          <description>A variable indicating if the player looks at the floor or at the ceiling.</description>
          <value description="flrceil" minValue="0" maxValue="2" defaultValue="0" readOnly="true" valueNotes="0 (floor), 2 (ceiling)"/>
        </variable>

        <scriptalias name="onNewMap">
          <description>This alias will automatically be executed when a new map is created via the "newmap" command.</description>
          <remarks>
            <remark>Does not affect the loading of an existing map.</remark>
          </remarks>
          <references>
            <identifierReference identifier="newmap"/>
            <identifierReference identifier="mapstartonce"/>
            <identifierReference identifier="mapstartalways"/>
          </references>
        </scriptalias>

        <variable name="oldselstyle">
          <description>Enables or disables using squares to render the editing grid/current selection instead of triangles.</description>
          <value token="N" description="0 off, 1 on" minValue="0" maxValue="1" defaultValue="1"/>
        </variable>

        <command name="gotoposition">
          <description>Only in edit mode: gets and sets camera position.</description>
          <remarks>
            <remark>Returns x, y, z, yaw and pitch. Sets x, y, z, yaw and pitch, if the parameter is not an empty string.</remark>
          </remarks>
          <arguments>
            <argument token="x" description="X coordinate" valueNotes="float"/>
            <argument token="y" description="Y coordinate" valueNotes="float"/>
            <argument token="z" description="Z coordinate" valueNotes="float"/>
            <argument token="yaw" description="yaw" valueNotes="integer"/>
            <argument token="pitch" description="pitch" valueNotes="integer"/>
          </arguments>
          <examples>
            <example>
              <code><![CDATA[echo (gotoposition)]]></code>
              <explanation>Output: 67.7 78.6 5.5 8 0</explanation>
            </example>
            <example>
              <code><![CDATA[gotoposition "" "" "" 180 0]]></code>
              <explanation>Change yaw and pitch to look straight in +y direction.</explanation>
            </example>
          </examples>
        </command>

        <command name="setvantagepoint">
          <description>Sets vantage point in current camera position.</description>
          <remarks>
            <remark>
            The vantage point is supposed to be a distinctive view on a map - like the angle from which the preview picture
            was taken. It is allowed to use when editing offline or spectating offline.
            </remark>
            <remark>A map can only have one vantage point.</remark>
          </remarks>
          <references>
            <identifierReference identifier="gotovantagepoint"/>
            <identifierReference identifier="getvantagepoint"/>
            <identifierReference identifier="clearvantagepoint"/>
          </references>
        </command>

        <command name="getvantagepoint">
          <description>Returns string with coordinates of vantage point or empty string, if none is set.</description>
          <references>
            <identifierReference identifier="setvantagepoint"/>
            <identifierReference identifier="gotovantagepoint"/>
            <identifierReference identifier="clearvantagepoint"/>
          </references>
        </command>

        <command name="gotovantagepoint">
          <description>Sets camera position in vantage point.</description>
          <remarks>
            <remark>It returns 1, if the map actually has a vantage point set.</remark>
          </remarks>
          <references>
            <identifierReference identifier="setvantagepoint"/>
            <identifierReference identifier="getvantagepoint"/>
            <identifierReference identifier="clearvantagepoint"/>
          </references>
        </command>

        <command name="clearvantagepoint">
          <description>Clears a set parameters of vantage point.</description>
          <references>
            <identifierReference identifier="setvantagepoint"/>
            <identifierReference identifier="getvantagepoint"/>
            <identifierReference identifier="gotovantagepoint"/>
          </references>
        </command>

        <command name="showmapstats">
          <description>Prints some map statistics.</description>
        </command>

        <command name="showmapdims">
          <description>Prints map dimensions.</description>
        </command>

        <variable name="unsavededits">
          <description>Holds the number of unsaved edits.</description>
        </variable>

        <command name="mapmodelslotname">
          <description>Returns the map model name (and path) of the mapmodel registered in the given slot number in the map config file.</description>
          <arguments>
            <argument token="N" description="mapmodel slot number"/>
          </arguments>
          <references>
            <identifierReference identifier="mapmodel"/>
            <identifierReference identifier="mapmodelslotbyname"/>
            <identifierReference identifier="mapmodelslotusage"/>
            <identifierReference identifier="editmapmodelslot"/>
            <identifierReference identifier="deletemapmodelslot"/>
          </references>
        </command>

        <command name="mapmodelslotbyname">
          <description>Returns the slot number registered in the map config file of the model with the given name.</description>
          <arguments>
            <argument token="M" description="mapmodel name (with path)"/>
          </arguments>
          <examples>
            <example>
              <code><![CDATA[echo (mapmodelslotbyname "mapmodels/makke/platform_bridge")]]></code>
              <explanation>Output: 5</explanation>
            </example>
          </examples>
          <references>
            <identifierReference identifier="mapmodel"/>
            <identifierReference identifier="mapmodelslotname"/>
            <identifierReference identifier="mapmodelslotusage"/>
            <identifierReference identifier="editmapmodelslot"/>
            <identifierReference identifier="deletemapmodelslot"/>
          </references>
        </command>

        <command name="mapmodelslotusage">
          <description>Returns a list of map entity indices which use a certain mapmodel slot.</description>
          <remarks>
            <remark>If the mapmodel is unused, it returns an empty string.</remark>
            <remark>
            It returns a single space, if the model slot is not used by any map entity,
            but is required by another model (with entities).
            </remark>
          </remarks>
          <arguments>
            <argument token="N" description="mapmodel slot number"/>
          </arguments>
          <references>
            <identifierReference identifier="mapmodel"/>
            <identifierReference identifier="mapmodelslotname"/>
            <identifierReference identifier="mapmodelslotbyname"/>
            <identifierReference identifier="editmapmodelslot"/>
            <identifierReference identifier="deletemapmodelslot"/>
          </references>
        </command>

        <command name="editmapmodelslot">
          <description>Edits the parameters of a mapmodel slot.</description>
          <remarks>
            <remark>Edits the parameters of a mapmodel slot. Only non-empty parameters actually change something.</remark>
            <remark>
            The command returns the resulting data of the mapmodel slot. If only the mapmodel slot number is specified,
            no changes are made, but the current data is returned (also in non-edit mode).
            Therefore the command can be used to get and set parameters.
            </remark>
            <remark>If anything is changed, automapconfig is enabled.</remark>
          </remarks>
          <arguments>
            <argument token="N" description="mapmodel slot number" valueNotes="integer"/>
            <argument token="R" description="radius" valueNotes="integer"/>
            <argument token="H" description="height" valueNotes="integer"/>
            <argument token="Z" description="z-offset" valueNotes="integer"/>
            <argument token="0" description="redundant, leave it at zero so you don't break the command" valueNotes="0"/>
            <argument token="P" description="mapmodel path" valueNotes="string"/>
          </arguments>
          <examples>
            <example>
              <code><![CDATA[editmapmodelslot 33 "" "" -5]]></code>
              <explanation>sets the z-offset of slot #33 to -5 without affecting other parameters</explanation>
            </example>
            <example>
              <code><![CDATA[echo (editmapmodelslot 33)]]></code>
              <explanation>prints the current parameters of mapmodel slot #33 , for example: 0 0 0 0 "makke/lightbulb"</explanation>
            </example>
          </examples>
          <references>
            <identifierReference identifier="mapmodel"/>
            <identifierReference identifier="mapmodelslotname"/>
            <identifierReference identifier="mapmodelslotbyname"/>
            <identifierReference identifier="mapmodelslotusage"/>
            <identifierReference identifier="deletemapmodelslot"/>
            <identifierReference identifier="mapmodelchanged"/>
          </references>
        </command>

        <command name="deletemapmodelslot">
          <description>Deletes an unused mapmodel slot.</description>
          <remarks>
            <remark>
            If "purge" is specified as second argument, it also deletes an used slot
            (including all map entities which use that mapmodel).
            </remark>
            <remark>Also it enables automapconfig.</remark>
          </remarks>
          <arguments>
            <argument token="N" description="mapmodel slot number"/>
            <argument token="P" description="purge"/>
          </arguments>
          <references>
            <identifierReference identifier="mapmodel"/>
            <identifierReference identifier="mapmodelslotname"/>
            <identifierReference identifier="mapmodelslotbyname"/>
            <identifierReference identifier="mapmodelslotusage"/>
            <identifierReference identifier="editmapmodelslot"/>
            <identifierReference identifier="mapmodelchanged"/>
          </references>
        </command>

        <command name="sortmapmodelslots">
          <description>Sorts all mapmoodel slots alphabetically and merges identical slots.</description>
          <remarks>
            <remark>
            By default, the list is sorted and only unused identical (with the same model and parameters) slots are merged.
            The keywords can be combined in any order. "nomerge" takes priority over "mergeused".
            </remark>
          </remarks>
          <examples>
            <example>
              <code><![CDATA[sortmapmodelslots]]></code>
              <explanation>
              - sorts the mapmodel slot list alphabetically and merge unused identical slots. Merging an unused slot is
              pretty much the same as deleting it, so this command sorts the list and removes unneeded double entries
              </explanation>
            </example>
            <example>
              <code><![CDATA[sortmapmodelslots nosort]]></code>
              <explanation>- merges (deletes) unused double entries in the mapmodel slot list</explanation>
            </example>
            <example>
              <code><![CDATA[sortmapmodelslots nosort mergeused]]></code>
              <explanation>
              - merges double entries in the mapmodel slot list. If two identical entries are used in the map,
              all uses are mapped to the new combined slot. This leaves no visual changes on the map.
              Should be avoided, if mapmodel slots have been renamed manually - and the renaming isn't finished yet
              </explanation>
            </example>
            <example>
              <code><![CDATA[sortmapmodelslots mergeused]]></code>
              <explanation>- sorts the mapmodel slot list and merges all double entries</explanation>
            </example>
          </examples>
          <arguments>
            <argument token="nosort" description="do not sort the list alphabetically" optional="true"/>
            <argument token="nomerge" description="do not merge any slots" optional="true"/>
            <argument token="mergeused" description="merge used and unused (identical) slots freely" optional="true"/>
          </arguments>
          <references>
            <identifierReference identifier="mapmodel"/>
            <identifierReference identifier="sorttextureslots"/>
            <identifierReference identifier="sortmapsoundslots"/>
          </references>
        </command>

        <variable name="mapmodelchanged">
          <description>Set to "1" with every command that changes mapmodel slots.</description>
          <value token="N" description="0: not changed, 1: changed" minValue="0" maxValue="1" defaultValue="0"/>
          <remarks>
            <remark>Should be used to trigger a rebuild of mapmodel menus.</remark>
          </remarks>
          <references>
            <identifierReference identifier="mapmodel"/>
            <identifierReference identifier="editmapmodelslot"/>
            <identifierReference identifier="deletemapmodelslot"/>
          </references>
        </variable>

        <command name="mapmodelregister">
          <description>Adds values for all attributes to a specific mapmodel.</description>
          <remarks>
            <remark>
            This is used to restore the cached values from config/mapmodelattributes.cfg during game start.
            It does not actually verify of load the model.
            </remark>
          </remarks>
          <arguments>
            <argument token="P" description="model path" valueNotes=""/>
            <argument token="V" description="list of all attribute values" valueNotes=""/>
          </arguments>
          <references>
            <identifierReference identifier="mapmodel"/>
            <identifierReference identifier="getmapmodelattributes"/>
            <identifierReference identifier="listallmapmodelattributes"/>
            <identifierReference identifier="mdlattribute"/>
            <identifierReference identifier="mapmodelregisterclear"/>
          </references>
        </command>

        <command name="mapmodelregistryclear">
          <description>Deletes all loaded mapmodel attributes.</description>
          <references>
            <identifierReference identifier="mapmodel"/>
            <identifierReference identifier="mapmodelregister"/>
            <identifierReference identifier="getmapmodelattributes"/>
            <identifierReference identifier="listallmapmodelattributes"/>
            <identifierReference identifier="mdlattribute"/>
            <identifierReference identifier="loadallmapmodels"/>
          </references>
        </command>

        <command name="getmapmodelattributes">
          <description>Returns values for all attributes to a specific mapmodel.</description>
          <remarks>
            <remark>
            If modelpath is a number, it is interpreted as index for the list of models in the current map config.
            If no attribute name is specified, all attributes are printed to the console instead.
            </remark>
          </remarks>
          <arguments>
            <argument token="P" description="model path" valueNotes=""/>
            <argument token="N" description="attribute name" optional="true" valueNotes="keywords, desc, defaults, usage, author, license, distribution, version"/>
          </arguments>
          <references>
            <identifierReference identifier="mapmodel"/>
            <identifierReference identifier="listallmapmodelattributes"/>
            <identifierReference identifier="mapmodelregister"/>
            <identifierReference identifier="mdlattribute"/>
          </references>
        </command>

        <command name="listallmapmodelattributes">
          <description>Returns a table of all known mapmodels.</description>
          <remarks>
            <remark>
            Each model is listed with the modelpath and the values for the requested attributes.
            To be used instead of a fixed table in menu_edit.cfg.
            </remark>
            <remark>
            In addition to attribute names, the function also allows the keywords "explodekeywords" and "sortby:" as arguments.
            If "explodekeywords" is given, all mapmodels with more than one keyword are listed multiple times, once for each keyword.
            If an attribute name is preceeded by "sortby:" the list will be sorted by this table column.
            If "sortby:" is used several times, this first sort will have highest priority.
            The list is always sorted by path by default.
            </remark>
          </remarks>
          <arguments>
            <argument token="N" description="list of attribute names" valueNotes="explodekeywords, sortby: keywords, desc, defaults, usage, author, license, distribution, version"/>
          </arguments>
          <examples>
            <example>
              <code><![CDATA[listallmapmodelattributes sortby: author sortby: desc explodekeywords]]></code>
            </example>
          </examples>
          <references>
            <identifierReference identifier="mapmodel"/>
            <identifierReference identifier="getmapmodelattributes"/>
            <identifierReference identifier="mapmodelregister"/>
            <identifierReference identifier="mdlattribute"/>
          </references>
        </command>

        <command name="loadallmapmodels">
          <description>Tries to load mapmodels from all paths below packages/models/mapmodels.</description>
          <remarks>
            <remark>
            It will throw a lot of error messages, because not all directories contain models to load.
            This command can be used to build or rebuild the complete list of all available mapmodels.
            It is only necessary, if models are added manually to the directories, since every mapmodel gets added to the list
            when it is loaded - which takes care of all automatically downloaded models.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="mapmodel"/>
            <identifierReference identifier="mapmodelregistryclear"/>
          </references>
        </command>

        <scriptalias name="mapmodelzoff">
          <description>Allows negative z-offsets for mapmodels.</description>
          <remarks>
            <remark>
            A mapmodel entity is placed at a z-coordinate that is based on the floor height of map geometry
            and a z-offset. The z-offset is a sum of the entity attribute 3 and the third mapmodel slot parameter.
            The entity z-offset can range from 0 to 255 while the mapmodel slot parameter can be any integer including negative numbers.
            So, to place a mapmodel below floor height, the mapmodel slot parameter has to be negative.
            </remark>
            <remark>
            "mapmodelzoff" script decreases the mapmodel slot parameter by one and increases the z-offset of every mapmodel
            which uses that slot also by one. This means, that all mapmodel are exact in the same place afterwards
            - but the entity z-offset now has room to lower the mapmodel by one more cube.
            </remark>
            <remark>If you need more z-offset available, run the script several times.</remark>
          </remarks>
          <arguments>
            <argument token="N" description="mapmodel slot number"/>
          </arguments>
        </scriptalias>

        <command name="gettexturelist">
          <description>Returns a table of all texture files fitting a certain description.</description>
          <remarks>
            <remark>All files found under packages/textures are examined.</remark>
            <remark>
            By default, the command returns a list with two columns: path and filename.
            If "excludes" is exactly one path prefix to exclude, the table gets a third column with path names without that prefix.
            If "extensions" is exactly one extension which does not start with the character '.',
            the table gets an additional (third or fourth) column containing file names without that extension.
            </remark>
          </remarks>
          <arguments>
            <argument token="includes" description="Optional list of path prefixes to include in the table."/>
            <argument token="excludes" description="Optional list of path prefixes to exclude from the table."/>
            <argument token="extensions" description="Optional list of filename extensions to include in the table."/>
          </arguments>
          <examples>
            <example>
              <code><![CDATA[echo (gettexturelist)]]></code>
              <explanation>Outputs two columns like "noctua/wall" "wall02.jpg"</explanation>
            </example>
            <example>
              <code><![CDATA[echo (gettexturelist "" "map_editor skymaps")]]></code>
              <explanation>Outputs two columns like "noctua/wall" "wall02.jpg", but omits skymaps and special textures for the editor</explanation>
            </example>
            <example>
              <code><![CDATA[echo (gettexturelist makke)]]></code>
              <explanation>Outputs only textures by makke and adds a third column like "makke/rattrap" "rb_box_03.jpg" "/rattrap"</explanation>
            </example>
            <example>
              <code><![CDATA[echo (gettexturelist "skymaps/" "" "_ft.jpg")]]></code>
              <explanation>
              Outputs four columns like "skymaps/egypt" "egypt_ft.jpg" "egypt" "egypt",
              "skymaps/humus" "meadow_ft.jpg" "humus" "meadow"
              </explanation>
            </example>
          </examples>
          <references>
            <identifierReference identifier="texture"/>
            <identifierReference identifier="gettextureorigin"/>
          </references>
        </command>

        <command name="gettextureorigin">
          <description>Returns the location where the texture file actually can be found.</description>
          <remarks>
            <remark>The possibilities are:</remark>
            <remark>"official": texture file was found in the working directory, which indicates an official texture.</remark>
            <remark>"custom": texture file was found in the profile directory, which means, the texture is either manually installed or downloaded.</remark>
            <remark>"package dir #x": texture file was found in a mod directory.</remark>
            <remark>"&lt;file not found&gt;"</remark>
          </remarks>
          <arguments>
            <argument token="N" description="filename or partial path with filename"/>
          </arguments>
          <references>
            <identifierReference identifier="texture"/>
            <identifierReference identifier="gettexturelist"/>
          </references>
        </command>

        <command name="textureslotbyname">
          <description>Returns the list of numbers of all texture slots which use that texture file.</description>
          <arguments>
            <argument token="N" description="texture filename"/>
          </arguments>
          <references>
            <identifierReference identifier="texture"/>
            <identifierReference identifier="textureslotusage"/>
            <identifierReference identifier="textureslotusagelist"/>
            <identifierReference identifier="edittextureslot"/>
            <identifierReference identifier="deletetextureslot"/>
            <identifierReference identifier="edittexturestack"/>
          </references>
        </command>

         <command name="textureslotusage">
          <description>Returns a list of mapmodels who use that texture as skin.</description>
          <remarks>
            <remark>If no mapmodel uses the texture, but world geometry does, a string of whitespace is returned. If the mapmodel is unused, an empty string is returned.</remark>
          </remarks>
          <arguments>
            <argument token="N" description="texture slot number" valueNotes="0..255"/>
          </arguments>
          <references>
            <identifierReference identifier="texture"/>
            <identifierReference identifier="textureslotusagelist"/>
            <identifierReference identifier="textureslotbyname"/>
            <identifierReference identifier="edittextureslot"/>
            <identifierReference identifier="deletetextureslot"/>
            <identifierReference identifier="edittexturestack"/>
          </references>
        </command>

        <command name="textureslotusagelist">
          <description>Returns a list of 256 numbers representing the number of uses for every texture slot.</description>
          <remarks>
            <remark>If "what" is "onlygeometry", the uses as map model skin do not count.</remark>
            <remark>If "what" is "onlymodels", the uses in map geometry do not count.</remark>
            <remark>It returns two values per slot: usage and visibility.</remark>
            <remark>
            If "what" is "onlymostvisible", instead of the regular list, a list of only the most used wall, floor,
            ceiling and upper wall textures (alternating with the keywords) is returned.
            </remark>
          </remarks>
          <examples>
            <example>
              <code><![CDATA[echo (textureslotusagelist onlymostvisible)]]></code>
              <explanation>Output: wall 211 floor 45 ceiling 0 "upper wall" 79</explanation>
            </example>
          </examples>
          <arguments>
            <argument token="W" description="what" valueNotes="onlygeometry, onlymodels, onlymostvisible"/>
          </arguments>
          <references>
            <identifierReference identifier="texture"/>
            <identifierReference identifier="textureslotusage"/>
            <identifierReference identifier="textureslotbyname"/>
            <identifierReference identifier="edittextureslot"/>
            <identifierReference identifier="deletetextureslot"/>
            <identifierReference identifier="edittexturestack"/>
          </references>
        </command>

        <command name="deletetextureslot">
          <description>Deletes an unused texture slot.</description>
          <remarks>
            <remark>
            If "purge" word is put as second argument, it also deletes an used slot.
            All mapmodels that use that texture as skin are changed to default skin.
            All world geometry, which uses the texture, is instead set to use slot #255 or a specified replacement slot.
            Slots below #5 always require "purge", no matter if they are in use (default slots).
            </remark>
            <remark>Also enables automapconfig.</remark>
          </remarks>
          <arguments>
            <argument token="N" description="texture slot number" valueNotes="0..255"/>
            <argument token="P" description="delete used slot?" valueNotes="purge"/>
            <argument token="R" description="replacement slot" valueNotes="0..255"/>
          </arguments>
          <references>
            <identifierReference identifier="texture"/>
            <identifierReference identifier="textureslotusage"/>
            <identifierReference identifier="textureslotusagelist"/>
            <identifierReference identifier="textureslotbyname"/>
            <identifierReference identifier="edittextureslot"/>
            <identifierReference identifier="edittexturestack"/>
          </references>
        </command>

        <command name="edittextureslot">
          <description>Edits the parameters of a texture slot.</description>
          <remarks>
            <remark>
            Only non-empty parameters actually change something. The command returns the resulting data of the texture slot.
            If only the texture slot number is specified, no changes are made, but the current data is returned
            (also in non-edit mode). Therefore the command can be used to get and set parameters.
            </remark>
            <remark>If anything is changed, automapconfig is enabled.</remark>
          </remarks>
          <arguments>
            <argument token="N" description="texture slot number" valueNotes="0..255"/>
            <argument token="S" description="scale" valueNotes=""/>
            <argument token="P" description="path" valueNotes=""/>
          </arguments>
          <examples>
            <example>
              <code><![CDATA[edittextureslot 33 "" "arcitool/rohbaubims.jpg"]]></code>
              <explanation>Sets texture name of slot #33</explanation>
            </example>
            <example>
              <code><![CDATA[echo (edittextureslot 33)]]></code>
              <explanation>Prints the current parameters of texture slot #33, for example: 0 "zastrow/3wood_crate_10.jpg"</explanation>
            </example>
          </examples>
          <references>
            <identifierReference identifier="texture"/>
            <identifierReference identifier="textureslotusage"/>
            <identifierReference identifier="textureslotusagelist"/>
            <identifierReference identifier="textureslotbyname"/>
            <identifierReference identifier="deletetextureslot"/>
            <identifierReference identifier="edittexturestack"/>
          </references>
        </command>

        <command name="edittexturestack">
          <description>Puts a texture slot in a "last used" list up front.</description>
          <remarks>
            <remark>The first parameter picks the list, the second parameter is the texture slot number to be used for the next edit.</remark>
          </remarks>
          <arguments>
            <argument token="S" description="surface" valueNotes="floor, wall or ceiling"/>
            <argument token="N" description="texture slot number" valueNotes="0..255"/>
          </arguments>
          <references>
            <identifierReference identifier="texture"/>
            <identifierReference identifier="textureslotusage"/>
            <identifierReference identifier="textureslotusagelist"/>
            <identifierReference identifier="textureslotbyname"/>
            <identifierReference identifier="deletetextureslot"/>
            <identifierReference identifier="edittextureslot"/>
          </references>
        </command>

        <command name="sorttextureslots">
          <description>Sorts all texture slots alphabetically and merges identical slots.</description>
          <remarks>
            <remark>
            By default, the list is sorted (except the first five) and only unused identical
            (with the same texture and scale factor) slots are merged.
            The keywords can be combined in any order. "nomerge" takes priority over "mergeused".
            </remark>
            <remark>
            It allows to manually sort also the first few slots by adding the slot number to move to the slots #1, #2, #3, #4
            (for example "sorttextureslots 11 12 13 14" will move slot #11 to slot #1, #12 to #2, #13 to #3 and #14 to #4,
            and sort the rest texture slots).
            </remark>
            <remark>See examples in the "sortmapmodelslots" reference.</remark>
          </remarks>
          <arguments>
            <argument token="nosort" description="do not sort the list alphabetically" optional="true"/>
            <argument token="nomerge" description="do not merge any slots" optional="true"/>
            <argument token="mergeused" description="merge used and unused (identical) slots freely" optional="true"/>
          </arguments>
          <references>
            <identifierReference identifier="texture"/>
            <identifierReference identifier="sortmapmodelslots"/>
            <identifierReference identifier="sortmapsoundslots"/>
          </references>
        </command>

        <command name="getmapsoundlist">
          <description>Returns a list of all *.wav and *.ogg files below packages/audio/ambience.</description>
          <references>
            <identifierReference identifier="mapsound"/>
            <identifierReference identifier="getmapsoundorigin"/>
          </references>
        </command>

        <command name="getmapsoundorigin">
          <description>Returns the location where the map sound file actually can be found.</description>
          <remarks>
            <remark>The possibilities are:</remark>
            <remark>"official": mapsound file was found in the working directory, which indicates an official mapsound.</remark>
            <remark>"custom": mapsound file was found in the profile directory, which means, the mapsound is either manually installed or downloaded.</remark>
            <remark>"package dir #x": mapsound file was found in a mod directory.</remark>
            <remark>"&lt;file not found&gt;"</remark>
          </remarks>
          <arguments>
            <argument token="N" description="filename or partial path with filename"/>
          </arguments>
          <references>
            <identifierReference identifier="mapsound"/>
            <identifierReference identifier="getmapsoundlist"/>
          </references>
        </command>

        <command name="mapsoundslotbyname">
          <description>Returns the list of numbers of all mapsound slots which use that sound file.</description>
          <arguments>
            <argument token="N" description="map sound filename"/>
          </arguments>
          <references>
            <identifierReference identifier="mapsound"/>
            <identifierReference identifier="mapsoundslotusage"/>
            <identifierReference identifier="editmapsoundslot"/>
            <identifierReference identifier="deletemapsoundslot"/>
          </references>
        </command>

        <command name="mapsoundslotusage">
          <description>Returns a list of map entity indices which use a certain map sound slot.</description>
          <remarks>
            <remark>If the sound is unused, it returns an empty string.</remark>
          </remarks>
          <arguments>
            <argument token="N" description="map sound slot number"/>
          </arguments>
          <references>
            <identifierReference identifier="mapsound"/>
            <identifierReference identifier="mapsoundslotbyname"/>
            <identifierReference identifier="editmapsoundslot"/>
            <identifierReference identifier="deletemapsoundslot"/>
          </references>
        </command>

        <command name="editmapsoundslot">
          <description>Edits path/name and maxuses parameters of a mapsound slot.</description>
          <remarks>
            <remark>
            Only non-empty parameters actually change something. The command returns the resulting data of the map sound slot.
            If only the map sound slot number is specified, no changes are made, but the current data is returned
            (also in non-edit mode). Therefore the command can be used to get and set parameters.
            </remark>
            <remark>If anything is changed, automapconfig is enabled.</remark>
          </remarks>
          <arguments>
            <argument token="N" description="map sound slot number"/>
            <argument token="P" description="map sound path"/>
            <argument token="M" description="maxuses"/>
          </arguments>
          <references>
            <identifierReference identifier="mapsound"/>
            <identifierReference identifier="mapsoundslotbyname"/>
            <identifierReference identifier="mapsoundslotusage"/>
            <identifierReference identifier="deletemapsoundslot"/>
            <identifierReference identifier="mapsoundchanged"/>
          </references>
        </command>

        <command name="deletemapsoundslot">
          <description>Deletes an unused map sound slot.</description>
          <remarks>
            <remark>
            If "purge" is specified as second argument, it also deletes an used slot
            (including all map entities which use that sound).
            </remark>
            <remark>Also it enables automapconfig.</remark>
          </remarks>
          <arguments>
            <argument token="N" description="map sound slot number"/>
            <argument token="P" description="purge"/>
          </arguments>
          <references>
            <identifierReference identifier="mapsound"/>
            <identifierReference identifier="mapsoundslotbyname"/>
            <identifierReference identifier="mapsoundslotusage"/>
            <identifierReference identifier="editmapsoundslot"/>
            <identifierReference identifier="mapsoundchanged"/>
          </references>
        </command>

        <command name="sortmapsoundslots">
          <description>Sorts all mapsound slots alphabetically and merges identical slots.</description>
          <remarks>
            <remark>
            By default, the list is sorted and only unused identical slots are merged.
            The keywords can be combined in any order. "nomerge" takes priority over "mergeused".
            </remark>
            <remark>See examples in the "sortmapmodelslots" reference.</remark>
          </remarks>
          <arguments>
            <argument token="nosort" description="do not sort the list alphabetically" optional="true"/>
            <argument token="nomerge" description="do not merge any slots" optional="true"/>
            <argument token="mergeused" description="merge used and unused (identical) slots freely" optional="true"/>
          </arguments>
          <references>
            <identifierReference identifier="mapsound"/>
            <identifierReference identifier="sortmapmodelslots"/>
            <identifierReference identifier="sorttextureslots"/>
          </references>
        </command>

        <variable name="mapsoundchanged">
          <description>Set to "1" with every command that changes mapsound slots.</description>
          <value token="N" description="0: not changed, 1: changed" minValue="0" maxValue="1" defaultValue="0"/>
          <remarks>
            <remark>Should be used to trigger a rebuild of mapsound menus.</remark>
          </remarks>
          <references>
            <identifierReference identifier="mapsound"/>
            <identifierReference identifier="editmapsoundslot"/>
            <identifierReference identifier="deletemapsoundslot"/>
          </references>
        </variable>

        <command name="automapconfig">
          <description>Enables the "automatic embedded map config data" feature.</description>
          <remarks>
            <remark>With the next map save the map config file will get renamed and the map config data stored inside the map file.</remark>
          </remarks>
          <references>
            <identifierReference identifier="getautomapconfig"/>
            <identifierReference identifier="embedconfigfile"/>
            <identifierReference identifier="extractconfigfile"/>
            <identifierReference identifier="listheaderextras"/>
          </references>
        </command>

        <command name="getautomapconfig">
          <description>Returns "1" if automapconfig is already enabled, "0" otherwise.</description>
          <references>
            <identifierReference identifier="automapconfig"/>
          </references>
        </command>

        <command name="embedconfigfile">
          <description>Loads the map config file, includes it in the map header and renames the original config file.</description>
          <remarks>
            <remark>Embedded config files take precedence over regular config files.</remark>
          </remarks>
          <references>
            <identifierReference identifier="automapconfig"/>
            <identifierReference identifier="extractconfigfile"/>
            <identifierReference identifier="listheaderextras"/>
          </references>
        </command>

        <command name="extractconfigfile">
          <description>Writes an embedded config file to a separate file and removes it from the map header.</description>
          <references>
            <identifierReference identifier="automapconfig"/>
            <identifierReference identifier="embedconfigfile"/>
          </references>
        </command>

        <command name="listheaderextras">
          <description>Returns a list with additional data ("header extras") from current map header.</description>
          <remarks>
            <remark>
            The header extras can be permanent, like the embedded config file, or can be used only once after map load,
            like the undo/redo data. Additional extra data can be easily added and will not break backward compatibility.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="automapconfig"/>
            <identifierReference identifier="embedconfigfile"/>
          </references>
        </command>

        <command name="addentity">
          <description>Adds an entity of the specified type at the current camera position.</description>
          <remarks>
            <remark>It also returns the index number of the new entity, so that the other attributes can be set by editentity.</remark>
          </remarks>
          <arguments>
            <argument token="E" description="the entity type or number" valueNotes="light (1), playerstart (2), pistol (3), ammobox (4), grenades (5), health (6), helmet (7), armour (8), akimbo (9), mapmodel (10), ladder (12), ctf-flag (13), sound (14), clip (15), plclip (16)"/>
          </arguments>
          <references>
            <identifierReference identifier="enumentities"/>
            <identifierReference identifier="editentity"/>
            <identifierReference identifier="deleteentity"/>
          </references>
        </command>

        <command name="editentity">
          <description>Edits a map entity.</description>
          <remarks>
            <remark>
            It edits only parameters given a non-empty value. Returns the type and the values of all attributes (x, y, z, attr1 - attr7).
            It uses float values for some attributes, return values also may be float.
            </remark>
          </remarks>
          <arguments>
            <argument token="N" description="entity index/number" valueNotes=""/>
            <argument token="A" description="list of attributes" valueNotes="" optional="true"/>
          </arguments>
          <examples>
            <example>
              <code><![CDATA[echo (editentity 33)]]></code>
              <explanation>Prints all attributes of map entity number 33, for example "light 174 172 12  20 255 200 200 0 0 0"</explanation>
            </example>
            <example>
              <code><![CDATA[editentity 33 "" 173]]></code>
              <explanation>Changes the y-position of entity 33 to 173</explanation>
            </example>
          </examples>
          <references>
           <identifierReference identifier="entset"/>
            <identifierReference identifier="enumentities"/>
            <identifierReference identifier="addentity"/>
            <identifierReference identifier="deleteentity"/>
          </references>
        </command>

        <command name="deleteentity">
          <description>Deletes a map entity.</description>
          <remarks>
            <remark>Note: deleting an entity only marks it as unused. It will be completely removed after saving and loading the map.</remark>
          </remarks>
          <arguments>
            <argument token="N" description="entity index/number" valueNotes=""/>
          </arguments>
          <references>
            <identifierReference identifier="delent"/>
            <identifierReference identifier="clearents"/>
            <identifierReference identifier="enumentities"/>
            <identifierReference identifier="addentity"/>
            <identifierReference identifier="editentity"/>
            <identifierReference identifier="undelent"/>
            <identifierReference identifier="getdeletedentities"/>
            <identifierReference identifier="unlistdeletedentity"/>
          </references>
        </command>

        <command name="enumentities">
          <description>Returns a list of the numbers of all entities of that type.</description>
          <remarks>
            <remark>If no such entities exist or the entity type could not be recognised, the list is empty.</remark>
          </remarks>
          <arguments>
            <argument token="type" description="the entity type" valueNotes="light, sound, clip, plclip, playerstart, pistol, ammobox, grenades, health, armour, akimbo, mapmodel, ladder, ctf-flag, helmet"/>
          </arguments>
          <references>
            <identifierReference identifier="gotoentity"/>
            <identifierReference identifier="addentity"/>
            <identifierReference identifier="editentity"/>
            <identifierReference identifier="deleteentity"/>
          </references>
        </command>

        <command name="gotoentity">
          <description>Jump to the location of a map entity.</description>
          <remarks>
            <remark>You can get the entity number with use "enumentities" command.</remark>
          </remarks>
          <arguments>
            <argument token="N" description="the entity number" valueNotes=""/>
          </arguments>
          <references>
            <identifierReference identifier="enumentities"/>
          </references>
        </command>

        <command name="getclosestent">
          <description>Returns the entity index number of the closest entity (or of the pinned entity, if one exists).</description>
          <remarks>
            <remark>Returns -1, if no entities are on the map.</remark>
            <remark>Returns always exactly the entity, that edit commands like delent will use next.</remark>
          </remarks>
          <references>
            <identifierReference identifier="toggleclosestentpin"/>
            <identifierReference identifier="entproperty"/>
            <identifierReference identifier="getentattr"/>
            <identifierReference identifier="getenttype"/>
          </references>
        </command>

        <command name="toggleclosestentpin">
          <description>Toggles the pin on the "closest entity" selector.</description>
          <remarks>
            <remark>
            The HUD will indicate the lock by showing "pinned" instead of "closest" entity.
            All actions, that would otherwise affect the closest entity, will affect the pinned entity instead.
            Deleting the locked entity will unlock it.
            </remark>
          </remarks>
          <defaultKeys>
            <key alias="MOUSE3" name="middle mouse button"/>
          </defaultKeys>
          <references>
            <identifierReference identifier="getclosestent"/>
          </references>
        </command>

        <variable name="pointatent">
          <description>Enables or disables pointing at entity sparklies.</description>
          <value token="B" description="boolean" minValue="0" maxValue="1" valueNotes="0: nearest, 1: pointed at" defaultValue="0"/>
          <remarks>
            <remark>If an entity is pointed at during disabling, it is pinned.</remark>
          </remarks>
          <references>
            <identifierReference identifier="pointatentmaxangle"/>
            <identifierReference identifier="toggleclosestentpin"/>
          </references>
        </variable>

        <variable name="pointatentmaxangle">
          <description>Specifies the required precision for pointing at entities sparklies.</description>
          <value token="N" description="0: not changed, 1: changed" minValue="0.01" maxValue="180.0" defaultValue="2.0" valueNotes="float"/>
          <references>
            <identifierReference identifier="pointatent"/>
          </references>
        </variable>

        <variable name="edithideentmask">
          <description>Integer variable containing a bitmask of hidden entity types.</description>
        </variable>

        <command name="getdeletedentities">
          <description>Returns a list of deleted entities.</description>
          <remarks>
            <remark>Each line contains the entity type, the position and all seven attributes.</remark>
          </remarks>
          <references>
            <identifierReference identifier="undelent"/>
            <identifierReference identifier="unlistdeletedentity"/>
            <identifierReference identifier="deleteentity"/>
          </references>
        </command>

        <command name="undelent">
          <description>Restores deleted entity.</description>
          <remarks>
            <remark>
            If no index is specified, the last deleted entity is restored.
            If an index is given, the specified entity from the list of deleted entities is restored.
            </remark>
            <remark>BACKSPACE in combination with editmeta undeletes the last deleted entity.</remark>
            <remark>BACKSPACE in combination with editmeta2 brings up the menu "deleted entities".</remark>
          </remarks>
          <arguments>
            <argument token="I" description="index"/>
          </arguments>
          <references>
            <identifierReference identifier="getdeletedentities"/>
            <identifierReference identifier="unlistdeletedentity"/>
            <identifierReference identifier="deleteentity"/>
            <identifierReference identifier="editmeta"/>
            <identifierReference identifier="editmeta2"/>
          </references>
        </command>

        <command name="unlistdeletedentity">
          <description>Removes entities from the list of deleted entities.</description>
          <remarks>
            <remark>If &lt;which&gt; is a number, the specified entry from the list of deleted entities gets removed.</remark>
            <remark>If &lt;which&gt; is "all", the whole list of deleted entities gets deleted.</remark>
            <remark>If &lt;which&gt; is "last" the last deleted entity is removed from the list of deleted entities.</remark>
            <remark>Returns the number of entities on the list of deleted entities (even if the parameter &lt;which&gt; was unknown or not specified).</remark>
          </remarks>
          <arguments>
            <argument token="W" description="which" valueNotes="[a number], all or last"/>
          </arguments>
          <references>
            <identifierReference identifier="getdeletedentities"/>
            <identifierReference identifier="undelent"/>
            <identifierReference identifier="deleteentity"/>
          </references>
        </command>

        <command name="xmap_list">
          <description>Lists all xmaps currently in memory.</description>
          <references>
            <identifierReference identifier="xmap_store"/>
            <identifierReference identifier="xmap_restore"/>
            <identifierReference identifier="xmap_delete"/>
            <identifierReference identifier="xmap_delete_backup"/>
            <identifierReference identifier="xmap_keep_backup"/>
            <identifierReference identifier="xmap_rename"/>
            <identifierReference identifier="getxmaplist"/>
            <identifierReference identifier="enumtodoentities"/>
          </references>
        </command>

        <command name="xmap_store">
          <description>Creates a snapshot and stores it under the given nickname.</description>
          <remarks>
            <remark>Nicknames have to qualify as valid filenames.</remark>
          </remarks>
          <arguments>
            <argument token="N" description="nickname"/>
          </arguments>
          <references>
            <identifierReference identifier="xmap_list"/>
            <identifierReference identifier="xmap_restore"/>
          </references>
        </command>

        <command name="xmap_restore">
          <description>Restores the xmap snapshot.</description>
          <remarks>
            <remark>1. If nickname is not given, it restores the last automatic backup snapshot. Automatic snapshots are taken:</remark>
            <remark>a) before a snapshot is restored,</remark>
            <remark>b) before a new map is loaded (if there were unsaved edits on the map) and</remark>
            <remark>c) when the game ends (if there were unsaved edits).</remark>
            <remark>2. If nickname is given, the command restores the named snapshot, it also creates a backup snapshot of the current editing data.</remark>
          </remarks>
          <arguments>
            <argument token="N" description="nickname"/>
          </arguments>
          <references>
            <identifierReference identifier="xmap_list"/>
            <identifierReference identifier="xmap_store"/>
          </references>
        </command>

        <command name="xmap_delete">
          <description>Deletes the named snapshot.</description>
          <arguments>
            <argument token="N" description="nickname"/>
          </arguments>
          <references>
            <identifierReference identifier="xmap_list"/>
          </references>
        </command>

        <command name="xmap_delete_backup">
          <description>Deletes the backup xmap.</description>
          <references>
            <identifierReference identifier="xmap_list"/>
          </references>
        </command>

        <command name="xmap_keep_backup">
          <description>Moves the backup xmap to a regular named spot.</description>
          <arguments>
            <argument token="N" description="nickname"/>
          </arguments>
          <references>
            <identifierReference identifier="xmap_list"/>
          </references>
        </command>

        <command name="xmap_rename">
          <description>Changes the nickname of the xmap.</description>
          <arguments>
            <argument token="O" description="old nickname"/>
            <argument token="N" description="new nickname"/>
          </arguments>
          <references>
            <identifierReference identifier="xmap_list"/>
          </references>
        </command>

        <command name="getxmaplist">
          <description>Returns a list of all regular xmaps in memory, or, if 'what' is "bak", the details of a stored backup xmap.</description>
          <remarks>
            <remark>Each xmap is listed with nickname and description.</remark>
          </remarks>
          <arguments>
            <argument token="w" description="what" valueNotes="bak" optional="true"/>
          </arguments>
          <references>
            <identifierReference identifier="xmap_list"/>
          </references>
        </command>

        <command name="addtodoentity">
          <description>Adds the entity #index to the TODO list.</description>
          <remarks>
            <remark>
            Entity errors during map load are automatically added to the list.
            The list is saved and restored with xmaps.
            </remark>
          </remarks>
          <arguments>
            <argument token="I" description="index"/>
            <argument token="C" description="comment" optional="true"/>
          </arguments>
          <references>
            <identifierReference identifier="cleartodoentities"/>
            <identifierReference identifier="enumtodoentities"/>
          </references>
        </command>

        <command name="cleartodoentities">
          <description>Clears list of TODO entities.</description>
          <remarks>
            <remark>The list is also deleted, when a new map is loaded.</remark>
            <remark>If an entity number is given as an argument, only entries for this entity are cleared.</remark>
          </remarks>
          <arguments>
            <argument token="I" description="index" optional="true"/>
          </arguments>
          <references>
            <identifierReference identifier="addtodoentity"/>
            <identifierReference identifier="enumtodoentities"/>
          </references>
        </command>

        <command name="enumtodoentities">
          <description>Returns a list of TODO entities.</description>
          <remarks>
            <remark>Returns entity index number and comment for every entry.</remark>
          </remarks>
          <references>
            <identifierReference identifier="addtodoentity"/>
            <identifierReference identifier="cleartodoentities"/>
            <identifierReference identifier="xmap_list"/>
          </references>
        </command>

        <variable name="showplayerstarts">
          <description>Show all playerstarts in edit mode.</description>
          <remarks>
            <remark>Set showplayerstarts to "1" to see a playermodel rendered at all playerstart entities.</remark>
          </remarks>
          <value token="N" description="0: hide, 1: show" minValue="0" maxValue="1" defaultValue="0"/>
        </variable>

        <command name="mapmrproper">
          <description>Cleanups hidden map attributes.</description>
          <remarks>
            <remark>
            "mapmrproper" tries to optimize hidden attributes of maps in a way, that the map can be handled in bigger chunks by the renderer.
            </remark>
            <remark>
            The mipmapping routine does not take into account, if certain textures of a cube are visible at all, when it collects otherwise identical cubes to be handled en-bloc.
            "mapmrproper" changes invisible textures in a way, that the cubes are in fact identical - so, that the mipmapper is satisfied.
            The optimizer does not change any map properties that are visible in any way.</remark>
            <remark>
            Before any changes are made, mapmrproper creates a backup, which can be restored by "undo" command.
            Enable mipstats ("showmip" command), to see, what has been done.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="showmip"/>
          </references>
        </command>

        <command name="calcmipstats">
          <description>Counts all the mips in the current map and prints their numbers as 1x1/2x2/4x4/8x8/16x16/32x32/64x64.</description>
          <references>
            <identifierReference identifier="showmip"/>
          </references>
        </command>

        <command name="editmeta">
          <description>First modifier key for editing mode.</description>
          <remarks>
            <remark>Go to references mentioned below to see the use.</remark>
          </remarks>
          <defaultKeys>
            <key alias="LCTRL" name="left Ctrl"/>
          </defaultKeys>
          <references>
            <identifierReference identifier="addselection"/>
            <identifierReference identifier="entproperty"/>
            <identifierReference identifier="undelent"/>
            <identifierReference identifier="pasteent"/>
            <identifierReference identifier="editmetakeydown"/>
            <identifierReference identifier="editmeta2"/>
          </references>
        </command>

        <command name="editmeta2">
          <description>Second modifier key for editing mode.</description>
          <remarks>
            <remark>Go to references mentioned below to see the use.</remark>
          </remarks>
          <defaultKeys>
            <key alias="LCTRL" name="left Shift"/>
          </defaultKeys>
          <references>
            <identifierReference identifier="entproperty"/>
            <identifierReference identifier="undelent"/>
            <identifierReference identifier="editmeta2down"/>
            <identifierReference identifier="editmeta"/>
          </references>
        </command>

        <variable name="editmetakeydown">
          <description>Indicates if editmeta key is pressed.</description>
          <value description="state of the first editmeta key" minValue="0" maxValue="1" defaultValue="0" readOnly="true" valueNotes="0: unpressed, 1: pressed"/>
          <references>
            <identifierReference identifier="editmeta"/>
          </references>
        </variable>

        <variable name="editmeta2down">
          <description>Indicates if second editmeta key is pressed.</description>
          <value description="state of the second editmeta key" minValue="0" maxValue="1" defaultValue="0" readOnly="true" valueNotes="0: unpressed, 1: pressed"/>
          <references>
            <identifierReference identifier="editmeta2"/>
          </references>
        </variable>

        <variable name="rereadtexturelists">
          <description>Variable, which is set to "1" when a texture is downloaded.</description>
          <remarks>
            <remark>Used to trigger menu rebuilds.</remark>
          </remarks>
          <value token="N" description="is texture downloaded?" minValue="0" maxValue="1" defaultValue="1" valueNotes="0: no, 1: yes"/>
          <references>
            <identifierReference identifier="rereadsoundlists"/>
          </references>
        </variable>

        <variable name="rereadsoundlists">
          <description>Variable, which is set to "1" when a sound is downloaded.</description>
          <remarks>
            <remark>Used to trigger menu rebuilds.</remark>
          </remarks>
          <value token="N" description="is sound downloaded?" minValue="0" maxValue="1" defaultValue="1" valueNotes="0: no, 1: yes"/>
          <references>
            <identifierReference identifier="rereadtexturelists"/>
          </references>
        </variable>

        <command name="mapareacheck">
          <description>Calculates some key values to determine map geometry viability.</description>
          <remarks>
            <remark>It returns different sets of statistics, depending on the keyword "what":</remark>
            <remark>
            "vdelta" - returns table of numbers of cubes within a certain range of vdelta
            differences (steepness). First entry is "0..2 cubes steep", next is "2..4" and so on.
            </remark>
            <remark>"steepest" - returns the coordinates of the steepest heightfield cube.</remark>
            <remark>"total" - returns the number of non-solid cubes on the map.</remark>
            <remark>"pprest" - returns the number of cubes _not_ visible from one of the probe positions.</remark>
            <remark>
            "pp" (default) - returns a table of all (currently 64) probe points of the map. Each probe point is listed with:
            x-coordinate, y-coordinate, floor height, area visible, volume of visible area, average height in visible area.
            </remark>
          </remarks>
          <arguments>
            <argument token="W" description="what" valueNotes="vdelta, steepest, total, pprest, pp (default)"/>
          </arguments>
        </command>

        <command name="getmaptimestamp">
          <description>Returns the "last written" timestamp of the current map in the requested format.</description>
          <remarks>
            <remark>
            If "fmt" starts with "U", the time is given as UTC, otherwise as local time. If "fmt" is empty,
            or not given or just the "U", the format defaults to "YYYYMMDD_hh.mm.ss". Use "%c" to get something nicer.
            </remark>
            <remark>The same format options as in strftime().</remark>
          </remarks>
          <arguments>
            <argument token="fmt" description="format" valueNotes="strftime format"/>
          </arguments>
        </command>

        <variable name="_ignoreillegalpaths">
          <description>Whether or not texture paths are scrutinized.</description>
          <value token="B" description="boolean" minValue="0" maxValue="1" valueNotes="1:yes=>ignore" defaultValue="0"/>
          <remarks>
            <remark>If during mapload textureslots can't be filled and this is not set to 1 a "missing media" error is raised.</remark>
            <remark>It is used in the optional cubescript config/opt/convmap.cfg</remark>
          </remarks>
          <references>
            <identifierReference identifier="loadnotexture"/>
          </references>
        </variable>

        <command name="stairs">
          <description>Places stairs in all selections.</description>
          <remarks>
            <remark>"xs" and "ys" determine the step width in x- and y-direction.</remark>
          </remarks>
          <arguments>
            <argument token="xs" description="step width in x-direction" valueNotes=""/>
            <argument token="ys" description="step width in y-direction" valueNotes=""/>
          </arguments>
        </command>

        <scriptalias name="updateeditinfopanel">
          <description>A cubescript hook to provide additional information about the current edit situation.</description>
          <remarks>
            <remark>For example it provides additional information about the closest entity.</remark>
            <remark>The returned text is rendered on the right side of the screen.</remark>
            <remark>
            Default for "updateeditinfopanel" is "explainclosestentity" script which provides detailed info about
            the closest entity.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="editinfopanelmillis"/>
            <identifierReference identifier="hideeditinfopanel"/>
          </references>
        </scriptalias>

        <variable name="editinfopanelmillis">
          <description>Update the edit info panel every N milliseconds.</description>
          <value token="N" description="milliseconds" minValue="5" maxValue="2000" defaultValue="80" valueNotes="integer"/>
          <references>
            <identifierReference identifier="updateeditinfopanel"/>
            <identifierReference identifier="hideeditinfopanel"/>
          </references>
        </variable>

        <variable name="hideeditinfopanel">
          <description>Hide the edit info panel.</description>
          <value token="N" description="0: show, 1: hide" minValue="0" maxValue="1" defaultValue="0"/>
          <references>
            <identifierReference identifier="updateeditinfopanel"/>
            <identifierReference identifier="editinfopanelmillis"/>
          </references>
        </variable>

        <variable name="hideeditslotinfo">
          <description>Hide the closest entity filename info.</description>
          <value token="N" description="0: show info always, 1: only show &quot;unassigned slot&quot; if necessary, 2: never show info" minValue="0" maxValue="2" defaultValue="0"/>
        </variable>

        <command name="mapartist">
          <description>Adds artist info to a map.</description>
          <arguments>
            <argument token="N" description="Prints the map artist player ID" valueNotes="print"/>
            <argument description="Sets the map artist player ID to the player currently logged in" valueNotes="set"/>
            <argument description="Returns the current map artist player ID" valueNotes="get"/>
            <argument description="Erases an existing map artist record in the current map" valueNotes="clear"/>
          </arguments>
          <references>
            <identifierReference identifier="modeinfo"/>
          </references>
        </command>

        <command name="modeinfo">
          <description>Adds modeinfo info to a map.</description>
          <remarks>
            <remark>
            See possibilities of mode list and flags (keywords) in config/maprot.cfg file.
            To use flags for all modes you can use "all" value instead of mode list.
            </remark>
          </remarks>
          <arguments>
            <argument token="N" description="Lists current modeinfo entries" valueNotes="list"/>
            <argument description="Returns list of current modeinfo entries" valueNotes="get"/>
            <argument description="Erases current list of modeinfo entries" valueNotes="clear"/>
            <argument description="Specifies flags for a list of modes" valueNotes="&lt;modelist&gt; &lt;modeflags&gt;"/>
          </arguments>
          <references>
            <identifierReference identifier="mapartist"/>
          </references>
        </command>

        <command name="showtagclipfocus">
          <description>Show the volume of a focused clip entity as a cloud of sparklies.</description>
          <arguments>
            <argument token="B" description="on/off" valueNotes="0:off,1:on" defaultValue="0"/>
          </arguments>
          <defaultKeys>
            <key alias="B" name="B" description="while pressed clips are clouds of sparklies"/>
          </defaultKeys>
          <remarks>
            <remark>To see the volume rather than the boundaries of a clip entity you can hold the B key in editing mode while pointing at it.</remark>
          </remarks>
        </command>

        <command name="updatemapmodeldependencies">
          <description>Update map config with any mapmodels required by those in use.</description>
        </command>

        <variable name="editingsettingsvisibletime">
          <description>How long the temporary bits of showeditingsettings are displayed.</description>
          <value token="T" description="time" minValue="750" maxValue="75000" valueNotes="time in milliseconds" defaultValue="7500"/>
          <remarks>
            <remark>Slide in/out the boxes and/or text of the showeditingsettings display.</remark>
          </remarks>
          <references>
            <identifierReference identifier="showeditingsettings"/>
          </references>
        </variable>

        <variable name="showeditingsettings">
          <description>A visual representation of hidden/shown entities. (may be used for more editing ephemerals later)</description>
          <value token="P" description="persistence" minValue="0" maxValue="3" valueNotes="0:off(*),1:short,2:text-short,3:permanent" defaultValue="0"/>
          <remarks>
            <remark>If the value of edithideentmask is not 0 (meaning all entities shown) then even if showeditingsettings is 0 the display will show up on the first toggle into editmode.</remark>
            <remark>The values 1, 2 and 3 will make the display show up for every time you start editing. With 3 it will stay for ever.</remark>
            <remark>For 2 the text will disappear after a time but the boxes will stay for ever. For 1 everything is hidden after the duration of editingsettingsvisibletime.</remark>
          </remarks>
          <references>
            <identifierReference identifier="edithideentmask"/>
            <identifierReference identifier="editingsettingsvisibletime"/>
          </references>
        </variable>

        <variable name="shadowyaw">
          <description>Shadow yaw specifies the angle at which shadow stencils are drawn on a map.</description>
          <value token="D" description="degrees" minValue="0" maxValue="360" valueNotes="The angle in degrees to rotate the stencil shadows" defaultValue="45"/>
          <examples>
            <example>
              <code><![CDATA[shadowyaw 90]]></code>
            </example>
          </examples>
          <remarks>
            <remark>
            When specifying shadowyaw, remember that the default angle is 45 degrees. The example below
            would make the shadows appear at 90 degrees (45 degrees more to the left).
            </remark>
          </remarks>
        </variable>

        <variable name="tagcliplinewidth">
          <description>The width of the tagclip lines.</description>
          <value token="W" description="width" minValue="0.2" maxValue="3" defaultValue="1"/>
          <references>
            <identifierReference identifier="showtagclips"/>
            <identifierReference identifier="showtagclipfocus"/>
          </references>
        </variable>

        <variable name="worldiodebug">
          <description>Whether or not to output debugging information while loading/saving maps.</description>
          <value token="B" description="boolean" minValue="0" maxValue="1" valueNotes="1:debug output" defaultValue="0"/>
        </variable>

        <variable name="_nextentityispasted">
          <description>Set to 1 just before calling a newent command where all attributes are meant to be kept.</description>
          <value token="B" description="boolean" minValue="0" maxValue="1" valueNotes="1:yes=>keep attribute values" defaultValue="0"/>
          <remarks>
            <remark>It is used in the pasteent scripting.</remark>
            <remark>When creating a new entity of type mapmodel, playerstart or CTF flag the orientation is taken from your current viewing angle. To disable this behaviour for one call only you set the value to of this to 1 and then issue your newentity call with all attributes given.</remark>
          </remarks>
          <references>
            <identifierReference identifier="loadnotexture"/>
          </references>
        </variable>

        </identifiers>
    </section>

    <!-- Editing Section Ends -->
    <!-- Menus Section Starts -->
    <section name="Menus" sortindex="13">
      <description>This section describes identifiers related to the menu gui.</description>
      <identifiers sort="true">

        <command name="menuinit">
          <description>Specifies commands to be executed when a menu opens.</description>
          <references>
            <identifierReference identifier="newmenu"/>
          </references>
          <remarks>
            <remark>This command should be placed after newmenu.</remark>
          </remarks>
          <arguments>
            <argument token="C" description="the code to execute on init"/>
          </arguments>
        </command>

        <command name="newmenu">
          <description>Creates a new menu.</description>
          <references>
            <identifierReference identifier="menuitem"/>
          </references>
          <remarks>
            <remark>
            All menu commands placed after newmenu (i.e. menuitem, menuitemcheckbox, etc.) are added
            into the menu until another "newmenu" command is specified.
            </remark>
          </remarks>
          <arguments>
            <argument token="N" description="the name of the menu"/>
          </arguments>
        </command>

        <command name="menuitem">
          <description>Creates a new menuitem.</description>
          <remarks>
            <remark>
            Upon activating the menuitem, the associated command will be executed (See config/menus.cfg for examples).
            If the command argument is omitted, then it will be set to the same value as the description.
            If -1 is specified instead of the command to execute, then no command is executed when activating the item.
            If the rollover option is used, the menuitem will execute that command when selecting (but not activating) the menuitem.
            </remark>
            <remark>'\n' in menuitem synchronizes further text with slider width (tab-like function).</remark>
            <remark>(Note: to activate the menu item, select it, and either: Click, press SPACE or press ENTER/Return).</remark>
          </remarks>
          <references>
            <identifierReference identifier="newmenu"/>
            <identifierReference identifier="getigraph"/>
          </references>
          <arguments>
            <argument token="T" description="the text content in menu line"/>
            <argument token="A" description="the command to execute on selection of the menuitem" optional="true"/>
            <argument token="H" description="the command to execute upon rolling over the menuitem" optional="true"/>
            <argument token="D" description="the description of menu item, which is displayed on the menu footer" optional="true"/>
          </arguments>
        </command>

        <command name="menuinitselection">
          <description>Defines the initial selection for a menu.</description>
          <arguments>
            <argument token="A" description="line number"/>
          </arguments>
        </command>

        <command name="menuitemaltfont">
          <description>Displays a menu line with a text which may contain chars from an alternate font.</description>
          <remarks>
            <remark>
            Chars from the alternate font have to be marked with "\a".
            Alternate font chars have no width and are just rendered above the following text. Use spaces to counter that.
            </remark>
          </remarks>
          <arguments>
            <argument token="N" description="the name of the alternate font" valueNotes="default, mono, serif, huddigits, serverquality, bargraphs, radaricons"/>
            <argument token="T" description="text content in menu line"/>
            <argument token="A" description="action" optional="true"/>
            <argument token="H" description="hoveraction" optional="true"/>
            <argument token="D" description="description displayed on menu footer" optional="true"/>
          </arguments>
          <references>
            <identifierReference identifier="font"/>
          </references>
        </command>

        <command name="menuselection">
          <description>Selects a line in a menu.</description>
          <arguments>
            <argument token="A" description="menu name"/>
            <argument token="B" description="line number"/>
          </arguments>
        </command>

        <command name="menuselectionpersistent">
          <description>Enables persistent selections for the currently displayed menu.</description>
          <remarks>
            <remark>When enabled, it restores a previously saved selection.</remark>
            <remark>
            Probably most efficient inside "menuinit". The position is restored during execution of this command,
            so the menu entry has to already exist and the alias with the last position has to be read from saved.cfg.
            In automatically created menus it may be necessary to execute the command with a short delay.
            </remark>
          </remarks>
        </command>

        <command name="menuselectionbgcolor">
          <description>Defines the background color for the menu selection bar.</description>
          <arguments>
            <argument token="R" description="red" valueNotes="0..100"/>
            <argument token="G" description="green" valueNotes="0..100"/>
            <argument token="B" description="blue" valueNotes="0..100"/>
            <argument token="A" description="alpha" valueNotes="0..100"/>
          </arguments>
        </command>

        <command name="menuselectiondescbgcolor">
          <description>Defines the background color for the description of selected active menu items (checkbox, slider, text input).</description>
          <arguments>
            <argument token="R" description="red" valueNotes="0..100"/>
            <argument token="G" description="green" valueNotes="0..100"/>
            <argument token="B" description="blue" valueNotes="0..100"/>
            <argument token="A" description="alpha" valueNotes="0..100"/>
          </arguments>
        </command>

        <command name="menuitemcheckbox">
          <description>Creates a checkbox menu item.</description>
          <remarks>
            <remark>
            Optional fourth parameter "position" in the range from 0 o 100, default 0, which moves the position
            of the checkbox over the width of a text input or slider, with 100 being left and 0 being right.
            </remark>
          </remarks>
          <arguments>
            <argument token="T" description="text"/>
            <argument token="V" description="value"/>
            <argument token="A" description="action"/>
            <argument token="P" description="position" valueNotes="0..100" optional="true"/>
          </arguments>
        </command>

        <command name="menuitemimage">
          <arguments>
            <argument token="N" description="image filename"/>
            <argument token="T" description="text"/>
            <argument token="A" description="action"/>
            <argument token="H" description="hoveraction"/>
          </arguments>
        </command>

        <variable name="hidebigmenuimages">
          <description>Hide big images in menus.</description>
          <value token="N" description="0: show, 1: hide" minValue="0" maxValue="1" defaultValue="0"/>
        </variable>

        <command name="menuitemkeyinput">
          <description>Menuitem which displays "text" and all keys, that bind "bindcmd" - in game mode.</description>
          <arguments>
            <argument token="T" description="text"/>
            <argument token="B" description="bind command"/>
          </arguments>
          <references>
            <identifierReference identifier="menuitemeditkeyinput"/>
            <identifierReference identifier="menuitemspectkeyinput"/>
          </references>
        </command>

        <command name="menuitemeditkeyinput">
          <description>Menuitem which displays "text" and all keys, that bind "bindcmd" - in edit mode.</description>
          <arguments>
            <argument token="T" description="text"/>
            <argument token="B" description="bind command"/>
          </arguments>
          <references>
            <identifierReference identifier="menuitemkeyinput"/>
            <identifierReference identifier="menuitemspectkeyinput"/>
          </references>
        </command>

        <command name="menuitemspectkeyinput">
          <description>Menuitem which displays "text" and all keys, that bind "bindcmd" - in spectate mode.</description>
          <arguments>
            <argument token="T" description="text"/>
            <argument token="B" description="bind command"/>
          </arguments>
          <references>
            <identifierReference identifier="menuitemkeyinput"/>
            <identifierReference identifier="menuitemeditkeyinput"/>
          </references>
        </command>

        <command name="menuitemmapload">
          <description>Menuitem that loads a map, displays the title and the preview or a default image.</description>
          <arguments>
            <argument token="M" description="map"/>
            <argument token="A" description="action" optional="true"/>
            <argument token="H" description="hoveraction" optional="true"/>
            <argument token="D" description="description displayed on menu footer" optional="true"/>
          </arguments>
          <references>
            <identifierReference identifier="screenshotpreview"/>
          </references>
        </command>

        <command name="screenshotpreview">
          <description>Creates a screenshot cropped to 4:3 with a given number of lines and jpeg quality 80.</description>
          <remarks>
            <remark>Pressing CTRL+F12 during spectating creates a clean screenshot and saves it as map preview picture.</remark>
          </remarks>
          <defaultKeys>
            <key alias="CTRL+F12" name="Ctrl+F12" description="creates map preview pictures during spectating"/>
          </defaultKeys>
          <arguments>
            <argument token="N" description="number of lines"  valueNotes="144..480, default 240 or last given value"/>
          </arguments>
          <references>
            <identifierReference identifier="menuitemmapload"/>
          </references>
        </command>

        <command name="menuitemslider">
          <arguments>
            <argument token="T" description="text" valueNotes="menu item text"/>
            <argument token="L" description="min" valueNotes="min value"/>
            <argument token="U" description="max" valueNotes="max value (or optionally -1 and set by display string length)"/>
            <argument token="V" description="value" valueNotes="initial value"/>
            <argument token="D" description="display" valueNotes="list of value descriptions or value step size"/>
            <argument token="A" description="action" valueNotes="executed on value changes (new value in arg1)"/>
            <argument token="W" description="wrap" valueNotes="if 1, wrap slider around"/>
          </arguments>
        </command>

        <command name="menuitemradio">
          <arguments>
            <argument token="T" description="text" valueNotes="menu item text"/>
            <argument token="L" description="min" valueNotes="min value"/>
            <argument token="U" description="max" valueNotes="max value (or optionally -1 and set by display string length)"/>
            <argument token="V" description="value" valueNotes="initial value"/>
            <argument token="D" description="display" valueNotes="list of value descriptions or value step size"/>
            <argument token="A" description="action" valueNotes="executed on value changes (new value in arg1)"/>
          </arguments>
        </command>

        <command name="menuitemtextinput">
          <description>Creates a new menuitem with text input field.</description>
          <remarks>
            <remark>
            If the last line of a menu is a text input item, pressing enter in that line will not only execute 
            the assigned command, but also close the menu.
            </remark>
          </remarks>
          <arguments>
            <argument token="T" description="text"/>
            <argument token="V" description="value"/>
            <argument token="A" description="action"/>
            <argument token="H" description="hoveraction"/>
            <argument token="M" description="maxchars"/>
          </arguments>
        </command>

        <command name="menuitemgreyedout">
          <description>Menu items added after this command are greyed out (1) or not (0).</description>
          <remarks>
            <remark>Greyed out menu items are grey and can't be operated.</remark>
          </remarks>
          <arguments>
            <argument token="V" description="value" valueNotes="0: off 1: on"/>
          </arguments>
        </command>

        <command name="menuheader">
          <description>Adds header and/or footer to the menu.</description>
          <arguments>
            <argument token="H" description="header"/>
            <argument token="F" description="footer"/>
          </arguments>
        </command>

        <variable name="browsefiledesc">
          <description>Toggles getting descriptive text from CGZ or DMO files in menudirlist.</description>
          <value token="B" description="" minValue="0" maxValue="1" defaultValue="1"/>
          <references>
            <identifierReference identifier="menudirlist"/>
          </references>
        </variable>

        <command name="menudirlist">
          <description>Creates a menu listing of files from a path and perform an action on them when clicked.</description>
          <remarks>
            <remark>Use this inside menu definitions, almost always as the only command of that menu.</remark>
            <remark>Compare the usage inside config/menus.cfg</remark>
          </remarks>
          <arguments>
            <argument token="P" description="the directory path from the assaultcube root"/>
            <argument token="E" description="file extension"/>
            <argument token="A" description="action"/>
            <argument token="I" description="show image from a file" valueNotes="0 or 1"/>
            <argument token="S" description="string - search it in map/demo filenames and descriptions and show only matched files (case insensitive)"/>
          </arguments>
          <examples>
            <example>
              <code><![CDATA[menudirlist "packages/maps" "cgz" "map $arg1"]]></code>
              <explanation>will create a list of maps and load them when clicked</explanation>
            </example>
          </examples>
          <references>
            <identifierReference identifier="newmenu"/>
            <identifierReference identifier="menudirlistsub"/>
            <identifierReference identifier="browsefiledesc"/>
          </references>
        </command>

        <command name="menudirlistsub">
          <description>Adds subdirectory entries to a menu with a files list.</description>
          <remarks>
            <remark>It has to come after the menudirlist command.</remark>
          </remarks>
          <arguments>
            <argument token="A" description="action, executed, when the menu entry is chosen"/>
            <argument token="D" description="if it is 1, an entry '..' is added (parent directory)" optional="true"/>
          </arguments>
          <references>
            <identifierReference identifier="menudirlist"/>
          </references>
        </command>

        <command name="menufont">
          <description>Sets the font for a specific menu.</description>
          <remarks>
            <remark>If menu is "", the currently initialised menu is used.</remark>
          </remarks>
          <arguments>
            <argument token="N" description="menu name"/>
            <argument token="F" description="font" valueNotes="default, mono, serif"/>
          </arguments>
          <examples>
            <example>
              <code><![CDATA[menufont score mono]]></code>
              <explanation>sets the font on the scoreboard</explanation>
            </example>
          </examples>
          <references>
            <identifierReference identifier="font"/>
          </references>
        </command>

        <command name="showmenu">
          <description>Displays the specified menu.</description>
          <remarks>
            <remark>
            The menu allows the user to pick an item with the cursor keys.
            Upon pressing return, the associated action will be executed.
            Pressing ESC will cancel the menu.
            </remark>
          </remarks>
          <arguments>
            <argument token="N" description="the name of a previously defined menu"/>
          </arguments>
          <references>
            <identifierReference identifier="newmenu"/>
            <identifierReference identifier="closemenu"/>
            <identifierReference identifier="delmenu"/>
          </references>
        </command>

        <command name="closemenu">
          <description>Closes the specified menu if it is open.</description>
          <remarks>
            <remark>If it is open multiple times in the stack only the topmost instance will be closed!</remark>
          </remarks>
          <arguments>
            <argument token="N" description="the name of a previously defined menu"/>
          </arguments>
          <references>
            <identifierReference identifier="newmenu"/>
            <identifierReference identifier="showmenu"/>
            <identifierReference identifier="delmenu"/>
            <identifierReference identifier="closecurmenu"/>
          </references>
        </command>

        <command name="delmenu">
          <description>Deletes the entire contents (all menu items) of the given menu.</description>
          <arguments>
            <argument token="N" description="the name of a previously defined menu"/>
          </arguments>
          <references>
            <identifierReference identifier="newmenu"/>
            <identifierReference identifier="showmenu"/>
            <identifierReference identifier="closemenu"/>
          </references>
        </command>

        <command name="menumdl">
          <description>Specifies a model to render while displaying the specified menu.</description>
          <remarks>
            <remark>If menu is "", the currently initialised menu is used.</remark>
            <remark>It specifies, which model to render and how. If only menu is specified, no model is rendered.</remark>
          </remarks>
          <arguments>
            <argument token="N" description="the name of the menu"/>
            <argument token="M" description="the model"/>
            <argument token="A" description="the animation to play"/>
            <argument token="R" description="the rotation speed"/>
            <argument token="S" description="the scale"/>
          </arguments>
        </command>

        <command name="chmenutexture">
          <description>Displays a texture on the right side of a menu.</description>
          <remarks>
            <remark>
            By specifying a title string in the third argument to chmenutexture,
            a picture is rendered instead of a texture. The title string is displayed instead of the texture resolution.
            The variable "menupicturesize" holds a size modifier for pictures, similar to "menutexturesize".
            </remark>
          </remarks>
          <arguments>
            <argument token="N" description="the name of the menu"/>
            <argument token="P" description="the path to the texture"/>
            <argument token="T" description="the title of the picture"/>
          </arguments>
          <references>
            <identifierReference identifier="menutexturesize"/>
            <identifierReference identifier="menupicturesize"/>
          </references>
        </command>

        <variable name="menutexturesize">
          <description>Changes the size of textures displayed in menus (mostly for testing purposes).</description>
          <value token="N" description="size factor" minValue="0.1f" maxValue="5.0f" defaultValue="1.0f"/>
          <references>
            <identifierReference identifier="chmenutexture"/>
            <identifierReference identifier="menupicturesize"/>
          </references>
        </variable>

        <variable name="menupicturesize">
          <description>Changes the size of pictures displayed in menus.</description>
          <value token="N" description="size factor" minValue="0.1f" maxValue="5.0f" defaultValue="1.6f"/>
          <references>
            <identifierReference identifier="chmenutexture"/>
            <identifierReference identifier="menutexturesize"/>
          </references>
        </variable>

        <variable name="wrapslider">
          <description>If wrapslider is set the menuitemslider will toggle to the min/max value if at end of the range.</description>
          <value token="N" description="0 off, 1 on" minValue="0" maxValue="1" defaultValue="0"/>
        </variable>

        <command name="menucanblink">
          <description>Toggles the ability for menutext to have the blinking bit set.</description>
          <remarks>
            <remark>The global setting of 'allowblinkingtext' overrides this.</remark>
          </remarks>
          <arguments>
            <argument token="T" description="0 = Off, any other integer = On" valueNotes="Any integer is valid, positive or negative"/>
          </arguments>
          <references>
            <identifierReference identifier="allowblinkingtext"/>
          </references>
        </command>

        <command name="curmenu">
          <description>Returns the name of the currently open menu.</description>
          <remarks>
            <remark>If more than one menu is open, only the name of the topmost menu on the stack is returned.</remark>
          </remarks>
          <references>
            <identifierReference identifier="closecurmenu"/>
            <identifierReference identifier="refreshcurmenu"/>
            <identifierReference identifier="refreshcurmenudelayed"/>
          </references>
        </command>

        <command name="closecurmenu">
          <description>Closes the currently open menu.</description>
          <remarks>
            <remark>If more than one menu is open, only closes the topmost menu on the stack.</remark>
          </remarks>
          <references>
            <identifierReference identifier="curmenu"/>
            <identifierReference identifier="refreshcurmenu"/>
            <identifierReference identifier="refreshcurmenudelayed"/>
          </references>
        </command>

        <command name="refreshcurmenu">
          <description>Refreshes (closes and opens again) the current menu.</description>
          <references>
            <identifierReference identifier="curmenu"/>
            <identifierReference identifier="refreshcurmenudelayed"/>
            <identifierReference identifier="closecurmenu"/>
          </references>
        </command>

        <command name="refreshcurmenudelayed">
          <description>Refreshes (closes and opens again, after very short delay) the current menu.</description>
          <references>
            <identifierReference identifier="curmenu"/>
            <identifierReference identifier="refreshcurmenu"/>
            <identifierReference identifier="closecurmenu"/>
          </references>
        </command>

        <command name="menurenderoffset">
          <description>Moves a menu away from the middle of the screen.</description>
          <remarks>
            <remark>Values of "0" represent half the screen width and height.</remark>
          </remarks>
          <arguments>
            <argument token="X" description="x-offset"/>
            <argument token="Y" description="y-offset"/>
          </arguments>
        </command>

        <command name="menusynctabstops">
          <description>Synchronizes tabs in menus.</description>
          <remarks>
            <remark>
            If enabled (1), tab positions in a menu are synchronised.
            It affects menu title, header and items, but not footer or descriptions.
            </remark>
          </remarks>
          <arguments>
            <argument token="V" description="value" valueNotes="0: off (default), 1: on"/>
          </arguments>
        </command>

        <command name="menutitle">
          <description>Make a different title show up than the menu's internal name.</description>
          <arguments>
            <argument token="N" description="name" valueNotes="human friendly title"/>
          </arguments>
          <remarks>
            <remark>Intended to pretty up the menus with more readable titles than the sometimes short but technical values that make the scripting easier!</remark>
          </remarks>
          <references>
            <identifierReference identifier="newmenu"/>
            <identifierReference identifier="curmenu"/>
          </references>
        </command>

      </identifiers>
    </section>
    <!-- Menus Section Ends -->
    <!-- Heads-Up Display Section Starts -->
    <section name="Heads-Up Display" sortindex="06">
      <description>This section describes the identifiers to configure the head-up display (HUD).</description>
      <identifiers>

        <variable name="gametimedisplay">
          <description>Show the game-time clock on the HUD.</description>
          <value token="D" description="off (0), count backward (1), count forward (2)" minValue="0" maxValue="2" defaultValue="1"/>
          <remarks>
            <remark>The clock can count backward (from time limit to 0s) or forward (from 0s to time limit).</remark>
          </remarks>
          <references>
            <identifierReference identifier="wallclockformat"/>
          </references>
        </variable>

        <variable name="wallclockformat">
          <description>Show the wall clock with time (usually local, not game-time) on the HUD.</description>
          <remarks>
            <remark>"wallclockformat" alias should contain string in strftime format to show the clock with proper time.
            If the alias is empty, the wall clock is hidden.</remark>
          </remarks>
          <references>
            <identifierReference identifier="gametimedisplay"/>
          </references>
        </variable>

        <variable name="showmap">
          <description>Determines if the mini-map should be shown on screen.</description>
          <value token="B" description="show mini-map" minValue="0" maxValue="1" defaultValue="0"/>
          <defaultKeys>
            <key alias="LALT" name="left Alt" description="toggles minimap"/>
          </defaultKeys>
        </variable>

        <variable name="showmapbackdrop">
          <description>Determines whether to have a see-through map overview (0), or render it on a black backdrop (1) or a combination of both (2).</description>
          <value token="B" description="backdrop-style" minValue="0" maxValue="2" defaultValue="0"/>
        </variable>

        <variable name="showmapbackdroptransparency">
          <description>Transparency of the black map backdrop (in percent) rendered if showmapbackdrop is set to 2.</description>
          <value token="T" description="transparency" minValue="0" maxValue="100" defaultValue="75"/>
          <references>
            <identifierReference identifier="showmapbackdrop"/>
          </references>
        </variable>

        <command name="clearminimap">
          <description>Recreates the minimap for the current map.</description>
          <references>
            <identifierReference identifier="minimapres"/>
          </references>
        </command>

        <variable name="minimapres">
          <description>Sets the resolution for the minimap.</description>
          <references>
            <identifierReference identifier="clearminimap"/>
          </references>
          <value token="N" description="the resolution" minValue="7" maxValue="10" defaultValue="9"/>
        </variable>

        <variable name="hidecompass">
          <description>Turns on/off the radar compass.</description>
          <value token="V" description="enable/disable radar compass" minValue="0" maxValue="1" defaultValue="0"/>
        </variable>

        <variable name="hidedamageindicator">
          <description>Turns on/off the damage indicator.</description>
          <value token="V" description="enable/disable damage indicator" minValue="0" maxValue="1" defaultValue="0"/>
        </variable>

        <variable name="oldfashionedgunstats">
          <description>Shows ammo statistics like in version 1.0.</description>
          <value token="N" description="0: new, 1: old" minValue="0" maxValue="1" defaultValue="0"/>
        </variable>

        <command name="toggleconsole">
          <description>Toggles the console.</description>
          <defaultKeys>
            <key alias="F11"/>
          </defaultKeys>
        </command>

        <variable name="confade">
          <description>Sets how many seconds before the console text rolls (disappears) up the screen.</description>
          <value token="V" description="time before the text rolls up" minValue="0" maxValue="60" defaultValue="20"/>
        </variable>

        <variable name="consize">
          <description>Sets how many lines of text the console displays.</description>
          <value token="V" description="" minValue="0" maxValue="100" defaultValue="6"/>
          <references>
            <identifierReference identifier="altconsize"/>
            <identifierReference identifier="fullconsize"/>
          </references>
        </variable>

        <variable name="altconsize">
          <description>Sets the percent of screen height for text lines on an alternate F11 history display.</description>
          <value token="V" description="" minValue="0" maxValue="100" defaultValue="0"/>
          <references>
            <identifierReference identifier="consize"/>
            <identifierReference identifier="fullconsize"/>
          </references>
        </variable>

        <variable name="fullconsize">
          <description>Sets the percent of screen height for text lines on the F11 history display.</description>
          <value token="V" description="" minValue="0" maxValue="100" defaultValue="40"/>
          <references>
            <identifierReference identifier="consize"/>
            <identifierReference identifier="altconsize"/>
          </references>
        </variable>

        <variable name="hideconsole">
          <description>Turns on or off the display of console text.</description>
          <value token="V" description="enable/disable console text" minValue="0" maxValue="1" defaultValue="0"/>
        </variable>

        <variable name="hidehudequipment">
          <description>Turns on or off the display of equipment icons.</description>
          <value token="V" description="enable/disable equipment icons" minValue="0" maxValue="1" defaultValue="0"/>
        </variable>

        <variable name="hidehudmsgs">
          <description>Turns on or off the display of messages at the bottom of the screen.</description>
          <value token="V" description="enable/disable messages" minValue="0" maxValue="1" defaultValue="0"/>
        </variable>

        <variable name="hidespecthud">
          <description>Turns on or off the display of spectator status.</description>
          <value token="V" description="enable/disable spectator status" minValue="0" maxValue="1" defaultValue="0"/>
        </variable>

        <variable name="hideteamscorehud">
          <description>Turns on or off the display of team score icons.</description>
          <value token="V" description="enable/disable team score icons" minValue="0" maxValue="1" defaultValue="0"/>
        </variable>

        <variable name="flagscorehudtransparency">
          <description>Options for flag score hud transparency.</description>
          <value token="V" description="flag score hud transparency" minValue="0" maxValue="2" defaultValue="2"
          valueNotes=" 0: no transparency, icon set 'flag gone'; 1: transparency, icon set 'flag gone'; 2: transparency, classic icon set"/>
        </variable>

        <variable name="hidektfindicator">
          <description>Turns on or off the display of ktf flag direction indicator.</description>
          <value token="V" description="enable/disable ktf indicator" minValue="0" maxValue="1" defaultValue="0"/>
          <references>
            <identifierReference identifier="ktfindicatoralpha"/>
          </references>
        </variable>

        <variable name="ktfindicatoralpha">
        <description>Sets the level of transparency of ktf flag direction indicator, 100 = totally solid.</description>
          <value token="V" description="ktf indicator alpha value" minValue="1" maxValue="100" defaultValue="70"/>
          <references>
            <identifierReference identifier="hidektfindicator"/>
          </references>
        </variable>

        <variable name="hideteam">
          <description>Turns on or off the display of local player team icons.</description>
          <value token="V" description="enable/disable team icons" minValue="0" maxValue="1" defaultValue="0"/>
        </variable>

        <variable name="hideradar">
          <description>Turns on or off the display of the on-screen radar.</description>
          <value token="V" description="enable/disable radar" minValue="0" maxValue="1" defaultValue="0"/>
        </variable>

        <variable name="hidevote">
          <description>Turns on or off the display of vote icons.</description>
          <value token="V" description="0=on; 1=on, but hide after own vote; 2=off" minValue="0" maxValue="2" defaultValue="0"/>
        </variable>

        <variable name="hudgun">
          <description>Turns on or off the display of the current selected gun.</description>
          <value token="V" description="show/hide guns 3D models" minValue="0" maxValue="1" defaultValue="1"/>
        </variable>

        <variable name="specthudgun">
          <description>Turns on/off the display of the hudgun while spectating a player in first-person view.</description>
          <remarks>
            <remark>Works in demo mode as well.</remark>
          </remarks>
          <value token="V" description="show/hide hudgun when spectating" minValue="0" maxValue="1" defaultValue="1"/>
        </variable>

        <variable name="showstats">
          <description>Turns on/off display of FPS/rendering statistics on the HUD.</description>
          <value token="N" description="0: Show no stats, 1: Only show FPS stats, 2: Show all stats" minValue="0" maxValue="2" defaultValue="1"/>
        </variable>

        <variable name="dbgpos">
          <description>Displays local player's current x,y,z position in map, showstats 1 must be enabled.</description>
          <value token="V" description="display current position" minValue="0" maxValue="1" defaultValue="0"/>
          <references>
            <identifierReference identifier="showstats"/>
          </references>
        </variable>

        <variable name="crosshairteamsign">
          <description>Turns on/off display of team warning crosshair.</description>
          <value token="V" description="enable/disable warning crosshair" minValue="0" maxValue="1" defaultValue="1"/>
        </variable>

        <variable name="damageindicatoralpha">
          <description>Sets the level of transparency of the damage indicator, 100 = totally solid.</description>
          <value token="V" description="damage indicator alpha value" minValue="1" maxValue="100" defaultValue="50"/>
        </variable>

        <variable name="damageindicatordist">
          <description>Sets the separation of the arrows in the damage indicator.</description>
          <value token="V" description="damage indicator separation size" minValue="0" maxValue="10000" defaultValue="500"/>
        </variable>

        <variable name="damageindicatorsize">
          <description>Sets the size of the damage indicator.</description>
          <value token="V" description="damage indicator icon size" minValue="0" maxValue="10000" defaultValue="200"/>
        </variable>

        <variable name="damageindicatortime">
          <description>Sets how long the damage indicator stays on screen.</description>
          <value token="V" description="damage indicator display time" minValue="1" maxValue="10000" defaultValue="1000"/>
        </variable>

        <variable name="damagescreen">
          <description>Show the blood-spat overlay when receiving damage?</description>
          <value token="N" description="damagescreen" minValue="0" maxValue="1" defaultValue="1" valueNotes="0 (false), 1 (true)"/>
        </variable>

        <variable name="damagescreenalpha">
          <description>If overlay of blood-spat, at what blending (transparency) level?</description>
          <value token="N" description="damagescreen transparency" minValue="1" maxValue="100" defaultValue="45"/>
        </variable>

        <variable name="damagescreenfactor">
          <description>If overlay of blood-spat, use which factor?</description>
          <value token="N" description="damagescreen factor" minValue="1" maxValue="100" defaultValue="7"/>
        </variable>

        <variable name="damagescreenfade">
          <description>If overlay of blood-spat, at what speed does it fade?</description>
          <value token="N" description="damagescreen fade" minValue="0" maxValue="1000" defaultValue="125"/>
        </variable>

        <variable name="crosshairsize">
          <description>Sets the size of your crosshair.</description>
          <remarks>
            <remark>The crosshair is turned off entirely if the size is set to 0.</remark>
          </remarks>
          <value token="N" description="the crosshair size" minValue="0" maxValue="50" defaultValue="15"/>
        </variable>

        <variable name="crosshairfx">
          <description>Turns on or off crosshair effects.</description>
          <remarks>
            <remark>
            When on, the crosshair will go orange when health is 50 or red when is 25.
            Size change of crosshair occurs when player holds assault rifle and has more than 3 shots in a row.
            </remark>
          </remarks>
          <arguments>
            <argument token="V" valueNotes="0" description="turn off all effects"/>
            <argument valueNotes="1 (default)" description="turn on all effects (color and size change)"/>
            <argument valueNotes="2" description="turn on color change/turn off size change"/>
            <argument valueNotes="3" description="turn off color change/turn on size change"/>
          </arguments>
        </variable>

        <variable name="radarentsize">
          <description>Sets the icon size of the players shown in the radar and the minimap.</description>
          <value token="V" description="size of icons inside radar" minValue="4" maxValue="64" defaultValue="12"/>
        </variable>

        <variable name="cncolumncolor">
          <description>Colour of CN column in scoreboard.</description>
          <value token="C" description="color" minValue="0" maxValue="9" defaultValue="5"
          valueNotes="0 (green), 1 (blue), 2 (yellow), 3 (red), 4 (gray), 5 (white), 6 (dark brown), 7 (dark red), 8 (purple), 9 (orange)"/>
        </variable>

        <variable name="radarheight">
          <description>Changes at what height you are floating in the radar-view.</description>
          <value token="H" description="height" minValue="5" maxValue="500" defaultValue="150"/>
        </variable>

        <variable name="showtargetname">
          <description>Enables or disables showing the player name on the HUD when in your crosshair.</description>
          <value token="N" description="0: off, 1: on" minValue="0" maxValue="1" defaultValue="1"/>
        </variable>

        <variable name="showspeed">
          <description>Enables or disables showing the player's horizontal speed (vector).</description>
          <value token="N" description="0: off, 1: on" minValue="0" maxValue="1" defaultValue="0"/>
        </variable>

        <variable name="blankouthud">
          <description>Hides most of elements on the HUD for X frames.</description>
          <value token="X" description="blank out the HUD" minValue="0" maxValue="10000" defaultValue="0"/>
          <remarks>
            <remark>
            Used for "clean" screenshot. The parameter is "frames", so for example 1000 will take 20 seconds at 50 fps
            or second at 1000 fps.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="cleanshot"/>
          </references>
        </variable>

        <command name="showscores">
          <description>Shows or hides the scores.</description>
          <defaultKeys>
            <key alias="TAB"/>
          </defaultKeys>
          <references>
            <identifierReference identifier="showscoresondeath"/>
          </references>
        </command>

        <variable name="showscoresondeath">
          <description>Determines if scores should be shown on death.</description>
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="1"/>
          <references>
            <identifierReference identifier="showscores"/>
          </references>
        </variable>

        <variable name="sc_flags">
          <description>Sets the order priority for the column flags on the scoreboard.</description>
          <value token="V" description="low priority: left, high priority: right" minValue="0" maxValue="100" defaultValue="0"/>
        </variable>

        <variable name="sc_frags">
          <description>Sets the order priority for the column frags on the scoreboard.</description>
          <value token="V" description="low priority: left, high priority: right" minValue="0" maxValue="100" defaultValue="1"/>
        </variable>

        <variable name="sc_deaths">
          <description>Sets the order priority for the column deaths or disables it on the scoreboard.</description>
          <value token="V" description="-1: disable, low priority: left, high priority: right" minValue="-1" maxValue="100" defaultValue="2"/>
        </variable>

        <variable name="sc_ratio">
          <description>Sets the order priority for the column ratio or disables it on the scoreboard.</description>
          <value token="V" description="-1: disable, low priority: left, high priority: right" minValue="-1" maxValue="100" defaultValue="-1"/>
        </variable>

        <variable name="sc_score">
          <description>Sets the order priority for the column score or disables it on the scoreboard.</description>
          <value token="V" description="-1: disable, low priority: left, high priority: right" minValue="-1" maxValue="100" defaultValue="4"/>
        </variable>

        <variable name="sc_lag">
          <description>Sets the order priority for the column pj/ping or disables it on the scoreboard.</description>
          <value token="V" description="-1: disable, low priority: left, high priority: right" minValue="-1" maxValue="100" defaultValue="5"/>
        </variable>

        <variable name="sc_clientnum">
          <description>Sets the order priority for the column cn on the scoreboard.</description>
          <value token="V" description="low priority: left, high priority: right" minValue="0" maxValue="100" defaultValue="6"/>
        </variable>

        <variable name="sc_name">
          <description>Sets the order priority for the column name on the scoreboard.</description>
          <value token="V" description="low priority: left, high priority: right" minValue="0" maxValue="100" defaultValue="7"/>
        </variable>

        <variable name="accuracy">
          <description>Sets whether or not to display the accuracy information window.</description>
          <remarks>
            <remark>Accuracy is displayed for current weapon and only then, if scoreboard is turned on.</remark>
          </remarks>
          <value token="N" description="1: on, 0: off" minValue="0" maxValue="1" defaultValue="0"/>
          <references>
            <identifierReference identifier="accuracyinfo"/>
            <identifierReference identifier="accuracyreset"/>
          </references>
        </variable>

        <command name="accuracyreset">
          <description>Resets accuracy counters.</description>
          <references>
            <identifierReference identifier="accuracy"/>
          </references>
        </command>

        <command name="accuracyinfo">
          <description>Shows in the console accuracy of all used weapons.</description>
          <references>
            <identifierReference identifier="accuracy"/>
          </references>
        </command>

        <variable name="conalpha">
          <description>Sets the transparency of the console.</description>
          <value token="N" description="Alpha value" minValue="0" maxValue="255" defaultValue="255"/>
        </variable>

        <variable name="votealpha">
          <description>Sets the transparency of the vote display.</description>
          <value token="N" description="Alpha value" minValue="0" maxValue="255" defaultValue="255"/>
        </variable>

      </identifiers>
    </section>
    <!-- Heads-Up Display Section Ends -->
    <!-- Visuals Section Starts -->
    <section name="Visuals" sortindex="05">
      <description>This section describes identifiers to configure the visuals.</description>
      <identifiers>
        <command name="resetgl">
          <description>Resets the OpenGL rendering settings.</description>
        </command>

        <command name="screenres">
          <description>Changes the screen resolution.</description>
          <arguments>
            <argument token="W" description="width"/>
            <argument token="H" description="height"/>
          </arguments>
          <references>
            <identifierReference identifier="desktopw"/>
            <identifierReference identifier="desktoph"/>
            <identifierReference identifier="getdisplayresolutions"/>
          </references>
        </command>

        <variable name="desktopw">
          <description>Returns a width of the desktop resolution (or zero, if not available).</description>
          <references>
            <identifierReference identifier="desktoph"/>
            <identifierReference identifier="screenres"/>
          </references>
        </variable>

        <variable name="desktoph">
          <description>Returns a height of the desktop resolution (or zero, if not available).</description>
          <references>
            <identifierReference identifier="desktopw"/>
            <identifierReference identifier="screenres"/>
          </references>
        </variable>

        <command name="getdisplayresolutions">
          <description>Returns a list of available screen resolutions.</description>
          <references>
            <identifierReference identifier="screenres"/>
          </references>
        </command>

        <command name="glext">
          <description>Checks for the searchstring in all loaded extensions.</description>
          <arguments>
            <argument token="E" description="extension"/>
          </arguments>
          <examples>
            <example>
              <code><![CDATA[if (glext shadow_funcs) [echo you have shadow functionality] [echo no shadows for you]]]></code>
            </example>
          </examples>
        </command>

        <command name="fpsrange">
          <description>Sets the range of FPS (AC will adjust LOD to achieve it).</description>
          <arguments>
            <argument token="A" description="min" defaultValue="30"/>
            <argument token="B" description="max" defaultValue="40"/>
          </arguments>
          <references>
            <identifierReference identifier="maxfps"/>
          </references>
        </command>

        <variable name="maxfps">
          <description>Limits the FPS (frames per second) of AssaultCube's video output.</description>
          <remarks>
            <remark>Remark: limit to '200' is optimal.</remark>
          </remarks>
          <value token="V" description="maximum FPS" minValue="25 or 0" maxValue="1000" defaultValue="200" valueNotes="0 disables maxfps"/>
          <references>
            <identifierReference identifier="fpsrange"/>
          </references>
        </variable>

        <variable name="skyclip">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="1"/>
        </variable>

        <variable name="shadowcasters">
        </variable>

        <variable name="shadowclip">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="1"/>
        </variable>

        <variable name="shadowtile">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="1"/>
        </variable>

        <variable name="ati_mda_bug">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="0"/>
        </variable>

        <variable name="stencilbits">
          <value token="V" description="" minValue="0" maxValue="32" defaultValue="0"/>
        </variable>

        <variable name="stencilshadow">
          <description>Sets the transparency/opacity level of stencil shadows.</description>
          <value token="V" description="Alpha level" minValue="0" maxValue="100" defaultValue="40"/>
        </variable>

        <variable name="depthoffset">
          <value token="V" description="" defaultValue="0.005f"/>
        </variable>

        <variable name="polygonoffsetfactor">
          <value token="V" description="" defaultValue="-3.0f"/>
        </variable>

        <variable name="polygonoffsetunits">
          <value token="V" description="" defaultValue="-3.0f"/>
        </variable>

        <variable name="dynshadowdecay">
          <value token="V" description="" minValue="0" maxValue="3000" defaultValue="1000"/>
        </variable>

        <variable name="dynshadowquad">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="0"/>
        </variable>

        <variable name="tsswap">
          <description>Swaps vertices of model triangles.</description>
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="1"/>
        </variable>

        <command name="font">
          <description>Loads a font texture to use as text within AssaultCube.</description>
          <arguments>
            <argument token="NAME" description="the font name"/>
            <argument token="PATH" description="the path to the font texture"/>
            <argument token="A" description="the default width"/>
            <argument token="B" description="the default height"/>
            <argument token="C" description="offset (co-ordinate X)"/>
            <argument token="D" description="offset (co-ordinate Y)"/>
            <argument token="E" description="offset (width)"/>
            <argument token="F" description="offset (height)"/>
          </arguments>
          <references>
            <identifierReference identifier="fontchar"/>
            <identifierReference identifier="fontskip"/>
            <identifierReference identifier="setfont"/>
            <identifierReference identifier="menufont"/>
            <identifierReference identifier="menuitemaltfont"/>
          </references>
        </command>

        <command name="fontchar">
          <description>Specifies a region of an image to be used as a font character.</description>
          <arguments>
            <argument token="A" description="X co-ordinates (from top-left corner)"/>
            <argument token="B" description="Y co-ordinates (from top-left corner)"/>
            <argument token="C" description="width"/>
            <argument token="D" description="height"/>
          </arguments>
          <references>
            <identifierReference identifier="font"/>
            <identifierReference identifier="fontskip"/>
          </references>
        </command>

        <command name="fontskip">
          <description>Specifies, at what char the font definition proceeds.</description>
          <remarks>
            <remark>
            For example "fontskip 48" means the ascii code of the first char in defined font will be "48", which is '0';
            "fontskip 65" would start at 'A'.</remark>
          </remarks>
          <arguments>
            <argument token="A" description="the ascii code of the first char"/>
          </arguments>
          <references>
            <identifierReference identifier="font"/>
            <identifierReference identifier="fontchar"/>
          </references>
        </command>

        <command name="setfont">
          <description>Changes the current font.</description>
          <arguments>
            <argument token="N" description="font name" valueNotes="default, mono, serif"/>
          </arguments>
          <references>
            <identifierReference identifier="font"/>
            <identifierReference identifier="curfont"/>
          </references>
        </command>

        <command name="curfont">
          <description>Returns a name of the current font.</description>
          <value token="S" description="name of font" valueNotes="&lt;empty&gt;, default, mono, serif" defaultValue=""/>
          <references>
            <identifierReference identifier="font"/>
            <identifierReference identifier="setfont"/>
          </references>
        </command>

        <variable name="fov">
          <description>Sets the field of view (fov).</description>
          <value token="N" description="the FOV value" minValue="75" maxValue="120" defaultValue="90"/>
          <references>
            <identifierReference identifier="scopefov"/>
            <identifierReference identifier="spectfov"/>
            <identifierReference identifier="spectfovremote"/>
          </references>
        </variable>

        <variable name="aboveheadiconsize">
          <description>Sets the size for the icon shown above a player using comunications voices.</description>
          <value token="V" description="Icon size" minValue="0" maxValue="1000" defaultValue="50"/>
        </variable>

        <variable name="aboveheadiconfadetime">
          <description>Time in milliseconds before the abovehead icon dissapears.</description>
          <value token="V" description="abovehead icon display time" minValue="1" maxValue="10000" defaultValue="2000"/>
        </variable>

        <variable name="bloodttl">
          <description>Sets the amount of time in milliseconds that blood is displayed on the ground.</description>
          <value token="V" description="Blood display time" minValue="0" maxValue="30000" defaultValue="10000"/>
        </variable>

        <variable name="blood">
          <description>Turns on and off the display of blood.</description>
          <value token="V" description="Enable/Disable blood" minValue="0" maxValue="1" defaultValue="1"/>
        </variable>

        <variable name="gib">
          <description>Enables or disables the gib animation entirely.</description>
          <value token="B" description="off OR on" minValue="0" maxValue="1" defaultValue="1" valueNotes="0 (false), 1 (true)"/>
          <references>
            <identifierReference identifier="gibnum"/>
            <identifierReference identifier="gibspeed"/>
            <identifierReference identifier="gibsgore"/>
            <identifierReference identifier="gibttl"/>
            <identifierReference identifier="popdeadplayers"/>
          </references>
        </variable>

        <variable name="gibnum">
          <description>Sets the number of gibs to display when performing a "messy" kill (grenade, knife, sniper headshot).</description>
          <remarks>
            <remark>Larger values are more spectacular, but can slow down less powerful machines. Reducing gibttl may help in this case.</remark>
          </remarks>
          <references>
            <identifierReference identifier="gibttl"/>
            <identifierReference identifier="gibspeed"/>
          </references>
          <value token="N" description="number of gibs" minValue="0" maxValue="1000" defaultValue="6"/>
        </variable>

        <variable name="gibttl">
          <description>Sets the time for gibs to live (in milliseconds), after which they will disappear.</description>
          <references>
            <identifierReference identifier="gibnum"/>
            <identifierReference identifier="gibspeed"/>
          </references>
          <value token="N" description="time to live" minValue="0" maxValue="60000" defaultValue="7000"/>
        </variable>

        <variable name="gibspeed">
          <description>Sets the velocity at which gibs will fly from a victim.</description>
          <references>
            <identifierReference identifier="gibnum"/>
            <identifierReference identifier="gibttl"/>
          </references>
          <value token="N" description="velocity" minValue="1" maxValue="100" defaultValue="30"/>
        </variable>

        <variable name="teamdisplaymode">
          <description>Sets the team display mode.</description>
          <remarks>
            <remark>
            In mode 0 team display is disabled
            In mode 1 players will be rendered with a colored vest to make the teams distinguishable.
            In mode 2 almost the whole suit of the players will be colored. These display modes are only
            applied in team gameodes.
            </remark>
          </remarks>
          <value token="N" description="the team display mode" minValue="0" maxValue="2" defaultValue="1" valueNotes="0 (none), 1 (color vests), 2 (color skins)"/>
        </variable>

        <variable name="aadynshadow">
          <description>Sets the size/resolution of the dynamic shadow data.</description>
          <value description="the size" minValue="0" maxValue="3" defaultValue="2"/>
        </variable>

        <variable name="dynshadowsize">
          <description>Sets the display size of the dynamic shadows.</description>
          <value description="the size" minValue="4" maxValue="8" defaultValue="5"/>
        </variable>

        <variable name="saveshadows">
          <description>Sets if dynamic shadows should be saved to disk.</description>
          <value description="auto save" minValue="0" maxValue="1" defaultValue="1"/>
        </variable>

        <variable name="dynshadow">
          <description>Sets the alpha value (transparency) for dynamic shadows.</description>
          <value description="the alpha value" minValue="0" maxValue="100" defaultValue="40"/>
        </variable>

        <variable name="bilinear">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="1"/>
        </variable>

        <variable name="scorchttl">
          <value token="V" description="" minValue="0" maxValue="30000" defaultValue="10000"/>
        </variable>

        <variable name="scorch">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="1"/>
        </variable>

        <variable name="mtexplosion">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="1"/>
        </variable>

        <variable name="mtwater">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="1"/>
        </variable>

        <variable name="reflectclip">
          <value token="V" description="" minValue="0" maxValue="100" defaultValue="1"/>
        </variable>

        <variable name="reflectsize">
          <value token="V" description="" minValue="6" maxValue="10" defaultValue="8"/>
        </variable>

        <variable name="reflectscissor">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="1"/>
        </variable>

        <variable name="dynlight">
          <description>Determines whether dynamic shadows and lights are rendered, provided just incase they slow your fps down too much.</description>
          <value token="R" description="0 off, 1 on" minValue="0" maxValue="1" defaultValue="1"/>
        </variable>

        <variable name="watersubdiv">
          <description>Determines the subdivision of the water surface in maps.</description>
          <remarks>
            <remark>
            Must be a power of 2: 4 is the default, 8 is recommended for people on slow machines,
            2 is nice for fast machines, and 1 is quite OTT. See "waterlevel" (edit reference)
            on how to add water to your own levels.
            </remark>
          </remarks>
          <value token="N" description="the subdivisioin value" minValue="1" maxValue="64" defaultValue="4"/>
          <references>
            <identifierReference identifier="waterlevel"/>
          </references>
        </variable>

        <variable name="waterreflect">
          <description>Turns on/off the reflections in the water surface.</description>
          <value token="V" description="enable/disable water reflections" minValue="0" maxValue="1" defaultValue="1"/>
        </variable>

        <variable name="waterrefract">
          <description>Turns on/off water refractions.</description>
          <value token="V" description="enable/disable water refractions" minValue="0" maxValue="1" defaultValue="0"/>
        </variable>

        <variable name="waveheight">
          <description>Sets the wave height of water, between 0 (completely still, no waves at all) and 1 (very choppy).</description>
          <value token="F" description="wave height (floating-point value)" minValue="0" maxValue="1" defaultValue="0.3"/>
        </variable>

        <variable name="shotlinettl">
          <value token="V" description="" minValue="0" maxValue="10000" defaultValue="75"/>
        </variable>

        <variable name="shotline">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="1"/>
        </variable>

        <variable name="fullscreen">
          <description>Enables or disables fullscreen.</description>          
          <value description="fullscreen" minValue="0" maxValue="1" defaultValue="1"/>
          <references>
            <identifierReference identifier="fullscreentoggle"/>
            <identifierReference identifier="fullscreendesktop"/>
          </references>
        </variable>

        <command name="fullscreentoggle">
          <description>Toggles fullscreen on or off.</description>
          <references>
            <identifierReference identifier="fullscreen"/>
          </references>
        </command>

        <variable name="hwmaxaniso">
          <description>Shows the maximum level of anisotropic filtering supported by the graphics hardware.</description>
          <references>
            <identifierReference identifier="aniso"/>
          </references>
        </variable>

        <variable name="aniso">
          <description>Sets the level of anisotropic filtering.</description>
          <value token="V" description="anisotropic filtering" minValue="0" maxValue="16" defaultValue="0"/>
          <references>
            <identifierReference identifier="hwmaxaniso"/>
          </references>
        </variable>

        <variable name="fsaa">
          <description>Sets the level of full-scene antialiasing (FSAA).</description>
          <value token="V" description="full-scene antialiasing" minValue="-1" maxValue="16" defaultValue="0"/>
          <remarks>
            <remark>-1 uses the default settings obtained from the system. 0 disables, 1..16 enables FSAA.</remark>
          </remarks>
        </variable>

        <variable name="scr_w">
          <description>Sets the screen width.</description>
          <value token="W" description="the screen width" minValue="320" maxValue="10000" defaultValue="1024"/>
        </variable>

        <variable name="scr_h">
          <description>Sets the screen height.</description>
          <value token="H" description="the screen height" minValue="200" maxValue="10000" defaultValue="768"/>
        </variable>

        <variable name="screenw">
          <description>Returns the actual width of the screen/window.</description>
          <value token="W" description="the screen/window width" readOnly="true"/>
        </variable>

        <variable name="screenh">
          <description>Returns the actual height of the screen/window.</description>
          <value token="H" description="the screen/window height" readOnly="true"/>
        </variable>

        <variable name="fullscreendesktop">
          <description>Enables using always desktop resolution in fullscreen mode.</description>
          <value token="V" description="Use desktop resolution for fullscreen" minValue="0" maxValue="1" defaultValue="1"/>
          <references>
            <identifierReference identifier="fullscreen"/>
          </references>
        </variable>

        <variable name="depthbits">
          <description>Sets the bits for the depth buffer.</description>
          <value description="depth pixels" minValue="0" maxValue="32" defaultValue="0"/>
        </variable>

        <variable name="vsync">
          <description>Enables or disables vsync.</description>
          <value token="V" description="vsync" minValue="-1" maxValue="1" defaultValue="-1"/>
          <remarks>
            <remark>-1 uses the default settings obtained from the system. 0 disables, 1 enables vsync.</remark>
          </remarks>
        </variable>

        <variable name="gamma">
          <description>Sets the temporary (to next map start) hardware gamma value.</description>
          <remarks>
            <remark>May not work if your card/driver doesn't support it.</remark>
          </remarks>
          <value token="N" description="the gamma value" minValue="30" maxValue="300" defaultValue="100"/>
        </variable>

        <scriptalias name="setgamma">
          <description>Sets a persistent gamma value for a map.</description>
          <arguments>
            <argument token="G" description="the gamma value" valueNotes="30..300, default 100"/>
          </arguments>
          <references>
            <identifierReference identifier="gamma"/>
          </references>
        </scriptalias>

        <variable name="lighterror">
          <description>Allows to finetune the amount of "error" the mipmapper/stripifier allow themselves for changing lightlevels.</description>
          <remarks>
            <remark>If this variable is changed this during play, a "recalc" is needed to see the effect.</remark>
          </remarks>
          <references>
            <identifierReference identifier="recalc"/>
          </references>
          <value token="E" description="the error value, 1 being the best quality" minValue="1" maxValue="100" defaultValue="4"/>
        </variable>

        <variable name="minlod">
          <description>Minimal level of detail.</description>
          <value token="V" description="" minValue="25" maxValue="250" defaultValue="60"/>
        </variable>

        <variable name="spectfov">
          <description>Specifies the Field Of View when in spectating/ghost mode.</description>
          <value token="V" description="Spectate FOV size" minValue="5" maxValue="120" defaultValue="110"/>
          <references>
            <identifierReference identifier="fov"/>
            <identifierReference identifier="spectfovremote"/>
          </references>
        </variable>

        <variable name="spectfovremote">
          <description>Chooses between local or remote player's FOV when spectating.</description>
          <value token="V" description="0: uses 'spectfov' and the local 'scopefov', 1: uses 'fov' and 'scopefov' of the spectated player" minValue="0" maxValue="1" defaultValue="0"/>
          <references>
            <identifierReference identifier="fov"/>
            <identifierReference identifier="spectfov"/>
            <identifierReference identifier="scopefov"/>
          </references>
        </variable>

        <variable name="hwtexsize">
          <description>Shows the maximum texture size (in pixels) supported by the graphics hardware.</description>
          <references>
            <identifierReference identifier="maxtexsize"/>
          </references>
        </variable>

        <variable name="maxtexsize">
          <description>The maximum texture size that will be used by the engine, larger textures will be scaled down.</description>
          <value token="V" description="maximum texture size" minValue="0" maxValue="4096" defaultValue="0"/>
          <references>
            <identifierReference identifier="hwtexsize"/>
          </references>
          <remarks>
            <remark>If this value is zero, hwtexsize will be used.</remark>
          </remarks>
        </variable>

        <variable name="maxtmus">
          <description>Gets the maximum number of supported textures when performing multitexturing.</description>
        </variable>

        <variable name="trilinear">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="1"/>
        </variable>

        <variable name="texreduce">
          <description>Reduces the size of all texture by the selected factor:</description>
          <description>-1: 2x2 : 0 : 1: x0.5 : 2: x0.25 : 3: x0.125</description>
          <description>Note: -1 is a special mode which reduces all textures to flat coloured surfaces.</description>
          <value token="S" description="scale selection" minValue="-1" maxValue="3" defaultValue="0"/>
        </variable>

        <variable name="hirestextures">
          <description>Controls whether textures with a scale higher than 1.0 will be scaled down while loading (0) or not (1).</description>
          <value token="S" description="scale down?" minValue="0" maxValue="1" defaultValue="1"/>
          <references>
            <identifierReference identifier="texture"/>
          </references>
        </variable>

        <variable name="bulletholettl">
          <description>Specifies how long (in milliseconds) to display bullet holes.</description>
          <value token="V" description="Bullethole display time" minValue="0" maxValue="30000" defaultValue="10000"/>
        </variable>

        <variable name="bullethole">
          <description>Turns on/off the display of bullet holes.</description>
          <value token="V" description="Enable/Disable bullet holes" minValue="0" maxValue="1" defaultValue="1"/>
        </variable>

        <variable name="particlesize">
          <description>Scales all particles.</description>
          <value token="P" description="the scale percentage" minValue="20" maxValue="500" defaultValue="100"/>
        </variable>

        <variable name="maxtrail">
          <description>Maximum number of smoke particles along shotline of sniper rifle.</description>
          <value token="N" description="maximum number of smoke particles" minValue="1" maxValue="10000" defaultValue="500"/>
        </variable>

        <variable name="animationinterpolationtime">
          <description>Sets the time available for interpolation between model animations.</description>
          <value token="N" description="the amount of milliseconds for the interpolation" minValue="0" maxValue="1000" defaultValue="100"/>
        </variable>

        <variable name="mergestrips">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="1"/>
        </variable>

        <variable name="gibsgore">
          <value token="N" description="" minValue="0" maxValue="4" defaultValue="1" values=""/>
          <description>Adjusts gib/gibnum/gibspeed/gibttl variables collectively.</description>
          <arguments>
            <argument valueNotes="0 - Off"/>
            <argument valueNotes="1 - Default/Normal values"/>
            <argument valueNotes="2 - Good"/>
            <argument valueNotes="3 - Messy"/>
            <argument valueNotes="4 - Unrealistic"/>
          </arguments>
        </variable>

        <variable name="popdeadplayers">
          <description>Makes dead players instantly pop out of existence, instead of falling over and sinking into the ground.</description>
          <value token="B" description="BOOL" minValue="0" maxValue="1" defaultValue="0"/>
          <references>
            <identifierReference identifier="gib"/>
          </references>
        </variable>

        <variable name="maxroll">
          <description>Sets the maximum value the display will roll on strafing.</description>
          <value token="N" description="the roll value" minValue="0" maxValue="20" defaultValue="0"/>
          <references>
            <identifierReference identifier="maxrolleffect"/>
            <identifierReference identifier="maxrollremote"/>
          </references>
        </variable>

        <variable name="maxrolleffect">
          <description>Sets the maximum value the display will roll when you get damages.</description>
          <value token="N" description="the roll value" minValue="0" maxValue="30" defaultValue="10"/>
          <references>
            <identifierReference identifier="maxrolleffect"/>
            <identifierReference identifier="maxrollremote"/>
          </references>
        </variable>

        <variable name="maxrollremote">
          <description>Limits the maximum value the display will roll on strafing or if player gets damages, when spectating other players.</description>
          <value token="N" description="The roll value" minValue="0" maxValue="50" defaultValue="10"/>
          <references>
            <identifierReference identifier="maxroll"/>
            <identifierReference identifier="maxrolleffect"/>
          </references>
        </variable>

        <variable name="swaymovediv">
          <value token="V" description="" minValue="1" maxValue="1000" defaultValue="200"/>
        </variable>

        <variable name="swayspeeddiv">
          <value token="V" description="" minValue="1" maxValue="1000" defaultValue="105"/>
        </variable>

        <variable name="swayupmovediv">
          <value token="V" description="" minValue="1" maxValue="1000" defaultValue="200"/>
        </variable>

        <variable name="swayupspeeddiv">
          <value token="V" description="" minValue="1" maxValue="1000" defaultValue="105"/>
        </variable>

        <variable name="nosway">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="0"/>
        </variable>

        <variable name="righthanded">
          <description>Chooses whether the players hand carrying the weapon appears as right or left handed.</description>
          <value token="N" description="0: lefty, 1: righty" minValue="0" maxValue="1" defaultValue="1"/>
        </variable>

        <variable name="allowblinkingtext">
          <description>For toggling on the ability for any text to have the blinking bit set.</description>
          <value token="T" description="0 = Off, 1 = On" minValue="0" maxValue="1" defaultValue="0"/>
          <references>
            <identifierReference identifier="menucanblink"/>
          </references>
        </variable>

        <variable name="mdldlist">
          <value token="N" description="" minValue="0" maxValue="1" defaultValue="1"/>
        </variable>

        <variable name="mdldyncache">
          <value token="V" description="" minValue="1" maxValue="32" defaultValue="2"/>
        </variable>

        <variable name="mdlstatcache">
          <value token="V" description="" minValue="1" maxValue="32" defaultValue="1"/>
        </variable>

        <command name="skin">
          <description>Determines the skin of the current player.</description>
          <remarks>
            <remark>See the player model folder for the according skin-id.</remark>
          </remarks>
          <arguments>
            <argument token="N" description="skin id" valueNotes="value"/>
          </arguments>
        </command>

        <command name="skin_cla">
          <description>Chooses skin when playing for team CLA.</description>
          <arguments>
            <argument token="N" description="skin id"/>
          </arguments>
        </command>

        <command name="skin_rvsf">
          <description>Chooses skin when playing for team RVSF.</description>
          <arguments>
            <argument token="N" description="skin id"/>
          </arguments>
        </command>

        <variable name="hidecustomskins">
          <value token="B" description="" minValue="0" maxValue="1" defaultValue="0"/>
        </variable>

        <variable name="smoothdist">
          <description>Determines the valid distance when extrapolating a players position.</description>
          <value token="V" description="distance" minValue="0" maxValue="16" defaultValue="8"/>
        </variable>

        <variable name="smoothmove">
          <description>Determines the speed when extrapolating a players position.</description>
          <value token="V" description="movement speed" minValue="0" maxValue="100" defaultValue="75"/>
        </variable>

        <command name="getigraph">
          <description>Returns an encoded string to display an inlined image outside the console.</description>
          <remarks>
            <remark>
            Images are stored in packages/misc/igraph/*.png and loaded during game start.
            Filenames consist of the image shorthand (mnemonic) and optional frame times, separated by "_".
            Media file names may only contain letters, digits and "_-.()".
            </remark>
            <remark>
            All texts displayed in the game console are scanned for mnemonics prefixed with ":".
            All found matches are replaced by the image.
            </remark>
            <remark>
            The images are displayed as squares with width and height the same as the regular font height.
            To create animations, put several square images side by side into the file. For example, a 128x32 image is
            interpreted as four frames. Frame duration is encoded in the filename, so, for example the file
            "nop_1000_200_100.png" shows the first frame for 1000 milliseconds, the second frame for 200 msec and the third
            (as the rest) for 100 msec.
            </remark>
            <remark>
            Igraphs "1" to "9" are hardcoded and can be manually encoded in menu texts.
            Use the new escape code "\i" plus the number of the image: "\i\1".."\i\9".
            Other images can be used in menus as well, but the codes have to be fetched by "getigraph".
            </remark>
            <remark>If the mnemonic was not found, then "getigraph" returns an empty string.</remark>
          </remarks>
          <arguments>
            <argument token="M" description="mnemonic"/>
          </arguments>
          <references>
            <identifierReference identifier="updateigraphs"/>
            <identifierReference identifier="igraphsize"/>
            <identifierReference identifier="igraphsizehardcoded"/>
            <identifierReference identifier="igraphanimate"/>
            <identifierReference identifier="igraphdefaultframetime"/>
            <identifierReference identifier="hideigraphs"/>
          </references>
        </command>

        <command name="updateigraphs">
          <description>Checks for new files in packages/misc/igraph/ folder.</description>
          <remarks>
            <remark>Only necessary, if new files are added during the game - for example, by mod package download.</remark>
          </remarks>
          <references>
            <identifierReference identifier="getigraph"/>
          </references>
        </command>

        <variable name="igraphsize">
          <description>Scales inlined images (in percent).</description>
          <value token="N" description="size of images (in percent)" minValue="80" maxValue="300" defaultValue="120"/>
          <references>
            <identifierReference identifier="getigraph"/>
            <identifierReference identifier="igraphsizehardcoded"/>
          </references>
        </variable>

        <variable name="igraphsizehardcoded">
          <description>Scales the hardcoded inlined images: "1".."9" (in percent).</description>
          <value token="N" description="size of images (in percent)" minValue="80" maxValue="160" defaultValue="106"/>
          <references>
            <identifierReference identifier="getigraph"/>
            <identifierReference identifier="igraphsize"/>
          </references>
        </variable>

        <variable name="igraphanimate">
          <description>Enables animation of inlined images with multiple frames.</description>
          <value token="N" description="0: display only first frame, 1: enable animation" minValue="0" maxValue="1" defaultValue="1"/>
          <references>
            <identifierReference identifier="getigraph"/>
            <identifierReference identifier="igraphdefaultframetime"/>
            <identifierReference identifier="igraphsize"/>
          </references>
        </variable>

        <variable name="igraphdefaultframetime">
          <description>Default frame time for inlined images with multiple frames.</description>
          <remarks>
            <remark>Used for images with no frame duration specified in the filename.</remark>
          </remarks>
          <value token="N" description="frame time for images" minValue="5" maxValue="2000" defaultValue="200"/>
          <references>
            <identifierReference identifier="getigraph"/>
            <identifierReference identifier="igraphanimate"/>
            <identifierReference identifier="igraphsize"/>
          </references>
        </variable>

        <variable name="hideigraphs">
          <description>Hides inlined images in the console.</description>
          <value token="N" description="0: show, 1: hide" minValue="0" maxValue="1" defaultValue="0"/>
          <references>
            <identifierReference identifier="getigraph"/>
          </references>
        </variable>

        <variable name="mapoverride_nowaterreflect">
          <description>Per-map override to disable water reflection on the client.</description>
          <value token="B" description="boolean" valueMin="0" valueMax="1" valueNotes="1:ignore" defaultValue="0"/>
          <remarks>
            <remark>Set by the mapper, for his map only. The overrides are stored in the map header.</remark>
            <remark>
            If "1", water reflection is disabled. Useful, when odd water colours are used to emulate other liquids
            that are not supposed to be that reflective.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="mapoverride_limitwaveheight"/>
            <identifierReference identifier="mapoverride_nostencilshadows"/>
            <identifierReference identifier="ignoreoverride_nowaterreflect"/>
          </references>
        </variable>

        <variable name="mapoverride_limitwaveheight">
          <description>Per-map override to limit waveheight on the client.</description>
          <value token="B" description="boolean" valueMin="0" valueMax="1" valueNotes="1:ignore" defaultValue="0"/>
          <remarks>
            <remark>Set by the mapper, for his map only. The overrides are stored in the map header.</remark>
            <remark>
            If "1", waveheight is capped at 0.1 max. Useful for small water areas (like puddles),
            where higher waves would look weird.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="mapoverride_nowaterreflect"/>
            <identifierReference identifier="mapoverride_nostencilshadows"/>
            <identifierReference identifier="ignoreoverride_limitwaveheight"/>
          </references>
        </variable>

        <variable name="mapoverride_nostencilshadows">
          <description>Per-map override to disable stencil shadows on the client.</description>
          <value token="B" description="boolean" valueMin="0" valueMax="1" valueNotes="1:ignore" defaultValue="0"/>
          <remarks>
            <remark>Set by the mapper, for his map only. The overrides are stored in the map header.</remark>
            <remark>
            If "1", stencil shadows are disabled. On clients, where stencil shadows are otherwise enabled,
            blob shadows are used instead. If shadows are disabled anyway, they stay disabled.
            Useful for dim maps, where hard shadows make no sense.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="mapoverride_nowaterreflect"/>
            <identifierReference identifier="mapoverride_limitwaveheight"/>
            <identifierReference identifier="ignoreoverride_nostencilshadows"/>
          </references>
        </variable>

        <variable name="ignoreoverride_nowaterreflect">
          <description>Ignores per-map overrides to disable water reflection on the client.</description>
          <value token="B" description="boolean" valueMin="0" valueMax="1" valueNotes="1:ignore" defaultValue="0"/>
          <remarks>
            <remark>
            Ignores the overrides set by the mappers (for their maps only).
            If "1", mapoverride_nowaterreflect is ignored and regular client settings are used.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="mapoverride_nowaterreflect"/>
            <identifierReference identifier="ignoreoverride_limitwaveheight"/>
            <identifierReference identifier="ignoreoverride_nostencilshadows"/>
          </references>
        </variable>

        <variable name="ignoreoverride_limitwaveheight">
          <description>Ignores per-map overrides to limit waveheight on the client.</description>
          <value token="B" description="boolean" valueMin="0" valueMax="1" valueNotes="1:ignore" defaultValue="0"/>
          <remarks>
            <remark>
            Ignores the overrides set by the mappers (for their maps only).
            If "1", mapoverride_limitwaveheight is ignored, and "waveheight" is used unchanged.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="mapoverride_limitwaveheight"/>
            <identifierReference identifier="ignoreoverride_nowaterreflect"/>
            <identifierReference identifier="ignoreoverride_nostencilshadows"/>
          </references>
        </variable>

        <variable name="ignoreoverride_nostencilshadows">
          <description>Ignores per-map overrides to disable stencil shadows on the client.</description>
          <value token="B" description="boolean" valueMin="0" valueMax="1" valueNotes="1:ignore" defaultValue="0"/>
          <remarks>
            <remark>
            Ignores the overrides set by the mappers (for their maps only).
            If "1", mapoverride_nostencilshadows is ignored.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="mapoverride_nostencilshadows"/>
            <identifierReference identifier="ignoreoverride_nowaterreflect"/>
            <identifierReference identifier="ignoreoverride_limitwaveheight"/>
          </references>
        </variable>

        <variable name="lightscale">
          <description>Scaling factor for all light in the game.</description>
          <value token="D" description="divisor" minValue="1" maxValue="100" valueNotes="values will be divided by this" defaultValue="4"/>
          <remarks>
            <remark>Any change will not take effect until a new world is loaded.</remark>
          </remarks>
        </variable>

      </identifiers>
    </section>
    <!-- Visuals Section Ends -->
    <!-- Sound Section Starts -->
    <section name="Sound" sortindex="07">
      <description>This section describes all identifiers related to music and sound effects.</description>
      <identifiers>
        <variable name="soundscheddistancescore">
          <value token="V" description="" minValue="0" maxValue="1000" defaultValue="5"/>
        </variable>

        <variable name="soundschedoldbonus">
          <value token="V" description="" minValue="0" maxValue="1000" defaultValue="100"/>
        </variable>

        <variable name="soundschedpriorityscore">
          <value token="V" description="" minValue="0" maxValue="1000" defaultValue="100"/>
        </variable>

        <variable name="soundschedreserve">
          <value token="V" description="" minValue="0" maxValue="100" defaultValue="2"/>
        </variable>

        <variable name="al_referencedistance">
          <description>The distance from the source emitting the sound to the listener.</description>
          <value token="V" description="" minValue="0" maxValue="1000000" defaultValue="400"/>
        </variable>

        <variable name="al_rollofffactor">
          <description>This value indicates the relative "strength" of a sound (how far away the sound can be heard).</description>
          <value token="V" description="" minValue="0" maxValue="1000000" defaultValue="100"/>
        </variable>

        <command name="sound">
          <description>Plays the specified sound.</description>
          <remarks>
            <remark>
            See source/src/server.h file or use "enumsounds" command for default sounds, and use "registersound" to register your own.
            For example, 'sound 0' and 'sound (registersound "player/jump")' both play the standard jump sound.
            </remark>
          </remarks>
          <arguments>
            <argument token="N" description="number of the sound to play" valueNotes="integer"/>
          </arguments>
          <references>
            <identifierReference identifier="enumsounds"/>
            <identifierReference identifier="registersound"/>
          </references>
        </command>

        <command name="soundtest">
          <description>Plays all hardcoded sounds in order.</description>
        </command>

        <command name="mutesound">
          <description>Mutes a specific game sound.</description>
          <arguments>
            <argument token="N" description="ID of the sound to mute" valueNotes="see 'enumsounds', starting at ID 0"/>
            <argument token="A" description="audible?" valueNotes="(mute) 0 or 1 (unmute)"/>
          </arguments>
          <references>
            <identifierReference identifier="soundmuted"/>
            <identifierReference identifier="unmuteallsounds"/>
            <identifierReference identifier="enumsounds"/>
          </references>
        </command>

        <command name="soundmuted">
          <description>Returns 1 if sound N is muted, else 0.</description>
          <examples>
            <example>
              <code><![CDATA[mutesound 5; if (soundmuted 5) [echo Sound 5 is muted!] [echo Sound 5 is not muted!]]]></code>
              <explanation>Output: Sound 5 is muted!</explanation>
            </example>
          </examples>
          <arguments>
            <argument token="N" description="sound ID" valueNotes="see 'enumsounds' for valid sound ID"/>
          </arguments>
          <references>
            <identifierReference identifier="mutesound"/>
            <identifierReference identifier="unmuteallsounds"/>
            <identifierReference identifier="enumsounds"/>
          </references>
        </command>

        <command name="unmuteallsounds">
          <description>Unmutes all previously muted sounds.</description>
          <references>
            <identifierReference identifier="mutesound"/>
          </references>
        </command>

        <variable name="mapsoundrefresh">
          <description>Specifies the interval for checking mapsounds.</description>
          <remarks>
            <remark>If set to value 0, the map sounds will be checked in every frame without any interval limitation.</remark>
          </remarks>
          <references>
            <identifierReference identifier="mapsound"/>
            <identifierReference identifier="newent sound"/>
          </references>
          <value token="N" description="interval in milliseconds" minValue="0" maxValue="1000" defaultValue="10"/>
        </variable>

        <variable name="audiodebug">
          <description>Enables verbose output for debugging purposes.</description>
          <value token="B" description="enable audio debug" minValue="0" maxValue="1" defaultValue="0"/>
        </variable>

        <variable name="gainscale">
          <description>Each subsequent played sound's gain-value is scaled by this percentage.</description>
          <remarks>
            <remark>
            This lowers the gain of the sounds before they are mixed, this might be useful in cases when the mixer has problems with too high gain values.
            </remark>
          </remarks>
          <value token="N" description="percentage" minValue="0" maxValue="100" defaultValue="100"/>
        </variable>

        <variable name="musicvol">
          <description>Sets the music volume.</description>
          <references>
            <identifierReference identifier="soundvol"/>
          </references>
          <value token="N" description="the volume" minValue="0" maxValue="255" defaultValue="128"/>
        </variable>

        <command name="music">
          <description>Plays music in the background.</description>
          <arguments>
            <argument token="A" description="music file name"/>
            <argument token="B" description="playtime"/>
            <argument token="C" description="command to be executed, when music is done"/>
          </arguments>
        </command>

        <command name="musicpreload">
          <description>Preloads the sound track.</description>
          <remarks>
            <remark>Can be helpful if you experience a delay, e.g. when picking up a flag.</remark>
          </remarks>
          <arguments>
            <argument token="N" description="soundtrack number" valueNotes="0 (flag grab), 1 (last minute #1), 2 (last minute #2)"/>
          </arguments>
        </command>

        <command name="registermusic">
          <description>Registers a track as music.</description>
          <arguments>
            <argument token="M" description="music file"/>
          </arguments>
          <remarks>
            <remark>The first three tracks have special meaning: Track #1 is for "flag grab" the second and third are used as "last minute" tracks.</remark>
          </remarks>
        </command>

        <command name="registersound">
          <description>Registers a sound.</description>
          <remarks>
            <remark>
            This command returns the sound number, which is assigned from 0 onwards,
            and which can be used with "sound" command. If the sound was already registered,
            its existing index is returned. "registersound" does not actually load the sound, this is done on first play.
            </remark>
          </remarks>
          <examples>
            <example>
              <code><![CDATA[registersound "player/jump" 80]]></code>
              <explanation>It registers packages/audio/player/jump.ogg sound with volume 80</explanation>
            </example>
          </examples>
          <arguments>
            <argument token="N" description="sound name" valueNotes="path below packages/audio/, without file extension"/>
            <argument token="V" description="volume" optional="true" valueNotes="0..255"/>
            <argument token="L" description="loop" optional="true" valueNotes="0 (off), 1 (on)"/>
            <argument token="R" description="audible radius" optional="true" valueNotes=""/>
          </arguments>
          <references>
            <identifierReference identifier="sound"/>
          </references>
        </command>

        <command name="enumsounds">
          <description>Lists sound index numbers and short descriptions for all sounds of one or more categories.</description>
          <remarks>
            <remark>
            All sounds with at least one of the flags will be listed. Flag names prefixed with "!" will exclude all matching
            sound from the list. If no such entities exist or the entity type could not be recognised, the list is empty.
            </remark>
          </remarks>
          <examples>
            <example>
              <code><![CDATA[echo (enumsounds "VOICECOM !PUBLIC")]]></code>
              <explanation>It will list all voicecom sounds that are for teams only</explanation>
            </example>
            <example>
              <code><![CDATA[echo (enumsounds (listoptions soundcategories))]]></code>
              <explanation>It will list all sounds</explanation>
            </example>
          </examples>
          <arguments>
            <argument token="C" description="list of sound categories (flags)" valueNotes="PAIN, OWNPAIN, WEAPON, PICKUP, MOVEMENT, BULLET, OTHER, VOICECOM, TEAM, PUBLIC, FFA, FLAGONLY"/>
          </arguments>
          <references>
            <identifierReference identifier="sound"/>
            <identifierReference identifier="registersound"/>
          </references>
        </command>

        <variable name="audio">
          <description>Enables or disables the audio subsystem in AC.</description>
          <value token="B" description="enable" minValue="0" maxValue="1" defaultValue="1"/>
        </variable>

        <variable name="soundchannels">
          <description>Sets the desired amount of allocated sound channels.</description>
          <remarks>
            <remark>AC will try to allocate that number of channels but it is not guaranteed to succeed.</remark>
          </remarks>
          <value description="number of channels" minValue="4" maxValue="1024" defaultValue="128"/>
        </variable>

        <variable name="footsteps">
          <description>Indicates if the footsteps sound should be played.</description>
          <value token="B" description="enable footsteps" minValue="0" maxValue="1" defaultValue="1" valueNotes="1 (true), 0 (false)"/>
          <references>
            <identifierReference identifier="localfootsteps"/>
           </references>
        </variable>

        <variable name="localfootsteps">
          <description>Indicates if the footsteps sound for the local player should be played.</description>
          <value token="B" description="enable footsteps" minValue="0" maxValue="1" defaultValue="1" valueNotes="1 (true), 0 (false)"/>
          <references>
            <identifierReference identifier="footsteps"/>
           </references>
        </variable>

        <variable name="hitsound">
          <description>Plays a sound upon every successful hit if enabled.</description>
           <remarks>
            <remark>
            If hitsound is set to 2, the sound will be played instantly rather than after server acknowledgment.
            </remark>
          </remarks>
          <value token="B" description="off OR on" minValue="0" maxValue="2" defaultValue="0" valueNotes="0 (disabled), 1 (server), 2 (local)"/>
        </variable>

        <variable name="bulletairsounddestrad">
          <value token="V" description="" minValue="0" maxValue="1000" defaultValue="8"/>
        </variable>

        <variable name="bulletairsoundrad">
          <value token="V" description="" minValue="0" maxValue="1000" defaultValue="15"/>
        </variable>

        <variable name="bulletairsoundsourcerad">
          <value token="V" description="" minValue="0" maxValue="1000" defaultValue="8"/>
        </variable>

        <variable name="bulletairsound">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="1"/>
        </variable>

        <variable name="bulletbouncesoundrad">
          <value token="V" description="" minValue="0" maxValue="1000" defaultValue="15"/>
        </variable>

        <variable name="bulletbouncesound">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="1"/>
        </variable>

        <variable name="maxsoundsatonce">
          <value token="V" description="" minValue="0" maxValue="100" defaultValue="32"/>
        </variable>

        <variable name="soundvol">
          <description>Sets the sound volume for all sounds.</description>
          <value token="N" description="the volume" minValue="0" maxValue="255" defaultValue="128"/>
        </variable>

        <variable name="heartbeat">
          <description>Defines the health level at or below which a heartbeat sound will be played.</description>
          <remark>A value of 0 (which is the default) disables this feature.</remark>
          <value token="H" description="health value" minValue="0" maxValue="99" defaultValue="0"/>
        </variable>

      </identifiers>
    </section>
    <!-- Sound Section Ends -->
    <!-- Ingame reference Section Starts -->
    <section name="Ingame reference" sortindex="14">
      <description>This section describes all identifiers related to the ingame documentation reference.</description>
      <identifiers>
        <command name="docsection">
          <description>Adds a new section to the ingame documentation.</description>
          <references>
            <identifierReference identifier="docident"/>
          </references>
          <arguments>
            <argument token="S" description="the section name"/>
          </arguments>
        </command>

        <command name="docident">
          <description>Adds a new identifier documentation to the last added section.</description>
          <remarks>
            <remark>An identifier represents a command or variable.</remark>
            <remark>
            The name may contain spaces to create a "multipart" identifier documentation
            that can be used to describe a complex argument as a single pseudo identifier,
            look at the examples.
            </remark>
          </remarks>
          <examples>
            <example>
              <code><![CDATA[docident fov "Sets the field of view."]]></code>
            </example>
            <example>
              <code><![CDATA[docident "newent light" "Adds a new light entity."]]></code>
            </example>
          </examples>
          <references>
            <identifierReference identifier="docsection"/>
            <identifierReference identifier="docargument"/>
            <identifierReference identifier="docremark"/>
            <identifierReference identifier="docref"/>
            <identifierReference identifier="docundone"/>
            <identifierReference identifier="docinvalid"/>
            <identifierReference identifier="docfind"/>
            <identifierReference identifier="docwritebaseref"/>
            <identifierReference identifier="docvisible"/>
            <identifierReference identifier="docidentverbose"/>
          </references>
          <arguments>
            <argument token="N" description="name of the identifier"/>
            <argument token="D" description="the description"/>
          </arguments>
        </command>

        <command name="docargument">
          <description>Adds a new argument documentation to the last added identifier.</description>
          <remarks>
            <remark>An argument represents either a command argument or a variable value.</remark>
            <remark>
            The last argument of an identifier can be flagged as variable-length
            to indicate that it represents an unknown number of arguments.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="docident"/>
          </references>
          <arguments>
            <argument token="T" description="the token"/>
            <argument token="D" description="the description"/>
            <argument token="V" description="the value notes"/>
            <argument token="I" description="flags this argument as variable-length" valueNotes="1 (true), 0 (false)" optional="true"/>
          </arguments>
        </command>

        <command name="docremark">
          <description>Adds a new documentation remark to the last added identifier.</description>
          <references>
            <identifierReference identifier="docident"/>
          </references>
          <arguments>
            <argument token="S" description="the remark"/>
          </arguments>
        </command>

        <command name="docexample">
          <description>Adds an example to the last added identifier.</description>
          <arguments>
            <argument token="C" description="the example code"/>
            <argument token="E" description="the explanation" optional="true"/>
          </arguments>
        </command>

        <command name="docref">
          <description>Adds a new documentation reference to an identifier.</description>
          <remarks>
            <remark>The new reference is added to the last added identifier documentation.</remark>
          </remarks>
          <references>
            <identifierReference identifier="docident"/>
          </references>
          <arguments>
            <argument token="N" description="the display name"/>
            <argument token="I" description="the identifier to refer to" optional="true"/>
            <argument token="U" description="the URL to refer to" optional="true"/>
          </arguments>
        </command>

        <variable name="docrefvisible">
          <description>Render documentation references (docrefs) of the identifiers.</description>
          <value token="V" description="0: hide, 1: render" minValue="0" maxValue="1" defaultValue="1"/>
          <references>
            <identifierReference identifier="docref"/>
            <identifierReference identifier="docvisible"/>
            <identifierReference identifier="docidentverbose"/>
          </references>
        </variable>

        <command name="docundone">
          <description>Outputs a list of yet undocumented identifiers (commands, variables, etc.).</description>
          <remarks>
            <remark>
            If the one argument is omitted, only the builtin identifiers will be listed. Therefore specify the argument
            other identifiers like aliases should be included too.
            </remark>
            <remark>
            Note that the list also includes identifiers that contain the substrings "TODO" or "UNDONE" in their documentation.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="docident"/>
            <identifierReference identifier="docinvalid"/>
            <identifierReference identifier="docfind"/>
          </references>
          <arguments>
            <argument token="A" description="output all identifiers" valueNotes="1 (true), 0 (false)" optional="true"/>
          </arguments>
        </command>

        <command name="docinvalid">
          <description>Outputs a list of identifier documentations that do not match any existing identifier.</description>
          <remarks>
            <remark>Multipart identifiers are not included in this list, see 'docident'.</remark>
          </remarks>
          <references>
            <identifierReference identifier="docident"/>
            <identifierReference identifier="docundone"/>
            <identifierReference identifier="docfind"/>
          </references>
        </command>

        <command name="docfind">
          <description>Searches for pattern in all ingame identifier documentations (reference) entries.</description>
          <remarks>
            <remark>If "silent" is zero or omitted, all found references are listed.</remark>
            <remark>
            A table of all found entries is returned as result.
            For each entry, the index of the doc entry string that contains the pattern is listed.
            </remark>
          </remarks>
          <arguments>
            <argument token="P" description="the pattern"/>
            <argument token="S" description="silent?"/>
          </arguments>
          <references>
            <identifierReference identifier="docident"/>
            <identifierReference identifier="docundone"/>
            <identifierReference identifier="docinvalid"/>
            <identifierReference identifier="getdoc"/>
          </references>
        </command>

        <command name="getdoc">
          <description>Returns a string of the specified identifier documentation (reference) entry.</description>
          <remarks>
            <remark>String index numbers match with the result of "docfind".</remark>
          </remarks>
          <arguments>
            <argument token="N" description="name of the identifier"/>
            <argument token="I" description="the string index number of entry" valueNotes="0: name, 1: description, 2: remarks"/>
          </arguments>
          <references>
            <identifierReference identifier="docident"/>
            <identifierReference identifier="docfind"/>
          </references>
        </command>

        <command name="docwritebaseref">
          <description>Writes out a base XML documentation reference containing templates for the builtin identifiers.</description>
          <remarks>
            <remark>
            The generated reference is written to "docs/autogenerated_base_reference.xml" by default.
            The three arguments can be changed later on in the generated XML document.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="docident"/>
            <identifierReference identifier="docundone"/>
            <identifierReference identifier="docinvalid"/>
            <identifierReference identifier="docfind"/>
          </references>
          <arguments>
            <argument token="R" description="the reference name" optional="true"/>
            <argument token="S" description="the XML schema location string" optional="true"/>
            <argument token="T" description="XML stylesheet to use" optional="true"/>
          </arguments>
        </command>

        <command name="dockey">
        <description>Adds a new default key to an identifier.</description>
          <arguments>
            <argument token="A" description="" valueNotes="value"/>
          </arguments>
        </command>

        <variable name="docskip">
        <description>Allows to scroll through the rendered identifier documentation.</description>
          <value token="V" description="offset (number of lines)" minValue="0" maxValue="1000" defaultValue="0"/>
        </variable>

        <variable name="docvisible">
          <description>Render identifier documentation for the typed command in the console.</description>
          <value token="V" description="0: hide, 1: render" minValue="0" maxValue="1" defaultValue="1"/>
           <references>
            <identifierReference identifier="docident"/>
            <identifierReference identifier="docidentverbose"/>
            <identifierReference identifier="docrefvisible"/>
          </references>
        </variable>

        <variable name="docidentverbose">
          <description>Enables identifier details or statement analyser.</description>
          <value token="V" description="level of displaying the additional informations" minValue="0" maxValue="3" defaultValue="1"/>
           <references>
            <identifierReference identifier="docident"/>
            <identifierReference identifier="docvisible"/>
            <identifierReference identifier="docrefvisible"/>
          </references>
        </variable>

        <command name="docwritetodoref">
          <description>Writes out an XML documentation reference file containing undocumented identifiers or identifiers marked with "TODO".</description>
          <arguments>
            <argument token="I" description="Also include aliases?" valueNotes="0: don't include aliases (default), 1: include aliases" optional="true"/>
          </arguments>
        </command>

      </identifiers>
    </section>
    <!-- Ingame reference Section Ends -->
    <!-- Serverbrowser Section Starts -->
    <section name="Serverbrowser" sortindex="08">
      <description>This section describes all identifiers related to the serverbrowser.</description>
      <identifiers sort="true">

        <command name="addserver">
          <description>Adds a server to the list of server to query in the server list menu.</description>
          <arguments>
            <argument token="S" description="the address of the server (hostname or IP)"/>
            <argument token="P" description="the port"/>
          </arguments>
        </command>

        <command name="clearservers">
          <description>Clears the server list.</description>
        </command>

        <variable name="showallservers">
          <description>Whether servers that have not yet responded to a ping should be shown in the server list.</description>
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="1"/>
        </variable>

        <variable name="searchlan">
          <value token="V" description="" minValue="0" maxValue="2" defaultValue="1"/>
        </variable>

        <variable name="serversort">
          <value token="V" description="" minValue="0" maxValue="NUMSERVSORT-1" defaultValue="0"/>
        </variable>

        <variable name="servpingrate">
          <value token="V" description="" minValue="1000" maxValue="60000" defaultValue="5000"/>
        </variable>

        <command name="updatefrommaster">
          <description>Contacts the masterserver and adds any new servers to the server list.</description>
          <remarks>
            <remark>The servers are written to the config/servers.cfg file. This menu can be reached through the Multiplayer menu.</remark>
          </remarks>
          <arguments>
            <argument token="B" description="force update" valueNotes="0 (delayed), 1 (immediate)"/>
          </arguments>
          <references>
            <identifierReference identifier="mastertype"/>
            <identifierReference identifier="masterupdatefrequency"/>
          </references>
        </command>

        <variable name="mastertype">
        <description>Sets the method which client will use to contact the masterserver.</description>
          <value token="V" description="0: direct TCP connection, 1: HTTP connection (via proxy)" minValue="0" maxValue="1" defaultValue="1"/>
          <references>
            <identifierReference identifier="updatefrommaster"/>
          </references>
        </variable>

        <variable name="masterupdatefrequency">
          <value token="V" description="" minValue="1" maxValue="24*60*60" defaultValue="60*60"/>
          <references>
            <identifierReference identifier="updatefrommaster"/>
          </references>
        </variable>

        <variable name="maxservpings">
          <description>Sets the number of servers to be pinged at once.</description>
          <value token="V" description="" minValue="0" maxValue="1000" defaultValue="10"/>
        </variable>

        <command name="addfavcategory">
          <description>Adds a new category in the serverbrowser favourites.</description>
          <remarks>
            <remark>Add new categories to your autoexec.cfg, check favourites.cfg for examples.</remark>
          </remarks>
          <arguments>
            <argument token="A" description="reference designator (keep short and unique)"/>
          </arguments>
        </command>

        <command name="listfavcats">
          <description>Lists all registered serverbrowser favourites categories.</description>
        </command>

        <variable name="hidefavicons">
          <description>Hides favourites icons in serverbrowser.</description>
          <value token="N" description="0: show, 1: hide" minValue="0" maxValue="1" defaultValue="0"/>
        </variable>

        <variable name="serverbrowserhidefavtag">
          <description>Hides favourites tag column in serverbrowser.</description>
          <value token="N" description="-" minValue="0" maxValue="2" defaultValue="1"/>
        </variable>

        <variable name="serverbrowserhideip">
          <description>Hides server IP and port in serverbrowser.</description>
          <value token="N" description="-" minValue="0" maxValue="2" defaultValue="2"/>
        </variable>

        <variable name="serversortdir">
          <description>Selects ascending of descending sort order in serverbrowser.</description>
        </variable>

        <variable name="serversortpreferofficial">
          <description>Sort official maps over custom maps in serverbrowser.</description>
          <value token="N" description="-" minValue="0" maxValue="1" defaultValue="1"/>
        </variable>

        <variable name="showminremain">
          <description>Show 'minutes remaining' in serverbrowser.</description>
          <value token="N" description="" minValue="0" maxValue="1" defaultValue="1"/>
        </variable>

        <variable name="shownamesinbrowser">
          <description>Show player names in serverbrowser.</description>
          <value token="N" description="-" minValue="0" maxValue="1" defaultValue="0"/>
        </variable>

        <variable name="showonlyfavourites">
          <description>Show only servers of one favourites category in serverbrowser.</description>
          <value token="N" description="category index" minValue="0" maxValue="100" defaultValue="0"/>
        </variable>

        <variable name="showonlygoodservers">
          <description>Show only servers with the correct protocol in serverbrowser.</description>
          <value token="N" description="-" minValue="0" maxValue="1" defaultValue="0"/>
        </variable>

        <variable name="showweights">
          <description>Show 'weights' in serverbrowser.</description>
          <value token="N" description="" minValue="0" maxValue="1" defaultValue="1"/>
          <remarks>
            <remark>
            'weights' are the sort criteria with the highest priority. Favourites categories can change the weights.
            Use 'showweights' to debug problems with serverbrowser sorting.
            </remark>
          </remarks>
        </variable>

        <variable name="showallplayersnumber">
          <description>Shows on serverbrowser number of all players on the all servers.</description>
          <value token="N" description="" minValue="0" maxValue="1" defaultValue="0"/>
        </variable>

        <command name="searchnickname">
          <description>Search a nickname (or -part) on all servers.</description>
          <arguments>
            <argument token="N" description="nickname to search"/>
          </arguments>
        </command>

      </identifiers>
    </section>
    <!-- Serverbrowser Section Ends -->
    <!-- Server Commands Section Starts -->
    <section name="Server commands" sortindex="09">
      <description>
        This section lists commands used by the client that communicate to the server. Most are used for server administration.
        Also see the "mode" section and the "map" command which also communicate to the server.
      </description>
      <identifiers sort="true">

        <command name="serverdesc">
          <description>Sets user-define server description.</description>
          <arguments>
            <argument token="D" description="description"/>
          </arguments>
          <remarks>
            <remark>
            If the server was run with -n1 and -n2 arguments (prefix and suffix of descriptive title)
            a serveradmin can set a user-defined server description with this command, if it wasn't this command results
            in "invalid vote". This title will only stay until the next map is loaded.
            </remark>
            <remark>
            If, for example, the server was run with -n"Fred's Server" -n1"Fred's " -n2" Server",
            then you could call "/serverdesc [pWn4g3 TOSOK]" and it would show up as "Fred's pWn4g3 TOSOK Server"
            in the serverbrowser.
            </remark>
          </remarks>
        </command>

        <command name="serverextension">
          <description>Sends the extension name and argument string to the server, which can use it for custom action.</description>
          <remarks>
            <remark>See source/src/server.cpp ["case SV_EXTENSION:"].</remark>
          </remarks>
          <arguments>
            <argument token="E" description="extension name"/>
            <argument token="A" description="argument"/>
          </arguments>
        </command>

        <command name="autoteam">
          <description>Sets automated team assignment.</description>
          <references>
            <identifierReference identifier="setadmin"/>
          </references>
          <arguments>
            <argument token="B" description="Enables or disables auto team" valueNotes="1 (On), 0 (Off)"/>
          </arguments>
        </command>

        <command name="ban">
          <description>Temporary ban of the specified player from the server.</description>
          <arguments>
            <argument token="C" description="The player to ban" valueNotes="client number"/>
            <argument token="R" description="The reason" valueNotes="at least 4 characters"/>
          </arguments>
          <remarks>
            <remark>Temporary ban duration is fixed at 20 minutes.  </remark>
          </remarks>
          <references>
            <identifierReference identifier="removebans"/>
            <identifierReference identifier="setadmin"/>
          </references>
        </command>

        <command name="callvote">
          <description>Calls a vote on the server.</description>
          <arguments>
            <argument token="T" description="Vote type" valueNotes="value"/>
            <argument token="A" description="First argument" valueNotes=""/>
            <argument token="B" description="Second argument" valueNotes=""/>
          </arguments>
          <remarks>
            <remark>
            This command is wrapped by aliases for better usability and is used to action votes such as ban, kick, etc.
            See config/admin.cfg for actual uses.
            </remark>
          </remarks>
        </command>

        <command name="forceteam">
          <description>Calls a vote to force the specified player to switch to the specified team.</description>
          <references>
            <identifierReference identifier="forceme"/>
            <identifierReference identifier="setadmin"/>
          </references>
          <arguments>
            <argument token="C" description="client number of player" valueNotes="integer"/>
            <argument token="T" description="the team to force to" valueNotes="0-4"/>
          </arguments>
        </command>

        <command name="forceme">
          <description>Calls a vote to forceteam yourself to the specified team.</description>
          <arguments>
            <argument token="T" description="the team to force yourself to" valueNotes="0-4" optional="true"/>
          </arguments>
          <remarks>
            <remark>By default, if you are on team CLA or RVSF, this command will force you to the enemy team, no arguments necessary.</remark>
          </remarks>
          <references>
            <identifierReference identifier="forceteam"/>
          </references>
        </command>

        <command name="shuffleteams">
          <description>Shuffles the teams.</description>
          <remarks>
            <remark>The server will attempt to restore balance, but the result may be less that optimal, and there are certainly better ways to keep teams balanced.</remark>
          </remarks>
          <references>
            <identifierReference identifier="forceteam"/>
            <identifierReference identifier="forceme"/>
          </references>
        </command>

        <command name="giveadmin">
          <description>Gives admin state to the specified player.</description>
          <remarks>
            <remark>Requires admin state. The admin will lose his admin state after successfully issuing this command.</remark>
          </remarks>
          <references>
            <identifierReference identifier="setadmin"/>
          </references>
          <arguments>
            <argument token="C" description="The player to become admin" valueNotes="client number"/>
          </arguments>
        </command>

        <command name="kick">
          <description>Kicks the specified player from the server.</description>
          <arguments>
            <argument token="C" description="The player to kick" valueNotes="client number"/>
            <argument token="R" description="The reason" valueNotes="at least 4 characters"/>
          </arguments>
          <references>
            <identifierReference identifier="setadmin"/>
          </references>
        </command>

        <command name="mastermode">
          <description>Sets the mastermode for the server.</description>
          <remarks>
            <remark>
            If the mastermode is set to 'private', no more clients can join the server.
            Default is 'open' which allows anyone to join the server.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="setadmin"/>
          </references>
          <arguments>
            <argument token="N" description="The master mode" valueNotes="0 (Open), 1 (Private), 2 (Match)"/>
          </arguments>
        </command>

        <command name="removebans">
          <description>Removes all temporary bans from the server.</description>
          <remarks>
            <remark>Temporary bans are normally automatically removed after 20 minutes.</remark>
          </remarks>
          <references>
            <identifierReference identifier="ban"/>
            <identifierReference identifier="setadmin"/>
          </references>
        </command>

        <command name="cleardemo">
          <description>Clears specific demo currently in memory on the server.</description>
          <arguments>
            <argument token="X" description="number in list" valueNotes="0 (all), 1.."/>
          </arguments>
          <references>
            <identifierReference identifier="listdemos"/>
            <identifierReference identifier="cleardemos"/>
          </references>
        </command>

        <command name="cleardemos">
          <description>Clears all demos currently in memory on the server.</description>
          <references>
            <identifierReference identifier="cleardemo"/>
          </references>
        </command>

        <command name="sendmap">
          <description>Sends a map to the server.</description>
          <remarks>
            <remark>
            During coop edit, the current map gets saved to file and sent to the server.
            Other players can use 'getmap' to download it.
            </remark>
            <remark>
            When not in edit mode, the map will not be saved. The new map will be used, when
            the next game on that map starts on the server.
            </remark>
          </remarks>
          <arguments>
            <argument token="M" description="map to send" optional="true"/>
          </arguments>
          <references>
            <identifierReference identifier="getmap"/>
            <identifierReference identifier="dlmap"/>
          </references>
        </command>

        <command name="deleteservermap">
          <description>Deletes a map from the current server.</description>
          <arguments>
            <argument token="A" description="map name"/>
          </arguments>
        </command>

        <command name="setadmin">
          <description>Claims or drops admin status.</description>
          <remarks>
            <remark>
            Failed logins result in an auto kick.
            The admin is granted the right to kick, ban, remove bans, set autoteam, set shuffleteam, change server
            description (if enabled), change map, change mastermode, force team, change mode, record demos, stop demos
            and clear demo(s) - All without needing votes from other users.
            If the admin votes on any (other players) call, his vote is final.
            In the scoreboard, the admin will be shown as a red colour.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="kick"/>
            <identifierReference identifier="autoteam"/>
            <identifierReference identifier="mastermode"/>
            <identifierReference identifier="ban"/>
            <identifierReference identifier="removebans"/>
          </references>
          <arguments>
            <argument token="B" description="Status" valueNotes="1 (Claim), 0 (Drop)"/>
            <argument token="PASS" description="Password" valueNotes="case sensitive"/>
          </arguments>
        </command>

        <command name="getvita">
          <description>Get vita for a client.</description>
          <arguments>
            <argument token="C" description="client number"/>
          </arguments>
          <remarks>
            <remark>TODO: elaborate</remark>
          </remarks>
        </command>

        <variable name="serverdebug">
          <description>Whether or not to output debugging information.</description>
          <value token="B" description="boolean" minValue="0" maxValue="1" valueNotes="1:debug output" defaultValue="0"/>
          <remarks>
            <remark>Only applies if you're running a client, the standalone server has DEBUGCOND(true) already set.</remark>
          </remarks>
        </variable>

      </identifiers>
    </section>
    <!-- Server Commands Section Ends -->
    <!-- Authentication Section Starts -->
    <section name="Authentication" sortindex="10">
      <description>
        This section describes identifiers related to player authentication.
      </description>
      <identifiers sort="true">

        <command name="authsetup">
          <description>Manages player authentication.</description>
          <remarks>
            <remark>
            "authsetup" contains all the funtionality needed to generate, load and save private and public keys,
            and to lock and unlock the private key with a password.
            </remark>
            <remark>
            Private and public keys are used to authenticate the player to servers, and are loaded from private/authprivate.cfg.
            Private keys can be stored in an "encrypted with password" version - in which case the player has to enter
            the password after game start. To prevent brute-force cracking of the password, the key-derivation function uses
            a constant time to encode (usually several seconds). Because of that, the decoding at game start can be done
            in the background.
            </remark>
            <remark>
            The private key is actually itself a public key generated from the prepriv key.
            The prepriv key should be kept away from the computer, either as hardcopy or on a thumbdrive.
            The prepriv key is not required to play the game. It can be used to prove ownership of the private key,
            in case the private key gets stolen. It can also be used to regenerate private and public keys,
            in case they are lost. The prepriv key can also be encrypted by its own password.
            </remark>
            <remark>----------</remark>
            <remark>Options:</remark>
            <remark>"authsetup" - checks private and public key and returns "1", if they match.</remark>
            <remark>"authsetup pre preprivhex [psalthex pwdcfg]" - loads prepriv key into memory. Optionally supports encrypted keys.</remark>
            <remark>"authsetup priv privhex [salthex pwdcfg]" - loads private key into memory. Optionally supports encrypted keys.</remark>
            <remark>"authsetup pub pubhex" - loads public key into memory.</remark>
            <remark>"authsetup ppass preprivpass" - decrypts prepriv key with password.</remark>
            <remark>"authsetup pass privpass" - decrypts private key with password.</remark>
            <remark>
            "authsetup passd privpass [commandwhendone]" - decrypts private key with password in background.
            Optionally executes cubescript command when done.
            </remark>
            <remark>"authsetup needpass" - returns "1", if the private key needs decryption.</remark>
            <remark>"authsetup genpre [prelen]" - generates new prepriv key.</remark>
            <remark>"authsetup genpriv" - generates private key from prepriv key.</remark>
            <remark>"authsetup genpub" - generates public key from private key.</remark>
            <remark>"authsetup savepre [preprivfilename]" - saves the prepriv key. The default filename is private/authpreprivate.cfg</remark>
            <remark>"authsetup savepre [privatefilename]" - saves the private key. The default filename is private/authprivate.cfg</remark>
            <remark>
            "authsetup newppass preprivpass [preprivfilename]" - encrypts prepriv key with new password and saves the result to file.
            The default filename is private/authpreprivate.cfg and an existing file gets overwritten - but the former file
            content is kept and also written, each line commented out.
            </remark>
            <remark>
            "authsetup newpass privpass [privatefilename]" - encrypts private key with new password and saves the encrypted
            private key and the public key to file. The default filename is private/authprivate.cfg and an existing file 
            gets overwritten - but the former file content is kept and also written, each line commented out.
            </remark>
            <remark>"authsetup unarmed" - sets private and public keys to a fixed value. For testing only. Can be used to "log out". Only available in development versions of the game</remark>
            <remark>----------</remark>
            <remark>
            "authmemusage", "authrounds", "authmaxtime" are only used, when new passwords are created (authsetup new[p]pass).
            "authmemusage" is the number of megabytes of RAM that are used for the password hash calculation. If "authrounds"
            is zero (as is default), then the hash algorithm calculates as many rounds as possible in the number of milliseconds
            specified in "authmaxtime". If "authrounds" is a positive number, then that is the number of rounds to be done,
            regardless the required time. Note that, since the password hash algorithm is not endianness-aware, it is
            not possible to move an encrypted password to a machine with different endianness. Moving between 32- and 64-bit
            machines should be no problem.
            </remark>
          </remarks>
          <arguments>
            <argument token="P" description="parameter" valueNotes="[empty], pre preprivhex [psalthex pwdcfg], 
            priv privhex [salthex pwdcfg], pub pubhex, ppass preprivpass, pass privpass, passd privpass [commandwhendone], 
            needpass, genpre [prelen], genpriv, genpub, newppass preprivpass [preprivfilename], 
            newpass privpass [privatefilename], unarmed"/>
          </arguments>
          <references>
            <identifierReference identifier="authmemusage"/>
            <identifierReference identifier="authrounds"/>
            <identifierReference identifier="authmaxtime"/>
            <identifierReference identifier="authkey"/>
            <identifierReference identifier="mypubkey"/>
            <identifierReference identifier="cryptodebug"/>
          </references>
        </command>

        <variable name="authmemusage">
          <description>Sets a number of megabytes of RAM that are used for the password hash calculation (when new passwords are created).</description>
          <value token="N" description="number of RAM [MB]" minValue="2" maxValue="(1&lt;&lt;10)-1" defaultValue="24"/>
          <references>
            <identifierReference identifier="authsetup"/>
            <identifierReference identifier="authrounds"/>
            <identifierReference identifier="authmaxtime"/>
          </references>
        </variable>

        <variable name="authrounds">
          <description>Sets a number of rounds, if greater than 0, then new password hashes are created with this fixed number of rounds.</description>
          <value token="N" description="number of rounds" minValue="0" maxValue="2^31-1" defaultValue="0"/>
          <references>
            <identifierReference identifier="authsetup"/>
            <identifierReference identifier="authmemusage"/>
            <identifierReference identifier="authmaxtime"/>
          </references>
        </variable>

        <variable name="authmaxtime">
          <description>Sets an amount of time (in ms), new password hashes are created with this fixed amount of time.</description>
          <value token="N" description="amount of time [ms]" minValue="1&lt;&lt;9" maxValue="1&lt;&lt;16" defaultValue="1&lt;&lt;12"/>
          <references>
            <identifierReference identifier="authsetup"/>
            <identifierReference identifier="authmemusage"/>
            <identifierReference identifier="authrounds"/>
          </references>
        </variable>

        <command name="authkey">
          <description>Manages a list of keys other than the game key (which is managed by authsetup).</description>
          <remarks>
            <remark>For example, this can be server owner keys or clan boss keys. Options:</remark>
            <remark>"authkey clear" - empties the list and comments out all lines in config/authkeys.cfg.</remark>
            <remark>"authkey list" - lists all authkeys that are currently in memory.</remark>
            <remark>"authkey delete keyname" - deletes the key "keyname" from memory.</remark>
            <remark>
            "authkey new keyname" - generates a new key with the name "keyname". If a key of that name already exists,
            it is deleted. The key is added to the list in memory and also written to the file config/authkeys.cfg.
            </remark>
            <remark>
            "authkey add keyname privkey" - adds a key with the name "keyname" to the list in memory.
            The privkey is a 32-byte hexadecimal string, preferrably generated by authkey new. 
            The matching public key is generated automatically from the private key.
            </remark>
            <remark>
            "authkey selfcert keyname [comment]" - generates a self-signed certificate for the key "keyname". Being able to
            create such a cert is proof, that you own the private key of a certain public key.
            </remark>
          </remarks>
          <arguments>
            <argument token="P" description="parameter" valueNotes="clear, list, delete keyname, new keyname, 
            add keyname privkey, selfcert keyname [comment]"/>
          </arguments>
          <references>
            <identifierReference identifier="authsetup"/>
          </references>
        </command>

        <command name="mypubkey">
          <description>Returns a public key of game account.</description>
          <remarks>
            <remark>It returns empty string, if no account exists or it is unusable (due to missing password, for example).</remark>
          </remarks>
          <references>
            <identifierReference identifier="authsetup"/>
          </references>
        </command>

        <variable name="cryptodebug">
          <description>Enables some debug messages in crypto.cpp file.</description>
          <value token="N" description="enable debugging" minValue="0" maxValue="1" defaultValue="1"/>
          <references>
            <identifierReference identifier="authsetup"/>
          </references>
        </variable>

        <command name="listcerts">
          <description>List all certificates.</description>
          <remarks>
            <remark>TODO: elaborate</remark>
          </remarks>
        </command>

        <command name="newcert">
          <description>Create and sign certificates from Cubescript.</description>
          <arguments>
            <argument token="X" description="command" valueNotes="clear, start, line, sign"/>
            <argument token="A" description="linename or pubkey" valueNotes="X:line => pubkey or name; X:sign => actual privkey"/>
            <argument token="B" description="value or comment" valueNotes="X:line => actual pubkey, actual privkey or actual name, X:sign => a descriptive comment"/>
            <argument token="C" description="comment" valueNotes="newcert line name KEY => a descriptive comment"/>
          </arguments>
          <remarks>
            <remark>TODO: elaborate</remark>
          </remarks>
        </command>

      </identifiers>
    </section>
    <!-- Authentication Section Ends -->
    <!-- Game Modes Section Starts -->
    <section name="Game modes" sortindex="03">
      <identifiers sort="true">

        <command name="mode">
          <description>Sets the gameplay mode to N for the next map loaded.</description>
          <references>
            <wikiReference article="Gamemodes"/>
            <identifierReference identifier="map"/>
            <identifierReference identifier="gamemode"/>
            <identifierReference identifier="getmode"/>
            <identifierReference identifier="curmodeattr"/>
            <identifierReference identifier="modeacronyms"/>
            <identifierReference identifier="modenum"/>
            <identifierReference identifier="tdm"/>
            <identifierReference identifier="coop"/>
            <identifierReference identifier="dm"/>
            <identifierReference identifier="surv"/>
            <identifierReference identifier="tsurv"/>
            <identifierReference identifier="ctf"/>
            <identifierReference identifier="tpf"/>
            <identifierReference identifier="pf"/>
            <identifierReference identifier="tlss"/>
            <identifierReference identifier="lss"/>
            <identifierReference identifier="osok"/>
            <identifierReference identifier="tosok"/>
            <identifierReference identifier="htf"/>
            <identifierReference identifier="tktf"/>
            <identifierReference identifier="ktf"/>
            <identifierReference identifier="btdm"/>
            <identifierReference identifier="bdm"/>
            <identifierReference identifier="bpf"/>
            <identifierReference identifier="blss"/>
            <identifierReference identifier="btsurv"/>
            <identifierReference identifier="bosok"/>
            <identifierReference identifier="btosok"/>
          </references>
          <arguments>
            <argument token="N" valueNotes="0" description="Team Deathmatch"/>
            <argument valueNotes="1" description="Co-op edit"/>
            <argument valueNotes="2" description="Deathmatch"/>
            <argument valueNotes="3" description="Survivor"/>
            <argument valueNotes="4" description="Team Survivor"/>
            <argument valueNotes="5" description="Capture the Flag"/>
            <argument valueNotes="6" description="Pistol Frenzy"/>
            <argument valueNotes="7" description="Bot Team Deathmatch"/>
            <argument valueNotes="8" description="Bot Deathmatch"/>
            <argument valueNotes="9" description="Last Swiss Standing"/>
            <argument valueNotes="10" description="One Shot, One Kill"/>
            <argument valueNotes="11" description="Team One Shot, One Kill"/>
            <argument valueNotes="12" description="Bot One Shot, One Kill"/>
            <argument valueNotes="13" description="Hunt the Flag"/>
            <argument valueNotes="14" description="Team Keep the Flag"/>
            <argument valueNotes="15" description="Keep the Flag"/>
            <argument valueNotes="16" description="Team Pistol Frenzy"/>
            <argument valueNotes="17" description="Team Last Swiss Standing"/>
            <argument valueNotes="18" description="Bot Pistol Frenzy"/>
            <argument valueNotes="19" description="Bot Last Swiss Standing"/>
            <argument valueNotes="20" description="Bot Team Survivor"/>
            <argument valueNotes="21" description="Bot Team One Shot, One Kill"/>
          </arguments>
          <remarks>
            <remark>You will need to define mode before loading the map or it will stay as the last mode played.</remark>
            <remark>There are many aliases for you to use instead of remembering the numeric mapping.</remark>
          </remarks>
          <examples>
            <example>
              <code><![CDATA[mode 7; map ac_complex; echo "Bot Team Deathmatch on ac_complex"]]></code>
            </example>
            <example>
              <code><![CDATA[mode 8; map ac_mines 4; echo "Bot Deathmatch on ac_mines for 4 minutes"]]></code>
            </example>
            <example>
              <code><![CDATA[mode 5; map ac_shine; echo "CTF @ ac_shine"]]></code>
            </example>
          </examples>
        </command>

        <command name="getmode">
          <description>Returns the name of current game mode.</description>
          <examples>
            <example>
              <code><![CDATA[echo (getmode)]]></code>
              <explanation>Example output: capture the flag</explanation>
            </example>
            <example>
              <code><![CDATA[echo (getmode 1)]]></code>
              <explanation>Example output: CTF</explanation>
            </example>
          </examples>
          <arguments>
            <argument token="N" description="0 = full mode name, 1 = mode acronym" valueNotes="min 0/max 1/default 0"/>
          </arguments>
          <references>
            <identifierReference identifier="mode"/>
            <identifierReference identifier="modeacronyms"/>
            <identifierReference identifier="gamemode"/>
            <identifierReference identifier="curmodeattr"/>
          </references>
        </command>

        <variable name="gamemode">
          <description>Returns the number of current game mode.</description>
          <examples>
            <example>
              <code><![CDATA[echo $gamemode]]></code>
              <explanation>Output: 5</explanation>
            </example>
          </examples>
          <references>
            <identifierReference identifier="mode"/>
            <identifierReference identifier="getmode"/>
            <identifierReference identifier="curmodeattr"/>
          </references>
        </variable>

        <command name="curmodeattr">
          <description>Checks the current game mode for certain attributes.</description>
          <arguments>
            <argument token="A" description="attribute name"/>
          </arguments>
          <remarks>
            <remark>Possible attributes are: team, arena, flag and bot.</remark>
          </remarks>
          <references>
            <identifierReference identifier="mode"/>
            <identifierReference identifier="gamemode"/>
            <identifierReference identifier="getmode"/>
          </references>
        </command>

        <variable name="modeacronyms">
          <description>Toggles use of acronyms instead of full modenames in the serverbrowser, scoreboard, voting info.</description>
          <value token="B" description="" minValue="0" maxValue="1" defaultValue="0"/>
          <references>
            <identifierReference identifier="mode"/>
            <identifierReference identifier="getmode"/>
            <identifierReference identifier="modenum"/>
          </references>
        </variable>

        <command name="modenum">
          <description>Returns the mode number for a specified mode acronym.</description>
          <examples>
            <example>
              <code><![CDATA[echo (modenum ctf)]]></code>
              <explanation>Output: 5</explanation>
            </example>
            <example>
              <code><![CDATA[echo (modenum btosok)]]></code>
              <explanation>Output: 21</explanation>
            </example>
          </examples>
          <arguments>
            <argument token="M" description="the mode acronym"/>
          </arguments>
          <remarks>
            <remark>Returns -1 if not found.</remark>
          </remarks>
          <references>
            <identifierReference identifier="mode"/>
            <identifierReference identifier="modeacronyms"/>
          </references>
        </command>

        <command name="gamemodedesc">
          <arguments>
            <argument token="M" description="mode" valueNotes="integer"/>
            <argument token="D" description="description" valueNotes="string"/>
          </arguments>
          <references>
            <identifierReference identifier="mode"/>
            <identifierReference identifier="showmodedescriptions"/>
          </references>
        </command>

        <variable name="showmodedescriptions">
          <description>Enables or disables the showing of game mode descriptions on the console after map starts.</description>
          <value token="B" description="0 off, 1 on" minValue="0" maxValue="1" defaultValue="1"/>
          <references>
            <identifierReference identifier="mode"/>
            <identifierReference identifier="gamemodedesc"/>
          </references>
        </variable>

        <command name="coop">
          <description>Starts a map with the mode "Co-operative Editing".</description>
          <remarks>
            <remark>
              See the "Co-operative map editing" section on the "Tips, tricks and advice" chapter
              of the map editing guide for more information.
            </remark>
          </remarks>
          <examples>
            <example>
              <code><![CDATA[coop ac_newmap]]></code>
            </example>
          </examples>
          <arguments>
            <argument token="M" description="The name of the map you wish to edit"/>
          </arguments>
        </command>

        <command name="ctf">
          <description>Starts a map with the mode "Capture the Flag".</description>
          <examples>
            <example>
              <code><![CDATA[ctf ac_mines]]></code>
            </example>
          </examples>
          <arguments>
            <argument token="M" description="The name of the map you wish to play"/>
            <argument token="T" valueNotes="1..60" description="The time limit, in minutes (default 15 minutes if T is 0 or not specified)"/>
          </arguments>
        </command>

        <command name="dm">
          <description>Starts a map with the mode "Deathmatch".</description>
          <examples>
            <example>
              <code><![CDATA[dm ac_complex]]></code>
            </example>
          </examples>
          <arguments>
            <argument token="M" description="The name of the map you wish to play"/>
            <argument token="T" valueNotes="1..60" description="The time limit, in minutes (default 10 minutes if T is 0 or not specified)"/>
          </arguments>
        </command>

        <command name="htf">
          <description>Starts a map with the mode "Hunt the Flag".</description>
          <examples>
            <example>
              <code><![CDATA[htf ac_mines]]></code>
            </example>
          </examples>
          <arguments>
            <argument token="M" description="The name of the map you wish to play"/>
            <argument token="T" valueNotes="1..60" description="The time limit, in minutes (default 15 minutes if T is 0 or not specified)"/>
          </arguments>
        </command>

        <command name="ktf">
          <description>Starts a map with the mode "Keep the Flag".</description>
          <examples>
            <example>
              <code><![CDATA[ktf ac_mines]]></code>
            </example>
          </examples>
          <arguments>
            <argument token="M" description="The name of the map you wish to play"/>
            <argument token="T" valueNotes="1..60" description="The time limit, in minutes (default 10 minutes if T is 0 or not specified)"/>
          </arguments>
        </command>

        <command name="lms">
          <description>Starts a map with the mode "Survivor". Some players prefer the name "Last Man Standing" for this mode.</description>
          <examples>
            <example>
              <code><![CDATA[lms ac_complex]]></code>
            </example>
          </examples>
          <arguments>
            <argument token="M" description="The name of the map you wish to play"/>
            <argument token="T" valueNotes="1..60" description="The time limit, in minutes (default 10 minutes if T is 0 or not specified)"/>
          </arguments>
        </command>

        <command name="lss">
          <description>Starts a map with the mode "Last Swiss Standing".</description>
          <examples>
            <example>
              <code><![CDATA[lss ac_complex]]></code>
            </example>
          </examples>
          <arguments>
            <argument token="M" description="The name of the map you wish to play"/>
            <argument token="T" valueNotes="1..60" description="The time limit, in minutes (default 10 minutes if T is 0 or not specified)"/>
          </arguments>
        </command>

        <command name="osok">
          <description>Starts a map with the mode "One Shot, One Kill".</description>
          <examples>
            <example>
              <code><![CDATA[osok ac_complex]]></code>
            </example>
          </examples>
          <arguments>
            <argument token="M" description="The name of the map you wish to play"/>
            <argument token="T" valueNotes="1..60" description="The time limit, in minutes (default 10 minutes if T is 0 or not specified)"/>
          </arguments>
        </command>

        <command name="pf">
          <description>Starts a map with the mode "Pistol Frenzy".</description>
          <examples>
            <example>
              <code><![CDATA[pf ac_complex]]></code>
            </example>
          </examples>
          <arguments>
            <argument token="M" description="The name of the map you wish to play"/>
            <argument token="T" valueNotes="1..60" description="The time limit, in minutes (default 10 minutes if T is 0 or not specified)"/>
          </arguments>
        </command>

        <command name="tdm">
          <description>Starts a map with the mode "Team Deathmatch".</description>
          <examples>
            <example>
              <code><![CDATA[tdm ac_complex]]></code>
            </example>
          </examples>
          <arguments>
            <argument token="M" description="The name of the map you wish to play"/>
            <argument token="T" valueNotes="1..60" description="The time limit, in minutes (default 15 minutes if T is 0 or not specified)"/>
          </arguments>
        </command>

        <command name="tktf">
          <description>Starts a map with the mode "Team Keep the Flag".</description>
          <examples>
            <example>
              <code><![CDATA[tktf ac_mines]]></code>
            </example>
          </examples>
          <arguments>
            <argument token="M" description="The name of the map you wish to play"/>
            <argument token="T" valueNotes="1..60" description="The time limit, in minutes (default 15 minutes if T is 0 or not specified)"/>
          </arguments>
        </command>

        <command name="tosok">
          <description>Starts a map with the mode "Team One Shot, One Kill".</description>
          <examples>
            <example>
              <code><![CDATA[tosok ac_complex]]></code>
            </example>
          </examples>
          <arguments>
            <argument token="M" description="The name of the map you wish to play"/>
            <argument token="T" valueNotes="1..60" description="The time limit, in minutes (default 15 minutes if T is 0 or not specified)"/>
          </arguments>
        </command>

        <command name="tsurv">
          <description>Starts a map with the mode "Team Survivor".</description>
          <examples>
            <example>
              <code><![CDATA[tsurv ac_complex]]></code>
            </example>
          </examples>
          <arguments>
            <argument token="M" description="The name of the map you wish to play"/>
            <argument token="T" valueNotes="1..60" description="The time limit, in minutes (default 15 minutes if T is 0 or not specified)"/>
          </arguments>
        </command>

        <command name="vip">
          <description>Starts a map with the mode "Hunt the Flag". Some players prefer the name "VIP" for this mode.</description>
          <examples>
            <example>
              <code><![CDATA[vip ac_mines]]></code>
            </example>
          </examples>
          <arguments>
            <argument token="M" description="The name of the map you wish to play"/>
            <argument token="T" valueNotes="1..60" description="The time limit, in minutes (default 15 minutes if T is 0 or not specified)"/>
          </arguments>
        </command>

        <command name="surv">
          <description>Starts a map with the mode "Survivor".</description>
          <examples>
            <example>
              <code><![CDATA[surv ac_complex]]></code>
            </example>
          </examples>
          <arguments>
            <argument token="M" description="The name of the map you wish to play"/>
            <argument token="T" valueNotes="1..60" description="The time limit, in minutes (default 10 minutes if T is 0 or not specified)"/>
          </arguments>
        </command>

        <command name="tpf">
          <description>Starts a map with the mode "Team Pistol Frenzy".</description>
          <examples>
            <example>
              <code><![CDATA[tpf ac_complex]]></code>
            </example>
          </examples>
          <arguments>
            <argument token="M" description="The name of the map you wish to play"/>
            <argument token="T" valueNotes="1..60" description="The time limit, in minutes (default 15 minutes if T is 0 or not specified)"/>
          </arguments>
        </command>

        <command name="tlss">
          <description>Starts a map with the mode "Team Last Swiss Standing".</description>
          <examples>
            <example>
              <code><![CDATA[tlss ac_complex]]></code>
            </example>
          </examples>
          <arguments>
            <argument token="M" description="The name of the map you wish to play"/>
            <argument token="T" valueNotes="1..60" description="The time limit, in minutes (default 15 minutes if T is 0 or not specified)"/>
          </arguments>
        </command>

        <command name="bpf">
          <description>Starts a map with the mode "Bot Pistol Frenzy".</description>
          <examples>
            <example>
              <code><![CDATA[bpf ac_complex]]></code>
            </example>
          </examples>
          <arguments>
            <argument token="M" description="The name of the map you wish to play"/>
            <argument token="T" valueNotes="1..60" description="The time limit, in minutes (default 10 minutes if T is 0 or not specified)"/>
          </arguments>
        </command>

        <command name="blss">
          <description>Starts a map with the mode "Bot Last Swiss Standing".</description>
          <examples>
            <example>
              <code><![CDATA[blss ac_complex]]></code>
            </example>
          </examples>
          <arguments>
            <argument token="M" description="The name of the map you wish to play"/>
            <argument token="T" valueNotes="1..60" description="The time limit, in minutes (default 10 minutes if T is 0 or not specified)"/>
          </arguments>
        </command>

        <command name="btdm">
          <description>Starts a map with the mode "Bot Team Deathmatch".</description>
          <examples>
            <example>
              <code><![CDATA[btdm ac_complex]]></code>
            </example>
          </examples>
          <arguments>
            <argument token="M" description="The name of the map you wish to play"/>
            <argument token="T" valueNotes="1..60" description="The time limit, in minutes (default 15 minutes if T is 0 or not specified)"/>
          </arguments>
        </command>

        <command name="bdm">
          <description>Starts a map with the mode "Bot Deathmatch".</description>
          <examples>
            <example>
              <code><![CDATA[bdm ac_complex]]></code>
            </example>
          </examples>
          <arguments>
            <argument token="M" description="The name of the map you wish to play"/>
            <argument token="T" valueNotes="1..60" description="The time limit, in minutes (default 10 minutes if T is 0 or not specified)"/>
          </arguments>
        </command>

        <command name="btsurv">
          <description>Starts a map with the mode "Bot Team Survivor".</description>
          <examples>
            <example>
              <code><![CDATA[btsurv ac_complex]]></code>
            </example>
          </examples>
          <arguments>
            <argument token="M" description="The name of the map you wish to play"/>
            <argument token="T" valueNotes="1..60" description="The time limit, in minutes (default 15 minutes if T is 0 or not specified)"/>
          </arguments>
        </command>

        <command name="bosok">
          <description>Starts a map with the mode "Bot One Shot, One Kill".</description>
          <examples>
            <example>
              <code><![CDATA[bosok ac_complex]]></code>
            </example>
          </examples>
          <arguments>
            <argument token="M" description="The name of the map you wish to play"/>
            <argument token="T" valueNotes="1..60" description="The time limit, in minutes (default 10 minutes if T is 0 or not specified)"/>
          </arguments>
        </command>

        <command name="btosok">
          <description>Starts a map with the mode "Bot Team One Shot, One Kill".</description>
          <examples>
            <example>
              <code><![CDATA[btosok ac_complex]]></code>
            </example>
          </examples>
          <arguments>
            <argument token="M" description="The name of the map you wish to play"/>
            <argument token="T" valueNotes="1..60" description="The time limit, in minutes (default 15 minutes if T is 0 or not specified)"/>
          </arguments>
        </command>

      </identifiers>
    </section>
    <!-- Game Modes Section Ends -->
    <!-- Editing Configs Section Starts -->
    <section name="Editing configs" sortindex="12">
      <description>
        All the below commands are used specifically in map configuration files.
        Some of these commands can also be used without the need of a map configuration file.
      </description>
      <identifiers sort="true">

        <command name="md2anim">
          <arguments>
            <argument token="A" description="anim"/>
            <argument token="F" description="frame"/>
            <argument token="R" description="range"/>
            <argument token="S" description="speed"/>
          </arguments>
        </command>

        <command name="md2emit">
          <arguments>
            <argument token="T" description="tag name"/>
            <argument token="Y" description="particle type (integer or name)" valueNotes="SPARK (0), SMOKE (1), ECLOSEST (2),
            BLOOD (3), DEMOTRACK (4), FIREBALL (5), SHOTLINE (6), BULLETHOLE (7), BLOODSTAIN (8), SCORCH (9), HUDMUZZLEFLASH (10),
            MUZZLEFLASH (11), ELIGHT (12), ESPAWN (13), EAMMO (14), EPICKUP (15), EMODEL (16), ECARROT (17), ELADDER (18), EFLAG (19)"/>
            <argument token="A" description="attribute 1"/>
            <argument token="B" description="attribute 2"/>
          </arguments>
        </command>

        <command name="md2tag">
          <arguments>
            <argument token="N" description="name"/>
            <argument token="A" description="vert1"/>
            <argument token="B" description="vert2"/>
            <argument token="C" description="vert3"/>
            <argument token="D" description="vert4"/>
          </arguments>
        </command>

        <command name="md3anim">
          <arguments>
            <argument token="A" description="anim"/>
            <argument token="S" description="startframe"/>
            <argument token="R" description="range"/>
            <argument token="V" description="speed"/>
          </arguments>
        </command>

        <command name="md3emit">
          <arguments>
            <argument token="T" description="tag name"/>
            <argument token="Y" description="particle type (integer or name)" valueNotes="SPARK (0), SMOKE (1), ECLOSEST (2),
            BLOOD (3), DEMOTRACK (4), FIREBALL (5), SHOTLINE (6), BULLETHOLE (7), BLOODSTAIN (8), SCORCH (9), HUDMUZZLEFLASH (10),
            MUZZLEFLASH (11), ELIGHT (12), ESPAWN (13), EAMMO (14), EPICKUP (15), EMODEL (16), ECARROT (17), ELADDER (18), EFLAG (19)"/>
            <argument token="A" description="attribute 1"/>
            <argument token="B" description="attribute 2"/>
          </arguments>
        </command>

        <command name="md3link">
          <arguments>
            <argument token="P" description="parentno"/>
            <argument token="C" description="childno"/>
            <argument token="T" description="tag name"/>
          </arguments>
        </command>

        <command name="md3load">
          <arguments>
            <argument token="M" description="model"/>
          </arguments>
        </command>

        <command name="md3skin">
          <arguments>
            <argument token="N" description="object name"/>
            <argument token="S" description="skin texture"/>
          </arguments>
        </command>

        <command name="mdlalphatest">
          <arguments>
            <argument token="A" description="alphatest"/>
          </arguments>
        </command>

        <command name="mdlalphablend">
          <arguments>
            <argument token="A" description="alphablend"/>
          </arguments>
        </command>

        <command name="mdlcachelimit">
          <arguments>
            <argument token="L" description="cachelimit"/>
          </arguments>
        </command>

        <command name="mdlcullface">
          <arguments>
            <argument token="C" description="cullface" valueNotes="0 or 1"/>
          </arguments>
        </command>

        <command name="mdlscale">
          <arguments>
            <argument token="P" description="percent" valueNotes="0..100..N*100"/>
          </arguments>
        </command>

        <command name="mdlshadowdist">
          <arguments>
            <argument token="D" description="shadow distance"/>
          </arguments>
        </command>

        <command name="mdltrans">
          <description>Translates (= moves) the model.</description>
          <arguments>
            <argument token="X"/>
            <argument token="Y"/>
            <argument token="Z"/>
          </arguments>
        </command>

        <command name="mdltranslucent">
          <arguments>
            <argument token="T" description="translucency" valueNotes="0..100..N*100"/>
          </arguments>
        </command>

        <command name="mdlvertexlight">
          <arguments>
            <argument token="V" description="vertexligh" valueNotes="0 or 1"/>
          </arguments>
        </command>

        <command name="mdlattribute">
          <description>Adds a value for a specified attribute to the model.</description>
          <remarks>
            <remark>
            If used, specifies that the current model depends on parts of another custom model
            (which therefore also has to be downloaded) can only be used once per model config.
            </remark>
            <remark>
            Example: 'mdlattribute' requires 'makke/signs/exit' could be used in 'signs/loading-dock/md2.cfg'
            to reuse 'makke/signs/exit/tris.md2' .
            </remark>
          </remarks>
          <arguments>
            <argument token="A" description="attribute" valueNotes="keywords, desc, defaults, usage, author, license, distribution, version, requires"/>
            <argument token="V" description="value" valueNotes=""/>
          </arguments>
          <references>
            <identifierReference identifier="getmapmodelattributes"/>
            <identifierReference identifier="listallmapmodelattributes"/>
            <identifierReference identifier="mapmodelregister"/>
          </references>
        </command>

        <variable name="fog">
          <description>Sets the fog distance.</description>
          <value token="N" description="The fog distance" minValue="64" maxValue="1024" valueNotes="distance in cubes" defaultValue="180"/>
          <remarks>
            <remark>
            You can do this for tweaking the visual effect of the fog, or if you are on a slow machine,
            setting the fog to a low value can also be a very effective way to increase fps (if you are geometry limited).
            Try out different values on big maps / maps which give you low fps. It is also good for aesthetic features of maps
            especially when combined with "fogcolour".
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="fogcolour"/>
          </references>
        </variable>

        <variable name="fogcolour">
          <description>Sets the fog and clearing colour.</description>
          <value token="C" description="The colour" minValue="0" maxValue="16777215" valueNotes="Hexadecimal colour" defaultValue="0x8099B3"/>
          <references>
            <identifierReference identifier="fog"/>
          </references>
        </variable>

        <command name="loadnotexture">
          <description>Binds a texture to be used if a slot couldn't be loaded with a given textures path.</description>
          <remarks>
            <remark>
            Binds the texture indicated in the filename to the texture slot of any textures that aren't found.
            The path is given exactly as with the texture-command, if it is omitted (or can't be loaded) the default is used.
            The default is located in packages/misc/notexture.jpg (not in packages/textures - where custom ones must reside!)
            </remark>
          </remarks>
          <examples>
            <example>
              <code><![CDATA[loadnotexture // Reset to default]]></code>
            </example>
            <example>
              <code><![CDATA[loadnotexture "makke/black.jpg" // Any missing texture will show up black]]></code>
            </example>
          </examples>
          <references>
            <identifierReference identifier="texture"/>
            <identifierReference identifier="texturereset"/>
            <identifierReference identifier="getnotexture"/>
          </references>
          <arguments>
            <argument token="F" description="file name of the texture to bind" valueNotes="string"/>
          </arguments>
        </command>

        <command name="getnotexture">
          <description>Returns the current "notexture" path (set by loadnotexture).</description>
          <references>
            <identifierReference identifier="loadnotexture"/>
          </references>
          <examples>
            <example>
              <code><![CDATA[echo (getnotexture)]]></code>
            </example>
          </examples>
        </command>

        <variable name="loadsky">
          <description>Loads a skymap for a map.</description>
          <remarks>
            <remark>The available skymaps reside in packages/textures/skymaps/..</remark>
            <remark>
            The skymap name in the argument is required to start with "textures/skymaps/",
            but that part of the path can be omitted, and it should be used only up to the underscore "_" in the filename.
            </remark>
            <remark>You can get the current skymap name with the $loadsky variable.</remark>
          </remarks>
          <examples>
            <example>
              <code><![CDATA[loadsky makke/mountain]]></code>
            </example>
            <example>
              <code><![CDATA[loadsky textures/skymaps/makke/mountain]]></code>
            </example>
          </examples>
          <arguments>
            <argument token="P" description="path to skymap textures" valueNotes="string"/>
          </arguments>
        </variable>

        <command name="mapmodel">
          <description>Registers a mapmodel that can be placed in maps.</description>
          <remarks>
            <remark>
            A mapmodel registered with this command can be placed in a map using the 'newent mapmodel' command.
            The bounding box is an invisible force surrounding the model, allowing players to collide against it, instead
            of walking through the mapmodel. For more information about this command, read mapediting5.xml.
            </remark>
            <remark>Example: mapmodel 4 2 4 0 "modelname"</remark>
            <remark>This mapmodel has a bounding box of 8x8x2 in size (X/Y/Z) and by default hovers 4 units above ground.</remark>
            <remark>It also returns the number of the created slot, example: echo (mapmodel ...)</remark>
          </remarks>
          <references>
            <identifierReference identifier="newent mapmodel"/>
            <identifierReference identifier="mapmodelreset"/>
            <identifierReference identifier="loadallmapmodels"/>
            <identifierReference identifier="mapmodelslotname"/>
            <identifierReference identifier="mapmodelslotbyname"/>
            <identifierReference identifier="mapmodelslotusage"/>
            <identifierReference identifier="editmapmodelslot"/>
            <identifierReference identifier="deletemapmodelslot"/>
            <identifierReference identifier="sortmapmodelslots"/>
            <identifierReference identifier="mapmodelchanged"/>
            <identifierReference identifier="listallmapmodelattributes"/>
            <identifierReference identifier="getmapmodelattributes"/>
          </references>
          <arguments>
            <argument token="R" description="The square radius of the bounding box." valueNotes="integer"/>
            <argument token="H" description="The height of the bounding box." valueNotes="integer"/>
            <argument token="Z" description="The initial height offset from the ground." valueNotes="integer"/>
            <argument token="0" description="This integer is redundant. Leave it at zero so you don't break the command." valueNotes="0"/>
            <argument token="N" description="The name of the map model" valueNotes="string"/>
            <argument token="F" description="If '1', the model is preloaded, even if no entities use it" optional="true" valueNotes="1"/>
          </arguments>
        </command>

        <command name="mapmodelreset">
          <description>Resets the mapmodel slots/indices to 0 for the subsequent "mapmodel" commands.</description>
          <remarks>
            <remark>Each subsequent mapmodel command increases it again. See config/default_map_settings.cfg for an example.</remark>
          </remarks>
          <references>
            <identifierReference identifier="mapmodel"/>
            <identifierReference identifier="newent mapmodel"/>
          </references>
        </command>

        <command name="mapsound">
          <description>Defines a mapsound.</description>
          <remarks>
            <remark>
            Registers the sound as a map-specific sound. These map-specific sounds may currently
            only be used with "sound" entities within a map. The first map sound registered in a map has slot/index number 0
            and increases afterwards.
            </remark>
            <remark>It also returns the number of the created slot, example: echo (mapsound ...)</remark>
          </remarks>
          <references>
            <identifierReference identifier="newent sound"/>
            <identifierReference identifier="mapsoundreset"/>
            <identifierReference identifier="getmapsoundlist"/>
            <identifierReference identifier="getmapsoundorigin"/>
            <identifierReference identifier="mapsoundslotbyname"/>
            <identifierReference identifier="mapsoundslotusage"/>
            <identifierReference identifier="editmapsoundslot"/>
            <identifierReference identifier="deletemapsoundslot"/>
            <identifierReference identifier="sortmapsoundslots"/>
            <identifierReference identifier="mapsoundchanged"/>
          </references>
          <arguments>
            <argument token="P" description="Path to the sound file"/>
            <argument token="M" description="Maximum simultaneous sounds/maxuses" optional="true" valueNotes="default -1 (unlimited)"/>
          </arguments>
        </command>

        <command name="mapsoundreset">
          <description>Resets the mapsound slots/indices to 0 for the subsequent "mapsound" commands.</description>
          <remarks>
            <remark>Each subsequent mapsound command increases it again. See config/default_map_settings.cfg for an example.</remark>
          </remarks>
          <references>
            <identifierReference identifier="newent sound"/>
            <identifierReference identifier="mapsound"/>
          </references>
        </command>

        <command name="texture">
          <description>Binds a texture to the current texture slot.</description>
          <remarks>
            <remark>Binds the texture indicated in the filename to the current texture slot and increments the slot number.</remark>
            <remark>The texture is rendered at the given scale. At scale 1.0 (or if scale is 0), 32x32 texels cover one cube. At scale 2.0, which is the current maximum, it's 64x64.</remark>
            <remark>It also returns the number of the created slot, example: echo (texture ...)</remark>
          </remarks>
          <references>
            <identifierReference identifier="loadnotexture"/>
            <identifierReference identifier="texturereset"/>
            <identifierReference identifier="hirestextures"/>
            <identifierReference identifier="gettexturelist"/>
            <identifierReference identifier="gettextureorigin"/>
            <identifierReference identifier="textureslotusage"/>
            <identifierReference identifier="textureslotusagelist"/>
            <identifierReference identifier="textureslotbyname"/>
            <identifierReference identifier="deletetextureslot"/>
            <identifierReference identifier="edittextureslot"/>
            <identifierReference identifier="edittexturestack"/>
            <identifierReference identifier="sorttextureslots"/>
          </references>
          <arguments>
            <argument token="S" description="Scale of the texture to load (should be a power of two)." valueNotes="Float"/>
            <argument token="F" description="File name of the texture to bind" valueNotes="string"/>
          </arguments>
        </command>

        <command name="texturereset">
          <description>Sets the texture slots/indicies to 0 for the subsequent "texture" commands.</description>
          <remarks>
            <remark>Each subsequent texture command increases it again. See config/default_map_settings.cfg for an example.</remark>
          </remarks>
          <references>
            <identifierReference identifier="texture"/>
          </references>
        </command>

        <command name="watercolour">
          <description>Determines the water colour in a map.</description>
          <remarks>
            <remark>
            You must define at least 3 first values, otherwise this command may not work
            correctly (use "1" as a placeholder if needed).
            </remark>
          </remarks>
          <arguments>
            <argument token="R" description="red colour intensity" valueNotes="1..255"/>
            <argument token="G" description="green colour intensity" valueNotes="1..255"/>
            <argument token="B" description="blue colour intensity" valueNotes="1..255"/>
            <argument token="A" description="alpha value (transparency)" valueNotes="0..255 (default 178)"/>
          </arguments>
          <references>
            <identifierReference identifier="getwatercolour"/>
            <identifierReference identifier="setwatercolour"/>
            <identifierReference identifier="waterlevel"/>
          </references>
        </command>

        <command name="hexbinchunk">
          <description>Part of a map file</description>
          <arguments>
            <argument token="C" description="chunk of mapdata" valueNotes="up to 24 bytes in hex"/>
          </arguments>
          <remarks>
            <remark>Internal – for XMAP – not intended for manual use</remark>
          </remarks>
          <references>
            <identifierReference identifier="restorexmap"/>
          </references>
        </command>

        <command name="restorexmap">
          <description>Declaration of map parts.</description>
          <arguments>
            <argument token="*" description="many combinations" valueNotes="read the source"/>
          </arguments>
          <remarks>
            <remark>Internal – for XMAP – not intended for manual use</remark>
          </remarks>
          <references>
            <identifierReference identifier="hexbinchunk"/>
          </references>
        </command>

        <variable name="persistentxmaps">
          <description>Whether or not to save all xmaps on exist and restore them at game start.</description>
          <value token="B" description="boolean" minValue="0" maxValue="1" valueNotes="1:persistent" defaultValue="1"/>
          <remarks>
            <remark>XMAP allows for visual comparison between maps.</remark>
            <remark>TODO: elaborate</remark>
          </remarks>
          <references>
            <identifierReference identifier="xmap_list"/>
          </references>
        </variable>

      </identifiers>
    </section>
    <!-- Editing Configs Section Ends -->
    <!-- Bot mode Section Starts -->
    <section name="Bot mode" sortindex="15">
      <description>This section describes bot mode related identifiers. See also "docs/cube_bot-readme.txt".</description>
      <identifiers sort="true">

        <command name="idlebots">
          <description>Enables or disables the processing of the bots artificial intelligence.</description>
          <arguments>
            <argument token="T" description="off OR on" valueNotes="0 or 1"/>
          </arguments>
          <examples>
            <example>
              <code><![CDATA[idlebots 1]]></code>
              <explanation>Will make the bots stand still.</explanation>
            </example>
            <example>
              <code><![CDATA[idlebots 0]]></code>
              <explanation>Will enable the bots to move and shoot.</explanation>
            </example>
          </examples>
        </command>

        <command name="kickallbots">
          <description>Kicks all bots out of the current game.</description>
        </command>

        <command name="kickbot">
          <description>Kicks the bot with the given name out of the current game.</description>
          <arguments>
            <argument token="N" description="botname" valueNotes="name of the bot to kick."/>
          </arguments>
          <examples>
            <example>
              <code><![CDATA[kickbot Robbie]]></code>
              <explanation>Will make the bot named "Robbie" dissapear from the current game.</explanation>
            </example>
          </examples>
        </command>

        <command name="addbot">
          <description>Adds a bot for a given team with a given skill calling him a given name.</description>
          <arguments>
            <argument token="T" description="team" valueNotes="RVSF or CLA"/>
            <argument token="S" description="skill" valueNotes="best, good, medium, worse, bad"/>
            <argument token="N" description="name" valueNotes="name for the bot"/>
          </arguments>
          <remarks>
            <remark>This command only works for single player modes.</remark>
          </remarks>
          <examples>
            <example>
              <code><![CDATA[addbot RVSF medium Robbie]]></code>
              <explanation>Will add a bot named Robbie with a medium skill level to the RVSF team.</explanation>
            </example>
          </examples>
        </command>

        <command name="addnbot">
          <description>Adds a given count of bots for the given team with the given skill and select random names for them.</description>
          <arguments>
            <argument token="C" description="count" valueNotes="how many bots to add"/>
            <argument token="T" description="team" valueNotes="RVSF or CLA"/>
            <argument token="S" description="skill" valueNotes="best, good, medium, worse, bad"/>
          </arguments>
          <remarks>
            <remark>This command only works for single player modes.</remark>
            <remark>The name of the bots will be selected randomly.</remark>
          </remarks>
          <examples>
            <example>
              <code><![CDATA[addnbot 2 CLA bad]]></code>
              <explanation>Will add 2 bots with a bad skill level to the CLA team.</explanation>
            </example>
          </examples>
        </command>

        <command name="botskill">
          <description>Changes the skill level for the given bot.</description>
          <arguments>
            <argument token="N" description="botname" valueNotes="the name of the bot"/>
            <argument token="S" description="botskill" valueNotes="best, good, medium, worse, bad"/>
          </arguments>
          <examples>
            <example>
              <code><![CDATA[botskill Robbie best]]></code>
              <explanation>Changes the previous bot skill level of the bot named Robbie to a 'best' skill level.</explanation>
            </example>
          </examples>
        </command>

        <command name="botskillall">
          <description>Changes the skill level for all bots.</description>
          <arguments>
            <argument token="S" description="botskill" valueNotes="best, good, medium, worse, bad"/>
          </arguments>
          <examples>
            <example>
              <code><![CDATA[botskillall worse]]></code>
              <explanation>Changes the previous bot skill level for all bots to a 'worse' skill level.</explanation>
            </example>
          </examples>
        </command>

        <command name="botsshoot">
          <description>Enables or disables the ability of the bots to fire their weapons.</description>
          <arguments>
            <argument token="T" description="shooting bots?" valueNotes="0 or 1"/>
          </arguments>
          <examples>
            <example>
              <code><![CDATA[botsshoot 0]]></code>
              <explanation>Bots won't shoot.</explanation>
            </example>
          </examples>
        </command>

        <variable name="xhairwpsel">
          <description>Determines if bot waypoints should be selected/placed using the crosshair or by the nearest location to your player.</description>
          <value token="V" description="Note: This is turned on by default." minValue="0" maxValue="1" defaultValue="1"/>
        </variable>

        <command name="setjumpwp">
          <references>
            <identifierReference identifier="unsetjumpwp"/>
          </references>
        </command>

        <command name="unsetjumpwp">
          <references>
            <identifierReference identifier="setjumpwp"/>
          </references>
        </command>

        <command name="setwptriggernr">
          <description>Assigns a number to the nearest waypoint.</description>
          <remarks>
            <remark>This is only used for trigger waypoints, so that the bots go to triggers in the right order. If you don't do this bots will search for every trigger, even when they are not reachable yet.</remark>
          </remarks>
          <arguments>
            <argument token="N" description="number"/>
          </arguments>
        </command>

        <command name="wpclear"/>
        <command name="wpflood"/>
        <command name="wpinfo">
          <description>Makes waypoints visible and either turns on or off the waypoint information display.</description>
          <arguments>
            <argument token="Y" description="show info?" valueNotes="0 or 1"/>
          </arguments>
        </command>

        <command name="wpload"/>
        <command name="wpsave"/>
        <command name="wpvisible">
          <arguments>
            <argument token="V" description="visible" valueNotes="0 or 1"/>
          </arguments>
        </command>

        <command name="setwpyaw">
          <description>Takes the current player yaw for the current waypoint.</description>
        </command>

        <command name="togglebotview">
          <description>When used you will see what the bot sees.</description>
          <remarks>
            <remark>Type it again (with or without name) to return to the game (you will respawn).</remark>
          </remarks>
          <arguments>
            <argument token="N" description="botname" valueNotes="the name of the bot"/>
          </arguments>
        </command>

        <command name="addpath1way1"/>
        <command name="addpath1way2"/>
        <command name="addpath2way1"/>
        <command name="addpath2way2"/>
        <command name="addwp">
          <description>Adds a bot waypoint at the current position.</description>
          <arguments>
            <argument token="A" description="connect automatically" valueNotes="0 or 1"/>
          </arguments>
        </command>

        <command name="autowp">
          <description>Automatically places waypoints.</description>
          <argument token="O" description="on" valueNotes="0 or 1"/>
        </command>

        <command name="delpath1way1"/>
        <command name="delpath1way2"/>
        <command name="delpath2way1"/>
        <command name="delpath2way2"/>
        <command name="delwp">
          <description>Deletes the selected waypoint.</description>
        </command>

      </identifiers>
    </section>
    <!-- Bot mode Section Ends -->
    <!-- Optional Section Starts -->
    <section name="Optional" sortindex="16">
      <description>This section describes optional identifiers from the files in config/opt/ folder and commands, which enable them.</description>
      <identifiers sort="true">

        <scriptalias name="load_autosave">
          <description>Loads optional obsolete autosave settings.</description>
          <remarks>
            <remark>To see the obsolete autosave settings, look at config/opt/autosave.cfg file.</remark>
          </remarks>
        </scriptalias>

        <scriptalias name="load_compatibility">
          <description>Loads optional compatibility settings for old scripts.</description>
          <remarks>
            <remark>To see the compatibility settings, look at config/opt/compatibility.cfg file.</remark>
          </remarks>
        </scriptalias>

        <scriptalias name="load_survival">
          <description>Loads optional settings for bot survival mode.</description>
          <remarks>
            <remark>To see the settings for survival, look at config/opt/survival.cfg file.</remark>
            <remark>The settings are loaded, when bot survival mode is started via menu.</remark>
          </remarks>
        </scriptalias>

        <scriptalias name="load_parsestring">
          <description>Loads optional settings for string parsing.</description>
          <remarks>
            <remark>To see the string parsing settings, look at config/opt/parsestring.cfg file.</remark>
          </remarks>
        </scriptalias>

        <scriptalias name="load_faq">
          <description>Loads optional FAQ settings.</description>
          <remarks>
            <remark>To see the FAQ settings, look at config/opt/faq.cfg file.</remark>
            <remark>The settings are loaded, when FAQ is open in menu.</remark>
          </remarks>
        </scriptalias>

        <scriptalias name="load_convmap">
          <description>Loads batch map conversion tools.</description>
          <remarks>
            <remark>To see the map conversion tools, look at config/opt/convmap.cfg file.</remark>
          </remarks>
        </scriptalias>

        <scriptalias name="load_mapeditscripts">
          <description>Loads extra map editing scripts.</description>
          <remarks>
            <remark>To see the map editing scripts, look at config/opt/mapeditscripts.cfg file.</remark>
          </remarks>
        </scriptalias>

        <command name="parsestring">
          <description>Loops through every character in the given string and executes the given block of cubescript on each iteration.</description>
          <examples>
            <example>
              <code><![CDATA[parsestring "Hello world" iter [echo $iter]]]></code>
              <explanation>Uses echo on every character in the string: "Hello world"</explanation>
            </example>
            <example>
              <code><![CDATA[parsestring "Hello world" iter [echo (concatword "Char #" $__iter ": " $iter)]]]></code>
              <explanation>Uses echo on every character in the string: "Hello world" --- Also outputs the position of each character in the string.</explanation>
            </example>
            <example>
              <code><![CDATA[backwardsstring = []; parsestring "This will look interesting backwards." iter [backwardsstring = (concatword $backwardsstring $iter); if (= $__iter 0) [echo $backwardsstring]] 1]]></code>
              <explanation>Outputs: ".sdrawkcab gnitseretni kool lliw sihT"</explanation>
            </example>
            <example>
              <code><![CDATA[parsestring "abcdefghijklmnopqrstuvwxyz" iter [if (> $__iter 4) breakparse [echo $iter]]]]></code>
              <explanation>Example usage of the breakparse command. Uses echo on characters a through e, then breaks out of the parse.</explanation>
            </example>
          </examples>
          <arguments>
            <argument token="S" description="string" valueNotes="string to parse"/>
            <argument token="A" description="string" valueNotes="name of alias to use as iterator"/>
            <argument token="C" description="string" valueNotes="cubescript to execute on each iteration"/>
            <argument token="B" description="integer" valueNotes="non-zero to force backwards parse" optional="true"/>
          </arguments>
          <remarks>
            <remark>Important: A secondary iterator alias (prefixed with a double underscore "__") is automatically created before each iteration that contains the character position data.</remark>
          </remarks>
          <references>
            <identifierReference identifier="load_parsestring"/>
            <identifierReference identifier="breakparse"/>
            <identifierReference identifier="substr"/>
            <identifierReference identifier="trimAllWhitespace"/>
            <identifierReference identifier="trimAllUnnecessaryWhitespace"/>
          </references>
        </command>

        <command name="breakparse">
          <description>Breaks out of a parsestring loop.</description>
          <remarks>
            <remark>Important: this command should only be used within the 3rd argument (the cubescript to execute) of parsestring.</remark>
          </remarks>
          <references>
            <identifierReference identifier="load_parsestring"/>
            <identifierReference identifier="parsestring"/>
          </references>
        </command>

        <command name="trimAllWhitespace">
          <description>Removes all whitespace characters from the given string.</description>
          <examples>
            <example>
              <code><![CDATA[echo (trimAllWhitespace "    H   e ll     o w  o r   l d     ")]]></code>
              <explanation>Outputs: Helloworld</explanation>
            </example>
          </examples>
          <arguments>
            <argument token="S" description="string" valueNotes="string to modify"/>
          </arguments>
          <references>
            <identifierReference identifier="load_parsestring"/>
            <identifierReference identifier="trimAllUnnecessaryWhitespace"/>
            <identifierReference identifier="parsestring"/>
          </references>
        </command>

        <command name="trimAllUnnecessaryWhitespace">
          <description>Removes all unnecessary leading and trailing whitespace characters from the given string.</description>
          <examples>
            <example>
              <code><![CDATA[echo (trimAllUnnecessaryWhitespace "    H   e ll     o w  o r   l d     ")]]></code>
              <explanation>Outputs: "H   e ll     o w  o r   l d"</explanation>
            </example>
          </examples>
          <arguments>
            <argument token="S" description="string" valueNotes="string to modify"/>
          </arguments>
          <references>
            <identifierReference identifier="load_parsestring"/>
            <identifierReference identifier="trimAllWhitespace"/>
            <identifierReference identifier="parsestring"/>
          </references>
        </command>

        <command name="survival">
          <description>Prepares a round of bot survival mode on the specified map.</description>
          <remarks>
            <remark>
            All official maps are compatible with survival, if you want to play survival on a custom map,
            prior edits/additions to the script are necessary, such as adding a zone for that specific map.
            </remark>
          </remarks>
          <arguments>
            <argument token="M" description="the map to use"/>
            <argument token="D" description="the difficulty" valueNotes="0 = easy, 1 = intermediate, 2 = hard, 3 = impossible" optional="true"/>
          </arguments>
          <references>
            <identifierReference identifier="load_survival"/>
          </references>
        </command>

        <command name="changegamma">
          <description>Smoothly changes your gamma to the specified value.</description>
          <remarks>
            <remark>Remark: that's optional command, disabled by default, to enable it execute "run opt/survival" or start bot surival mode from menu.</remark>
          </remarks>
          <arguments>
            <argument token="G" description="the gamma to change to"/>
            <argument token="M" description="milliseconds between gamma changes"/>
          </arguments>
          <examples>
            <example>
              <code><![CDATA[changegamma 300 30]]></code>
              <explanation>Every 30 milliseconds your gamma is changed by 1 until it reaches its goal of gamma 300.</explanation>
            </example>
          </examples>
          <references>
            <identifierReference identifier="load_survival"/>
            <identifierReference identifier="gamma"/>
            <identifierReference identifier="changespeed"/>
          </references>
        </command>

        <command name="changespeed">
          <description>Smoothly changes your gamespeed to the specified value.</description>
          <remarks>
            <remark>Remark: that's optional command, disabled by default, to enable it execute "run opt/survival" or start bot surival mode from menu.</remark>
          </remarks>
          <arguments>
            <argument token="S" description="the gamespeed to change to"/>
            <argument token="M" description="milliseconds between gamespeed changes"/>
          </arguments>
          <examples>
            <example>
              <code><![CDATA[changespeed 1000 30]]></code>
              <explanation>Every 30 milliseconds your gamespeed is changed by 1 until it reaches its goal of gamespeed 1000.</explanation>
            </example>
          </examples>
          <references>
            <identifierReference identifier="load_survival"/>
            <identifierReference identifier="gamespeed"/>
            <identifierReference identifier="changegamma"/>
          </references>
        </command>

        <command name="alive">
          <description>Returns 1 if the local player is alive.</description>
          <examples>
            <example>
              <code><![CDATA[echo (alive)]]></code>
              <explanation>Output: 1</explanation>
            </example>
          </examples>
          <references>
            <identifierReference identifier="load_compatibility"/>
          </references>
        </command>

        <command name="curmode">
          <description>Returns the mode number for the current game.</description>
          <references>
            <identifierReference identifier="load_compatibility"/>
            <identifierReference identifier="gamemode"/>
            <identifierReference identifier="curmap"/>
            <identifierReference identifier="map"/>
            <identifierReference identifier="mode"/>
          </references>
        </command>

        <command name="currole">
          <description>Returns 1 if the local player has admin privileges, 0 otherwise.</description>
          <references>
            <identifierReference identifier="load_compatibility"/>
            <identifierReference identifier="setadmin"/>
            <identifierReference identifier="connectadmin"/>
          </references>
        </command>

        <command name="curteam">
          <description>Returns an integer indicating what team a client is currently on.</description>
          <arguments>
            <argument token="C" description="client number" valueNotes="returns the specified client's team instead" optional="true"/>
          </arguments>
          <remarks>
            <remark>Returns 0 for CLA, 1 for RVSF.</remark>
            <remark>Returns 2 for CLA-spectator, 3 for RVSF-spectator.</remark>
            <remark>Returns 4 for spectator.</remark>
            <remark>By default this command returns what team *you* (player1) are currently on.</remark>
          </remarks>
          <references>
            <identifierReference identifier="load_compatibility"/>
            <identifierReference identifier="team"/>
            <identifierReference identifier="forceteam"/>
            <identifierReference identifier="skin"/>
          </references>
        </command>

        <command name="findpn">
          <description>Finds player name with this client number.</description>
          <arguments>
            <argument token="CN" description="client number"/>
          </arguments>
          <references>
            <identifierReference identifier="load_compatibility"/>
          </references>
        </command>

        <command name="getclientmode">
          <description>Returns the current game mode number.</description>
          <references>
            <identifierReference identifier="load_compatibility"/>
          </references>
        </command>

        <variable name="orderscorecolumns">
          <description>Show the client number column on the scoreboard first?</description>
          <value token="N" description="CN column order" minValue="0" maxValue="1" defaultValue="0" valueNotes="0 (false), 1 (true)"/>
          <references>
            <identifierReference identifier="load_compatibility"/>
          </references>
        </variable>

        <command name="pstat_score">
          <description>Returns the score statistics for the player with the given client number.</description>
          <arguments>
            <argument token="CN" description="client number" valueNotes="0..N"/>
          </arguments>
          <examples>
            <example>
              <code>
                <![CDATA[
                echo (pstat_score 0)
                ]]>
              </code>
              <explanation>Output: 0 5 3 43 1 1 unarmed</explanation>
              <explanation>The output is a list of FLAGS, FRAGS, DEATHS, POINTS, TEAM, TEAMKILLS, and NAME.</explanation>
            </example>
          </examples>
          <references>
            <identifierReference identifier="load_compatibility"/>
            <identifierReference identifier="start_intermission"/>
            <identifierReference identifier="pstat_weap"/>
          </references>
        </command>

        <command name="showedithide">
          <description>Shows the settings for hidden entities (sparklies).</description>
          <references>
            <identifierReference identifier="setedithide"/>
            <identifierReference identifier="seteditshow"/>
          </references>
        </command>

        <command name="setedithide">
          <description>Hides the list of entity types you set.</description>
          <arguments>
            <argument token="L" description="list of entity types to hide" valueNotes="light, playerstart, pistol, ammobox, grenades, health, helmet, armour, akimbo, mapmodel, ladder, ctf-flag, sound, clip, plclip"/>
          </arguments>
          <remarks>
            <remark>Call "setedithide [lights mapmodels]" to just hide all lights and mapmodels.</remark>
            <remark>Only shown entity types are potential 'closest entity'.</remark>
            <remark>"setedithide" without any arguments restores visibility of all entities.</remark>
          </remarks>
          <references>
            <identifierReference identifier="seteditshow"/>
            <identifierReference identifier="showedithide"/>
          </references>
        </command>

        <command name="seteditshow">
          <description>Hides all but the single entity type you give.</description>
          <arguments>
            <argument token="T" description="the entity type to show exclusively" valueNotes="light, playerstart, pistol, ammobox, grenades, health, helmet, armour, akimbo, mapmodel, ladder, ctf-flag, sound, clip, plclip"/>
          </arguments>
          <remarks>
            <remark>Just run "seteditshow mapmodel" and see just the mapmodel entities.</remark>
            <remark>The other entity types are ignored as closestentity too.</remark>
            <remark>"seteditshow" without any argument hides all entities.</remark>
          </remarks>
          <references>
            <identifierReference identifier="setedithide"/>
            <identifierReference identifier="showedithide"/>
          </references>
        </command>

        <command name="++">
          <description>Increments an alias by 1.</description>
          <arguments>
            <argument token="A" description="the alias name"/>
          </arguments>
          <examples>
            <example>
              <code>i = 0; ++ i; echo $i</code>
              <explanation>Output: 1</explanation>
            </example>
          </examples>
          <references>
            <identifierReference identifier="--"/>
            <identifierReference identifier="++f"/>
            <identifierReference identifier="--f"/>
          </references>
        </command>

        <command name="++f">
          <description>Increments an alias by floating-point 1.</description>
          <arguments>
            <argument token="A" description="the alias name"/>
          </arguments>
          <examples>
            <example>
              <code>i = 2.14; ++f i; echo $i</code>
              <explanation>Output: 3.14</explanation>
            </example>
          </examples>
          <references>
            <identifierReference identifier="--f"/>
            <identifierReference identifier="++"/>
            <identifierReference identifier="--"/>
          </references>
        </command>

        <command name="--">
          <description>Decrements an alias by 1.</description>
          <arguments>
            <argument token="A" description="the alias name"/>
          </arguments>
          <examples>
            <example>
              <code>i = 0; -- i; echo $i</code>
              <explanation>Output: -1</explanation>
            </example>
          </examples>
          <references>
            <identifierReference identifier="++"/>
            <identifierReference identifier="--f"/>
            <identifierReference identifier="++f"/>
          </references>
        </command>

        <command name="--f">
          <description>Decrements an alias by floating-point 1.</description>
          <arguments>
            <argument token="A" description="the alias name"/>
          </arguments>
          <examples>
            <example>
              <code>i = 4.14; --f i; echo $i</code>
              <explanation>Output: 3.14</explanation>
            </example>
          </examples>
          <references>
            <identifierReference identifier="++f"/>
            <identifierReference identifier="--"/>
            <identifierReference identifier="++"/>
          </references>
        </command>

      </identifiers>
    </section>
    <!-- Optional Section Ends -->
    <!-- TODO Section Starts -->
    <section name="TODO" sortindex="99">
      <description>This section describes identifiers that are not documented yet, but you may try to help us there.</description>
      <identifiers sort="true">

      </identifiers>
    </section>
    <!-- "TODO" Section Ends -->
  </sections>
</cuberef>
